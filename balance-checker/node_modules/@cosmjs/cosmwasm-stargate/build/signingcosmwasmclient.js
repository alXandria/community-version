"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningCosmWasmClient = exports.defaultGasLimits = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const amino_1 = require("@cosmjs/amino");
const cosmwasm_launchpad_1 = require("@cosmjs/cosmwasm-launchpad");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const math_1 = require("@cosmjs/math");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const tx_1 = require("@cosmjs/stargate/build/codec/cosmos/distribution/v1beta1/tx");
const tx_2 = require("@cosmjs/stargate/build/codec/cosmos/staking/v1beta1/tx");
const signing_1 = require("@cosmjs/stargate/build/codec/cosmos/tx/signing/v1beta1/signing");
const tx_3 = require("@cosmjs/stargate/build/codec/cosmos/tx/v1beta1/tx");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const long_1 = __importDefault(require("long"));
const pako_1 = __importDefault(require("pako"));
const aminotypes_1 = require("./aminotypes");
const tx_4 = require("./codec/cosmwasm/wasm/v1beta1/tx");
const cosmwasmclient_1 = require("./cosmwasmclient");
function prepareBuilder(builder) {
    if (builder === undefined) {
        return ""; // normalization needed by backend
    }
    else {
        if (!cosmwasm_launchpad_1.isValidBuilder(builder))
            throw new Error("The builder (Docker Hub image with tag) is not valid");
        return builder;
    }
}
exports.defaultGasLimits = Object.assign(Object.assign({}, stargate_1.defaultGasLimits), { upload: 1500000, init: 500000, migrate: 200000, exec: 200000, changeAdmin: 80000 });
function createBroadcastTxErrorMessage(result) {
    return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
}
function createDefaultRegistry() {
    return new proto_signing_1.Registry([
        ...stargate_1.defaultRegistryTypes,
        ["/cosmwasm.wasm.v1beta1.MsgClearAdmin", tx_4.MsgClearAdmin],
        ["/cosmwasm.wasm.v1beta1.MsgExecuteContract", tx_4.MsgExecuteContract],
        ["/cosmwasm.wasm.v1beta1.MsgMigrateContract", tx_4.MsgMigrateContract],
        ["/cosmwasm.wasm.v1beta1.MsgStoreCode", tx_4.MsgStoreCode],
        ["/cosmwasm.wasm.v1beta1.MsgInstantiateContract", tx_4.MsgInstantiateContract],
        ["/cosmwasm.wasm.v1beta1.MsgUpdateAdmin", tx_4.MsgUpdateAdmin],
    ]);
}
class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
    constructor(tmClient, signer, options) {
        super(tmClient);
        const { registry = createDefaultRegistry(), aminoTypes = new stargate_1.AminoTypes({ additions: aminotypes_1.cosmWasmTypes, prefix: options.prefix }), gasPrice = stargate_1.defaultGasPrice, gasLimits = {}, } = options;
        this.fees = stargate_1.buildFeeTable(gasPrice, exports.defaultGasLimits, gasLimits);
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
    }
    static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new SigningCosmWasmClient(tmClient, signer, options);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static async offline(signer, options = {}) {
        return new SigningCosmWasmClient(undefined, signer, options);
    }
    /** Uploads code and returns a receipt, including the code ID */
    async upload(senderAddress, wasmCode, meta = {}, memo = "") {
        const source = meta.source || "";
        const builder = prepareBuilder(meta.builder);
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgStoreCode",
            value: tx_4.MsgStoreCode.fromPartial({
                sender: senderAddress,
                wasmByteCode: compressed,
                source: source,
                builder: builder,
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], this.fees.upload, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const codeIdAttr = stargate_1.logs.findAttribute(parsedLogs, "message", "code_id");
        return {
            originalSize: wasmCode.length,
            originalChecksum: encoding_1.toHex(crypto_1.sha256(wasmCode)),
            compressedSize: compressed.length,
            compressedChecksum: encoding_1.toHex(crypto_1.sha256(compressed)),
            codeId: Number.parseInt(codeIdAttr.value, 10),
            logs: parsedLogs,
            transactionHash: result.transactionHash,
        };
    }
    async instantiate(senderAddress, codeId, msg, label, options = {}) {
        const instantiateContractMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgInstantiateContract",
            value: tx_4.MsgInstantiateContract.fromPartial({
                sender: senderAddress,
                codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
                label: label,
                initMsg: encoding_1.toUtf8(JSON.stringify(msg)),
                funds: [...(options.transferAmount || [])],
                admin: options.admin,
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], this.fees.init, options.memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
        const contractAddressAttr = stargate_1.logs.findAttribute(parsedLogs, "message", "contract_address");
        return {
            contractAddress: contractAddressAttr.value,
            logs: parsedLogs,
            transactionHash: result.transactionHash,
        };
    }
    async updateAdmin(senderAddress, contractAddress, newAdmin, memo = "") {
        const updateAdminMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgUpdateAdmin",
            value: tx_4.MsgUpdateAdmin.fromPartial({
                sender: senderAddress,
                contract: contractAddress,
                newAdmin: newAdmin,
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], this.fees.changeAdmin, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: stargate_1.logs.parseRawLog(result.rawLog),
            transactionHash: result.transactionHash,
        };
    }
    async clearAdmin(senderAddress, contractAddress, memo = "") {
        const clearAdminMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgClearAdmin",
            value: tx_4.MsgClearAdmin.fromPartial({
                sender: senderAddress,
                contract: contractAddress,
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], this.fees.changeAdmin, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: stargate_1.logs.parseRawLog(result.rawLog),
            transactionHash: result.transactionHash,
        };
    }
    async migrate(senderAddress, contractAddress, codeId, migrateMsg, memo = "") {
        const migrateContractMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgMigrateContract",
            value: tx_4.MsgMigrateContract.fromPartial({
                sender: senderAddress,
                contract: contractAddress,
                codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),
                migrateMsg: encoding_1.toUtf8(JSON.stringify(migrateMsg)),
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], this.fees.migrate, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: stargate_1.logs.parseRawLog(result.rawLog),
            transactionHash: result.transactionHash,
        };
    }
    async execute(senderAddress, contractAddress, msg, memo = "", funds) {
        const executeContractMsg = {
            typeUrl: "/cosmwasm.wasm.v1beta1.MsgExecuteContract",
            value: tx_4.MsgExecuteContract.fromPartial({
                sender: senderAddress,
                contract: contractAddress,
                msg: encoding_1.toUtf8(JSON.stringify(msg)),
                funds: [...(funds || [])],
            }),
        };
        const result = await this.signAndBroadcast(senderAddress, [executeContractMsg], this.fees.exec, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: stargate_1.logs.parseRawLog(result.rawLog),
            transactionHash: result.transactionHash,
        };
    }
    async sendTokens(senderAddress, recipientAddress, amount, memo = "") {
        const sendMsg = {
            typeUrl: "/cosmos.bank.v1beta1.MsgSend",
            value: {
                fromAddress: senderAddress,
                toAddress: recipientAddress,
                amount: [...amount],
            },
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], this.fees.send, memo);
    }
    async delegateTokens(delegatorAddress, validatorAddress, amount, memo = "") {
        const delegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
            value: tx_2.MsgDelegate.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress, amount }),
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], this.fees.delegate, memo);
    }
    async undelegateTokens(delegatorAddress, validatorAddress, amount, memo = "") {
        const undelegateMsg = {
            typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
            value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress, amount }),
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], this.fees.undelegate, memo);
    }
    async withdrawRewards(delegatorAddress, validatorAddress, memo = "") {
        const withdrawDelegatorRewardMsg = {
            typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
            value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress }),
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], this.fees.withdraw, memo);
    }
    /**
     * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.
     *
     * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
     * @param messages
     * @param fee
     * @param memo
     */
    async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        const txRaw = await this.sign(signerAddress, messages, fee, memo);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
            signerData = explicitSignerData;
        }
        else {
            const { accountNumber, sequence } = await this.getSequence(signerAddress);
            const chainId = await this.getChainId();
            signerData = {
                accountNumber: accountNumber,
                sequence: sequence,
                chainId: chainId,
            };
        }
        return proto_signing_1.isOfflineDirectSigner(this.signer)
            ? this.signDirect(signerAddress, messages, fee, memo, signerData)
            : this.signAmino(signerAddress, messages, fee, memo, signerData);
    }
    async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        utils_1.assert(!proto_signing_1.isOfflineDirectSigner(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: {
                messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
                memo: signed.memo,
            },
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBody);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], signed.fee.amount, signedGasLimit, signedSequence, signMode);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signedTxBodyBytes,
            authInfoBytes: signedAuthInfoBytes,
            signatures: [encoding_1.fromBase64(signature.signature)],
        });
    }
    async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        utils_1.assert(proto_signing_1.isOfflineDirectSigner(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
            throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));
        const txBody = {
            typeUrl: "/cosmos.tx.v1beta1.TxBody",
            value: {
                messages: messages,
                memo: memo,
            },
        };
        const txBodyBytes = this.registry.encode(txBody);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], fee.amount, gasLimit, sequence);
        const signDoc = proto_signing_1.makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
            bodyBytes: signed.bodyBytes,
            authInfoBytes: signed.authInfoBytes,
            signatures: [encoding_1.fromBase64(signature.signature)],
        });
    }
}
exports.SigningCosmWasmClient = SigningCosmWasmClient;
//# sourceMappingURL=signingcosmwasmclient.js.map