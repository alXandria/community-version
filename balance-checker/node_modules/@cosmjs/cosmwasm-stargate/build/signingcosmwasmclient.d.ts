import { ChangeAdminResult, ExecuteResult, InstantiateOptions, InstantiateResult, MigrateResult, UploadMeta, UploadResult } from "@cosmjs/cosmwasm-launchpad";
import { EncodeObject, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { AminoTypes, BroadcastTxResponse, Coin, CosmosFeeTable, GasLimits, GasPrice, SignerData, StdFee } from "@cosmjs/stargate";
import { TxRaw } from "@cosmjs/stargate/build/codec/cosmos/tx/v1beta1/tx";
import { Tendermint34Client } from "@cosmjs/tendermint-rpc";
import { CosmWasmClient } from "./cosmwasmclient";
export { ChangeAdminResult, // returned by SigningCosmWasmClient.updateAdmin/SigningCosmWasmClient.clearAdmin
ExecuteResult, // returned by SigningCosmWasmClient.execute
InstantiateOptions, // argument type of SigningCosmWasmClient.instantiate
InstantiateResult, // returned by SigningCosmWasmClient.instantiate
MigrateResult, // returned by SigningCosmWasmClient.migrate
UploadMeta, // argument type of SigningCosmWasmClient.upload
UploadResult, };
/**
 * These fees are used by the higher level methods of SigningCosmWasmClient
 */
export interface CosmWasmFeeTable extends CosmosFeeTable {
    readonly upload: StdFee;
    readonly init: StdFee;
    readonly exec: StdFee;
    readonly migrate: StdFee;
    /** Paid when setting the contract admin to a new address or unsetting it */
    readonly changeAdmin: StdFee;
}
export declare const defaultGasLimits: GasLimits<CosmWasmFeeTable>;
export interface SigningCosmWasmClientOptions {
    readonly registry?: Registry;
    readonly aminoTypes?: AminoTypes;
    readonly prefix?: string;
    readonly gasPrice?: GasPrice;
    readonly gasLimits?: Partial<GasLimits<CosmWasmFeeTable>>;
    readonly broadcastTimeoutMs?: number;
    readonly broadcastPollIntervalMs?: number;
}
export declare class SigningCosmWasmClient extends CosmWasmClient {
    readonly fees: CosmWasmFeeTable;
    readonly registry: Registry;
    readonly broadcastTimeoutMs: number | undefined;
    readonly broadcastPollIntervalMs: number | undefined;
    private readonly signer;
    private readonly aminoTypes;
    static connectWithSigner(endpoint: string, signer: OfflineSigner, options?: SigningCosmWasmClientOptions): Promise<SigningCosmWasmClient>;
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static offline(signer: OfflineSigner, options?: SigningCosmWasmClientOptions): Promise<SigningCosmWasmClient>;
    protected constructor(tmClient: Tendermint34Client | undefined, signer: OfflineSigner, options: SigningCosmWasmClientOptions);
    /** Uploads code and returns a receipt, including the code ID */
    upload(senderAddress: string, wasmCode: Uint8Array, meta?: UploadMeta, memo?: string): Promise<UploadResult>;
    instantiate(senderAddress: string, codeId: number, msg: Record<string, unknown>, label: string, options?: InstantiateOptions): Promise<InstantiateResult>;
    updateAdmin(senderAddress: string, contractAddress: string, newAdmin: string, memo?: string): Promise<ChangeAdminResult>;
    clearAdmin(senderAddress: string, contractAddress: string, memo?: string): Promise<ChangeAdminResult>;
    migrate(senderAddress: string, contractAddress: string, codeId: number, migrateMsg: Record<string, unknown>, memo?: string): Promise<MigrateResult>;
    execute(senderAddress: string, contractAddress: string, msg: Record<string, unknown>, memo?: string, funds?: readonly Coin[]): Promise<ExecuteResult>;
    sendTokens(senderAddress: string, recipientAddress: string, amount: readonly Coin[], memo?: string): Promise<BroadcastTxResponse>;
    delegateTokens(delegatorAddress: string, validatorAddress: string, amount: Coin, memo?: string): Promise<BroadcastTxResponse>;
    undelegateTokens(delegatorAddress: string, validatorAddress: string, amount: Coin, memo?: string): Promise<BroadcastTxResponse>;
    withdrawRewards(delegatorAddress: string, validatorAddress: string, memo?: string): Promise<BroadcastTxResponse>;
    /**
     * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.
     *
     * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
     * @param messages
     * @param fee
     * @param memo
     */
    signAndBroadcast(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo?: string): Promise<BroadcastTxResponse>;
    sign(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, explicitSignerData?: SignerData): Promise<TxRaw>;
    private signAmino;
    private signDirect;
}
