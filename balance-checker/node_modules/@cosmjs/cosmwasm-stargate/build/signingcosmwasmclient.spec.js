"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const tx_1 = require("@cosmjs/stargate/build/codec/cosmos/bank/v1beta1/tx");
const coin_1 = require("@cosmjs/stargate/build/codec/cosmos/base/v1beta1/coin");
const tx_2 = require("@cosmjs/stargate/build/codec/cosmos/staking/v1beta1/tx");
const tx_3 = require("@cosmjs/stargate/build/codec/cosmos/tx/v1beta1/tx");
const utils_1 = require("@cosmjs/utils");
const long_1 = __importDefault(require("long"));
const pako_1 = __importDefault(require("pako"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const signingcosmwasmclient_1 = require("./signingcosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
describe("SigningCosmWasmClient", () => {
    describe("connectWithSigner", () => {
        it("can be constructed", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client).toBeTruthy();
        });
        it("can be constructed with custom registry", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const registry = new proto_signing_1.Registry();
            registry.register("/custom.MsgCustom", tx_1.MsgSend);
            const options = { prefix: testutils_spec_1.wasmd.prefix, registry: registry };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client.registry.lookupType("/custom.MsgCustom")).toEqual(tx_1.MsgSend);
        });
        it("can be constructed with custom gas price", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = {
                prefix: testutils_spec_1.wasmd.prefix,
                gasPrice: stargate_1.GasPrice.fromString("3.14utest"),
            };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client.fees).toEqual({
                upload: {
                    amount: stargate_1.coins(4710000, "utest"),
                    gas: "1500000",
                },
                init: {
                    amount: stargate_1.coins(1570000, "utest"),
                    gas: "500000",
                },
                migrate: {
                    amount: stargate_1.coins(628000, "utest"),
                    gas: "200000",
                },
                exec: {
                    amount: stargate_1.coins(628000, "utest"),
                    gas: "200000",
                },
                send: {
                    amount: stargate_1.coins(251200, "utest"),
                    gas: "80000",
                },
                changeAdmin: {
                    amount: stargate_1.coins(251200, "utest"),
                    gas: "80000",
                },
                delegate: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                transfer: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                undelegate: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                withdraw: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
            });
        });
        it("can be constructed with custom gas limits", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = {
                prefix: testutils_spec_1.wasmd.prefix,
                gasLimits: {
                    send: 160000,
                },
            };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client.fees).toEqual({
                upload: {
                    amount: stargate_1.coins(37500, "ucosm"),
                    gas: "1500000",
                },
                init: {
                    amount: stargate_1.coins(12500, "ucosm"),
                    gas: "500000",
                },
                migrate: {
                    amount: stargate_1.coins(5000, "ucosm"),
                    gas: "200000",
                },
                exec: {
                    amount: stargate_1.coins(5000, "ucosm"),
                    gas: "200000",
                },
                send: {
                    amount: stargate_1.coins(4000, "ucosm"),
                    gas: "160000",
                },
                changeAdmin: {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "80000",
                },
                delegate: {
                    amount: stargate_1.coins(4000, "ucosm"),
                    gas: "160000",
                },
                transfer: {
                    amount: stargate_1.coins(4000, "ucosm"),
                    gas: "160000",
                },
                undelegate: {
                    amount: stargate_1.coins(4000, "ucosm"),
                    gas: "160000",
                },
                withdraw: {
                    amount: stargate_1.coins(4000, "ucosm"),
                    gas: "160000",
                },
            });
        });
        it("can be constructed with custom gas price and gas limits", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = {
                prefix: testutils_spec_1.wasmd.prefix,
                gasPrice: stargate_1.GasPrice.fromString("3.14utest"),
                gasLimits: {
                    send: 160000,
                },
            };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            expect(client.fees).toEqual({
                upload: {
                    amount: stargate_1.coins(4710000, "utest"),
                    gas: "1500000",
                },
                init: {
                    amount: stargate_1.coins(1570000, "utest"),
                    gas: "500000",
                },
                migrate: {
                    amount: stargate_1.coins(628000, "utest"),
                    gas: "200000",
                },
                exec: {
                    amount: stargate_1.coins(628000, "utest"),
                    gas: "200000",
                },
                send: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                changeAdmin: {
                    amount: stargate_1.coins(251200, "utest"),
                    gas: "80000",
                },
                delegate: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                transfer: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                undelegate: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
                withdraw: {
                    amount: stargate_1.coins(502400, "utest"),
                    gas: "160000",
                },
            });
        });
    });
    describe("upload", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const wasm = testutils_spec_1.getHackatom().data;
            const { codeId, originalChecksum, originalSize, compressedChecksum, compressedSize } = await client.upload(testutils_spec_1.alice.address0, wasm);
            expect(originalChecksum).toEqual(encoding_1.toHex(crypto_1.sha256(wasm)));
            expect(originalSize).toEqual(wasm.length);
            expect(compressedChecksum).toMatch(/^[0-9a-f]{64}$/);
            expect(compressedSize).toBeLessThan(wasm.length * 0.5);
            expect(codeId).toBeGreaterThanOrEqual(1);
        });
        it("can set builder and source", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const hackatom = testutils_spec_1.getHackatom();
            const meta = {
                source: "https://crates.io/api/v1/crates/cw-nameservice/0.1.0/download",
                builder: "confio/cosmwasm-opt:0.6.2",
            };
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, hackatom.data, meta);
            const codeDetails = await client.getCodeDetails(codeId);
            expect(codeDetails.source).toEqual(meta.source);
            expect(codeDetails.builder).toEqual(meta.builder);
        });
    });
    describe("instantiate", () => {
        it("works with transfer amount", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const funds = [stargate_1.coin(1234, "ucosm"), stargate_1.coin(321, "ustake")];
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                memo: "Let's see if the memo is used",
                transferAmount: funds,
            });
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const ucosmBalance = await wasmClient.bank.balance(contractAddress, "ucosm");
            expect(ucosmBalance).toEqual(funds[0]);
            const ustakeBalance = await wasmClient.bank.balance(contractAddress, "ustake");
            expect(ustakeBalance).toEqual(funds[1]);
        });
        it("works with admin", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", { admin: testutils_spec_1.unused.address });
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const { contractInfo } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo);
            expect(contractInfo.admin).toEqual(testutils_spec_1.unused.address);
        });
        it("can instantiate one code multiple times", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const contractAddress1 = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: testutils_spec_1.makeRandomAddress(),
            }, "contract 1");
            const contractAddress2 = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: testutils_spec_1.makeRandomAddress(),
            }, "contract 2");
            expect(contractAddress1).not.toEqual(contractAddress2);
        });
    });
    describe("updateAdmin", () => {
        it("can update an admin", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            await client.updateAdmin(testutils_spec_1.alice.address0, contractAddress, testutils_spec_1.unused.address);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo2);
            expect(contractInfo2.admin).toEqual(testutils_spec_1.unused.address);
        });
    });
    describe("clearAdmin", () => {
        it("can clear an admin", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            await client.clearAdmin(testutils_spec_1.alice.address0, contractAddress);
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo2);
            expect(contractInfo2.admin).toEqual("");
        });
    });
    describe("migrate", () => {
        it("can can migrate from one code ID to another", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId: codeId1 } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const { codeId: codeId2 } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId1, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const { contractInfo: contractInfo1 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo1);
            expect(contractInfo1.admin).toEqual(testutils_spec_1.alice.address0);
            const newVerifier = testutils_spec_1.makeRandomAddress();
            await client.migrate(testutils_spec_1.alice.address0, contractAddress, codeId2, { verifier: newVerifier });
            const { contractInfo: contractInfo2 } = await wasmClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contractInfo2);
            expect(Object.assign({}, contractInfo2)).toEqual(Object.assign(Object.assign({}, contractInfo1), { codeId: long_1.default.fromNumber(codeId2, true) }));
        });
    });
    describe("execute", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const { codeId } = await client.upload(testutils_spec_1.alice.address0, testutils_spec_1.getHackatom().data);
            // instantiate
            const funds = [stargate_1.coin(233444, "ucosm"), stargate_1.coin(5454, "ustake")];
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(testutils_spec_1.alice.address0, codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "amazing random contract", {
                transferAmount: funds,
            });
            // execute
            const result = await client.execute(testutils_spec_1.alice.address0, contractAddress, { release: {} }, undefined);
            const wasmEvent = result.logs[0].events.find((e) => e.type === "wasm");
            utils_1.assert(wasmEvent, "Event of type wasm expected");
            expect(wasmEvent.attributes).toContain({ key: "action", value: "release" });
            expect(wasmEvent.attributes).toContain({
                key: "destination",
                value: beneficiaryAddress,
            });
            // Verify token transfer from contract to beneficiary
            const wasmClient = await testutils_spec_1.makeWasmClient(testutils_spec_1.wasmd.endpoint);
            const beneficiaryBalanceUcosm = await wasmClient.bank.balance(beneficiaryAddress, "ucosm");
            expect(beneficiaryBalanceUcosm).toEqual(funds[0]);
            const beneficiaryBalanceUstake = await wasmClient.bank.balance(beneficiaryAddress, "ustake");
            expect(beneficiaryBalanceUstake).toEqual(funds[1]);
            const contractBalanceUcosm = await wasmClient.bank.balance(contractAddress, "ucosm");
            expect(contractBalanceUcosm).toEqual(stargate_1.coin(0, "ucosm"));
            const contractBalanceUstake = await wasmClient.bank.balance(contractAddress, "ustake");
            expect(contractBalanceUstake).toEqual(stargate_1.coin(0, "ustake"));
        });
    });
    describe("sendTokens", () => {
        it("works with direct signer", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const amount = stargate_1.coins(7890, "ucosm");
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.alice.address0, beneficiaryAddress, amount, memo);
            stargate_1.assertIsBroadcastTxSuccess(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            utils_1.assert(after);
            expect(after).toEqual(amount[0]);
        });
        it("works with legacy Amino signer", async () => {
            testutils_spec_1.pendingWithoutWasmd();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
            const options = { prefix: testutils_spec_1.wasmd.prefix };
            const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
            const amount = stargate_1.coins(7890, "ucosm");
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.alice.address0, beneficiaryAddress, amount, memo);
            stargate_1.assertIsBroadcastTxSuccess(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            utils_1.assert(after);
            expect(after).toEqual(amount[0]);
        });
    });
    describe("signAndBroadcast", () => {
        describe("direct mode", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: msgDelegateTypeUrl,
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: msgDelegateTypeUrl,
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
                await utils_1.sleep(1000);
                const searchResult = await client.getTx(result.transactionHash);
                utils_1.assert(searchResult, "Must find transaction");
                const tx = proto_signing_1.decodeTxRaw(searchResult.tx);
                // From ModifyingDirectSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect(Object.assign({}, tx.authInfo.fee.amount[0])).toEqual(stargate_1.coin(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msgSend = {
                    fromAddress: testutils_spec_1.alice.address0,
                    toAddress: testutils_spec_1.makeRandomAddress(),
                    amount: stargate_1.coins(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with staking MsgDelegate", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with wasm MsgStoreCode", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const { data, builder, source } = testutils_spec_1.getHackatom();
                const msgStoreCode = {
                    sender: testutils_spec_1.alice.address0,
                    wasmByteCode: pako_1.default.gzip(data),
                    source: source !== null && source !== void 0 ? source : "",
                    builder: builder !== null && builder !== void 0 ? builder : "",
                    instantiatePermission: undefined,
                };
                const msgAny = {
                    typeUrl: "/cosmwasm.wasm.v1beta1.MsgStoreCode",
                    value: msgStoreCode,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ustake"),
                    gas: "1500000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a custom registry and custom message", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = Object.assign({}, baseCustomMsgDelegate);
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new stargate_1.AminoTypes({
                    additions: {
                        "/cosmos.staking.v1beta1.MsgDelegate": {
                            aminoType: "cosmos-sdk/MsgDelegate",
                            toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                                utils_1.assert(customDelegatorAddress, "missing customDelegatorAddress");
                                utils_1.assert(customValidatorAddress, "missing validatorAddress");
                                utils_1.assert(customAmount, "missing amount");
                                utils_1.assert(customAmount.amount, "missing amount.amount");
                                utils_1.assert(customAmount.denom, "missing amount.denom");
                                return {
                                    delegator_address: customDelegatorAddress,
                                    validator_address: customValidatorAddress,
                                    amount: {
                                        amount: customAmount.amount,
                                        denom: customAmount.denom,
                                    },
                                };
                            },
                            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                                customDelegatorAddress: delegator_address,
                                customValidatorAddress: validator_address,
                                customAmount: coin_1.Coin.fromPartial(amount),
                            }),
                        },
                    },
                });
                const options = { prefix: testutils_spec_1.wasmd.prefix, registry: customRegistry, aminoTypes: customAminoTypes };
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.alice.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                stargate_1.assertIsBroadcastTxSuccess(result);
                await utils_1.sleep(1000);
                const searchResult = await client.getTx(result.transactionHash);
                utils_1.assert(searchResult, "Must find transaction");
                const tx = proto_signing_1.decodeTxRaw(searchResult.tx);
                // From ModifyingSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect(Object.assign({}, tx.authInfo.fee.amount[0])).toEqual(stargate_1.coin(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
            });
        });
    });
    describe("sign", () => {
        describe("direct mode", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingDirectSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect(Object.assign({}, authInfo.fee.amount[0])).toEqual(stargate_1.coin(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msgSend = {
                    fromAddress: testutils_spec_1.alice.address0,
                    toAddress: testutils_spec_1.makeRandomAddress(),
                    amount: stargate_1.coins(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with staking MsgDelegate", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a custom registry and custom message", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, { prefix: testutils_spec_1.wasmd.prefix });
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = Object.assign({}, baseCustomMsgDelegate);
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new stargate_1.AminoTypes({
                    additions: {
                        "/cosmos.staking.v1beta1.MsgDelegate": {
                            aminoType: "cosmos-sdk/MsgDelegate",
                            toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                                utils_1.assert(customDelegatorAddress, "missing customDelegatorAddress");
                                utils_1.assert(customValidatorAddress, "missing validatorAddress");
                                utils_1.assert(customAmount, "missing amount");
                                return {
                                    delegator_address: customDelegatorAddress,
                                    validator_address: customValidatorAddress,
                                    amount: {
                                        amount: customAmount.amount,
                                        denom: customAmount.denom,
                                    },
                                };
                            },
                            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                                customDelegatorAddress: delegator_address,
                                customValidatorAddress: validator_address,
                                customAmount: coin_1.Coin.fromPartial(amount),
                            }),
                        },
                    },
                });
                const options = { registry: customRegistry, aminoTypes: customAminoTypes };
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.alice.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutWasmd();
                const options = { prefix: testutils_spec_1.wasmd.prefix };
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, options);
                const client = await signingcosmwasmclient_1.SigningCosmWasmClient.connectWithSigner(testutils_spec_1.wasmd.endpoint, wallet, options);
                const msg = {
                    delegatorAddress: testutils_spec_1.alice.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: stargate_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: stargate_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.alice.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect(Object.assign({}, authInfo.fee.amount[0])).toEqual(stargate_1.coin(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargate_1.assertIsBroadcastTxSuccess(result);
            });
        });
    });
});
//# sourceMappingURL=signingcosmwasmclient.spec.js.map