"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const encoding_1 = require("@cosmjs/encoding");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const query_1 = require("../codec/cosmos/bank/v1beta1/query");
const coin_1 = require("../codec/cosmos/base/v1beta1/coin");
const testutils_spec_1 = require("../testutils.spec");
const queryclient_1 = require("./queryclient");
const utils_1 = require("./utils");
async function makeClient(rpcUrl) {
    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(rpcUrl);
    return [queryclient_1.QueryClient.withExtensions(tmClient), tmClient];
}
describe("QueryClient", () => {
    describe("queryVerified", () => {
        it("works via WebSockets", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClient(testutils_spec_1.simapp.tendermintUrlWs);
            const key = Uint8Array.from([
                ...encoding_1.toAscii("balances"),
                ...utils_1.toAccAddress(testutils_spec_1.unused.address),
                ...encoding_1.toAscii(testutils_spec_1.simapp.denomFee),
            ]);
            const data = await client.queryVerified("bank", key);
            const response = coin_1.Coin.decode(data);
            expect(response.amount).toMatch(testutils_spec_1.nonNegativeIntegerMatcher);
            expect(response.denom).toEqual(testutils_spec_1.simapp.denomFee);
            tmClient.disconnect();
        });
        it("works via http", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClient(testutils_spec_1.simapp.tendermintUrlHttp);
            const key = Uint8Array.from([
                ...encoding_1.toAscii("balances"),
                ...utils_1.toAccAddress(testutils_spec_1.unused.address),
                ...encoding_1.toAscii(testutils_spec_1.simapp.denomFee),
            ]);
            const data = await client.queryVerified("bank", key);
            const response = coin_1.Coin.decode(data);
            expect(response.amount).toMatch(testutils_spec_1.nonNegativeIntegerMatcher);
            expect(response.denom).toEqual(testutils_spec_1.simapp.denomFee);
            tmClient.disconnect();
        });
    });
    describe("queryUnverified", () => {
        it("works via WebSockets", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClient(testutils_spec_1.simapp.tendermintUrlWs);
            const requestData = Uint8Array.from(query_1.QueryAllBalancesRequest.encode({ address: testutils_spec_1.unused.address }).finish());
            const data = await client.queryUnverified(`/cosmos.bank.v1beta1.Query/AllBalances`, requestData);
            const response = query_1.QueryAllBalancesResponse.decode(data);
            expect(response.balances.length).toEqual(2);
            tmClient.disconnect();
        });
        it("works via http", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClient(testutils_spec_1.simapp.tendermintUrlHttp);
            const requestData = Uint8Array.from(query_1.QueryAllBalancesRequest.encode({ address: testutils_spec_1.unused.address }).finish());
            const data = await client.queryUnverified(`/cosmos.bank.v1beta1.Query/AllBalances`, requestData);
            const response = query_1.QueryAllBalancesResponse.decode(data);
            expect(response.balances.length).toEqual(2);
            tmClient.disconnect();
        });
    });
});
//# sourceMappingURL=queryclient.spec.js.map