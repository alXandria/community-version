"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const testutils_spec_1 = require("../testutils.spec");
const bank_1 = require("./bank");
const queryclient_1 = require("./queryclient");
async function makeClientWithBank(rpcUrl) {
    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(rpcUrl);
    return [queryclient_1.QueryClient.withExtensions(tmClient, bank_1.setupBankExtension), tmClient];
}
describe("BankExtension", () => {
    describe("balance", () => {
        it("works for different existing balances", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response1 = await client.bank.balance(testutils_spec_1.unused.address, testutils_spec_1.simapp.denomFee);
            expect(response1).toEqual({
                amount: testutils_spec_1.unused.balanceFee,
                denom: testutils_spec_1.simapp.denomFee,
            });
            const response2 = await client.bank.balance(testutils_spec_1.unused.address, testutils_spec_1.simapp.denomStaking);
            expect(response2).toEqual({
                amount: testutils_spec_1.unused.balanceStaking,
                denom: testutils_spec_1.simapp.denomStaking,
            });
            tmClient.disconnect();
        });
        it("returns zero for non-existent balance", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response = await client.bank.balance(testutils_spec_1.unused.address, "gintonic");
            expect(response).toEqual({
                amount: "0",
                denom: "gintonic",
            });
            tmClient.disconnect();
        });
        it("returns zero for non-existent address", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response = await client.bank.balance(testutils_spec_1.nonExistentAddress, testutils_spec_1.simapp.denomFee);
            expect(response).toEqual({
                amount: "0",
                denom: testutils_spec_1.simapp.denomFee,
            });
            tmClient.disconnect();
        });
    });
    describe("allBalances", () => {
        it("returns all balances for unused account", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const balances = await client.bank.allBalances(testutils_spec_1.unused.address);
            expect(balances).toEqual([
                {
                    amount: testutils_spec_1.unused.balanceFee,
                    denom: testutils_spec_1.simapp.denomFee,
                },
                {
                    amount: testutils_spec_1.unused.balanceStaking,
                    denom: testutils_spec_1.simapp.denomStaking,
                },
            ]);
            tmClient.disconnect();
        });
        it("returns an empty list for non-existent account", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const balances = await client.bank.allBalances(testutils_spec_1.nonExistentAddress);
            expect(balances).toEqual([]);
            tmClient.disconnect();
        });
    });
    describe("totalSupply", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response = await client.bank.totalSupply();
            expect(response).toEqual([
                {
                    amount: testutils_spec_1.simapp.totalSupply.toString(),
                    denom: testutils_spec_1.simapp.denomFee,
                },
                {
                    amount: jasmine.stringMatching(testutils_spec_1.nonNegativeIntegerMatcher),
                    denom: testutils_spec_1.simapp.denomStaking,
                },
            ]);
            tmClient.disconnect();
        });
    });
    describe("supplyOf", () => {
        it("works for existing denom", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response = await client.bank.supplyOf(testutils_spec_1.simapp.denomFee);
            expect(response).toEqual({
                amount: testutils_spec_1.simapp.totalSupply.toString(),
                denom: testutils_spec_1.simapp.denomFee,
            });
            tmClient.disconnect();
        });
        it("returns zero for non-existent denom", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
            const response = await client.bank.supplyOf("gintonic");
            expect(response).toEqual({
                amount: "0",
                denom: "gintonic",
            });
            tmClient.disconnect();
        });
    });
    describe("verified", () => {
        describe("balance", () => {
            it("works for different existing balances", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
                const response1 = await client.bank.verified.balance(testutils_spec_1.unused.address, testutils_spec_1.simapp.denomFee);
                expect(response1).toEqual({
                    amount: testutils_spec_1.unused.balanceFee,
                    denom: testutils_spec_1.simapp.denomFee,
                });
                const response2 = await client.bank.verified.balance(testutils_spec_1.unused.address, testutils_spec_1.simapp.denomStaking);
                expect(response2).toEqual({
                    amount: testutils_spec_1.unused.balanceStaking,
                    denom: testutils_spec_1.simapp.denomStaking,
                });
                tmClient.disconnect();
            });
            it("returns null for non-existent balance", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.bank.verified.balance(testutils_spec_1.unused.address, "gintonic");
                expect(response).toBeNull();
                tmClient.disconnect();
            });
            it("returns null for non-existent address", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithBank(testutils_spec_1.simapp.tendermintUrl);
                const response = await client.bank.verified.balance(testutils_spec_1.nonExistentAddress, testutils_spec_1.simapp.denomFee);
                expect(response).toBeNull();
                tmClient.disconnect();
            });
        });
    });
});
//# sourceMappingURL=bank.spec.js.map