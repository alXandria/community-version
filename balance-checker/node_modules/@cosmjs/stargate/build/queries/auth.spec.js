"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const proto_signing_1 = require("@cosmjs/proto-signing");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const long_1 = __importDefault(require("long"));
const auth_1 = require("../codec/cosmos/auth/v1beta1/auth");
const any_1 = require("../codec/google/protobuf/any");
const testutils_spec_1 = require("../testutils.spec");
const auth_2 = require("./auth");
const queryclient_1 = require("./queryclient");
async function makeClientWithAuth(rpcUrl) {
    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(rpcUrl);
    return [queryclient_1.QueryClient.withExtensions(tmClient, auth_2.setupAuthExtension), tmClient];
}
describe("AuthExtension", () => {
    describe("account", () => {
        it("works for unused account", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
            const account = await client.auth.account(testutils_spec_1.unused.address);
            utils_1.assert(account);
            expect(account.typeUrl).toEqual("/cosmos.auth.v1beta1.BaseAccount");
            expect(auth_1.BaseAccount.decode(account.value)).toEqual({
                address: testutils_spec_1.unused.address,
                // pubKey not set
                accountNumber: long_1.default.fromNumber(testutils_spec_1.unused.accountNumber, true),
                sequence: long_1.default.fromNumber(0, true),
            });
            tmClient.disconnect();
        });
        it("works for account with pubkey and non-zero sequence", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
            const account = await client.auth.account(testutils_spec_1.validator.delegatorAddress);
            utils_1.assert(account);
            expect(account.typeUrl).toEqual("/cosmos.auth.v1beta1.BaseAccount");
            expect(auth_1.BaseAccount.decode(account.value)).toEqual({
                address: testutils_spec_1.validator.delegatorAddress,
                pubKey: any_1.Any.fromPartial(proto_signing_1.encodePubkey(testutils_spec_1.validator.pubkey)),
                accountNumber: long_1.default.fromNumber(0, true),
                sequence: long_1.default.fromNumber(testutils_spec_1.validator.sequence, true),
            });
            tmClient.disconnect();
        });
        it("rejects for non-existent address", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
            await expectAsync(client.auth.account(testutils_spec_1.nonExistentAddress)).toBeRejectedWithError(/account cosmos1p79apjaufyphcmsn4g07cynqf0wyjuezqu84hd not found/i);
            tmClient.disconnect();
        });
    });
    describe("verified", () => {
        describe("account", () => {
            it("works for unused account", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
                const account = await client.auth.verified.account(testutils_spec_1.unused.address);
                utils_1.assert(account);
                expect(account.typeUrl).toEqual("/cosmos.auth.v1beta1.BaseAccount");
                expect(auth_1.BaseAccount.decode(account.value)).toEqual({
                    address: testutils_spec_1.unused.address,
                    // pubKey not set
                    accountNumber: long_1.default.fromNumber(testutils_spec_1.unused.accountNumber, true),
                    sequence: long_1.default.fromNumber(0, true),
                });
                tmClient.disconnect();
            });
            it("works for account with pubkey and non-zero sequence", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
                const account = await client.auth.verified.account(testutils_spec_1.validator.delegatorAddress);
                utils_1.assert(account);
                expect(account.typeUrl).toEqual("/cosmos.auth.v1beta1.BaseAccount");
                expect(auth_1.BaseAccount.decode(account.value)).toEqual({
                    address: testutils_spec_1.validator.delegatorAddress,
                    pubKey: any_1.Any.fromPartial(proto_signing_1.encodePubkey(testutils_spec_1.validator.pubkey)),
                    accountNumber: long_1.default.fromNumber(0, true),
                    sequence: long_1.default.fromNumber(testutils_spec_1.validator.sequence, true),
                });
                tmClient.disconnect();
            });
            it("returns null for non-existent address", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const [client, tmClient] = await makeClientWithAuth(testutils_spec_1.simapp.tendermintUrl);
                const account = await client.auth.verified.account(testutils_spec_1.nonExistentAddress);
                expect(account).toBeNull();
                tmClient.disconnect();
            });
        });
    });
});
//# sourceMappingURL=auth.spec.js.map