"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention,no-bitwise */
const amino_1 = require("@cosmjs/amino");
const proto_signing_1 = require("@cosmjs/proto-signing");
const utils_1 = require("@cosmjs/utils");
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const build_1 = require("../../proto-signing/build");
const aminotypes_1 = require("./aminotypes");
const tx_1 = require("./codec/cosmos/bank/v1beta1/tx");
const coin_1 = require("./codec/cosmos/base/v1beta1/coin");
const tx_2 = require("./codec/cosmos/staking/v1beta1/tx");
const tx_3 = require("./codec/cosmos/tx/v1beta1/tx");
const fee_1 = require("./fee");
const signingstargateclient_1 = require("./signingstargateclient");
const stargateclient_1 = require("./stargateclient");
const testutils_spec_1 = require("./testutils.spec");
describe("SigningStargateClient", () => {
    describe("constructor", () => {
        it("can be constructed with default fees", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            const openedClient = client;
            expect(openedClient.fees).toEqual({
                send: {
                    amount: [
                        {
                            amount: "2000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "80000",
                },
                delegate: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                transfer: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                undelegate: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                withdraw: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
            });
        });
        it("can be constructed with custom registry", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const registry = new proto_signing_1.Registry();
            registry.register("/custom.MsgCustom", tx_1.MsgSend);
            const options = { registry: registry };
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
            const openedClient = client;
            expect(openedClient.registry.lookupType("/custom.MsgCustom")).toEqual(tx_1.MsgSend);
        });
        it("can be constructed with custom gas price", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const gasPrice = fee_1.GasPrice.fromString("3.14utest");
            const options = { gasPrice: gasPrice };
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
            const openedClient = client;
            expect(openedClient.fees).toEqual({
                send: {
                    amount: [
                        {
                            amount: "251200",
                            denom: "utest",
                        },
                    ],
                    gas: "80000",
                },
                delegate: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                transfer: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                undelegate: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                withdraw: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
            });
        });
        it("can be constructed with custom gas limits", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const gasLimits = {
                send: 160000,
                delegate: 120000,
            };
            const options = { gasLimits: gasLimits };
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
            const openedClient = client;
            expect(openedClient.fees).toEqual({
                send: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                delegate: {
                    amount: [
                        {
                            amount: "3000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "120000",
                },
                transfer: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                undelegate: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                withdraw: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
            });
        });
        it("can be constructed with custom gas price and gas limits", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const gasPrice = fee_1.GasPrice.fromString("3.14utest");
            const gasLimits = {
                send: 160000,
            };
            const options = { gasPrice: gasPrice, gasLimits: gasLimits };
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
            const openedClient = client;
            expect(openedClient.fees).toEqual({
                send: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                delegate: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                transfer: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                undelegate: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                withdraw: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
            });
        });
    });
    describe("sendTokens", () => {
        it("works with direct signer", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            const amount = proto_signing_1.coins(7890, "ucosm");
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.faucet.address0, beneficiaryAddress, amount, memo);
            stargateclient_1.assertIsBroadcastTxSuccess(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(after).toEqual(amount[0]);
        });
        it("works with legacy Amino signer", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            const amount = proto_signing_1.coins(7890, "ucosm");
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const memo = "for dinner";
            // no tokens here
            const before = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(before).toEqual({
                denom: "ucosm",
                amount: "0",
            });
            // send
            const result = await client.sendTokens(testutils_spec_1.faucet.address0, beneficiaryAddress, amount, memo);
            stargateclient_1.assertIsBroadcastTxSuccess(result);
            expect(result.rawLog).toBeTruthy();
            // got tokens
            const after = await client.getBalance(beneficiaryAddress, "ucosm");
            expect(after).toEqual(amount[0]);
        });
    });
    describe("sendIbcTokens", () => {
        it("works with direct signing", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            const memo = "Cross-chain fun";
            // both timeouts set
            {
                const result = await client.sendIbcTokens(testutils_spec_1.faucet.address0, testutils_spec_1.faucet.address1, proto_signing_1.coin(1234, "ucosm"), "fooPort", "fooChannel", { revisionHeight: long_1.default.fromNumber(123), revisionNumber: long_1.default.fromNumber(456) }, Math.floor(Date.now() / 1000) + 60, memo);
                // CheckTx must pass but the execution must fail in DeliverTx due to invalid channel/port
                expect(stargateclient_1.isBroadcastTxFailure(result)).toEqual(true);
            }
            // no height timeout
            {
                const result = await client.sendIbcTokens(testutils_spec_1.faucet.address0, testutils_spec_1.faucet.address1, proto_signing_1.coin(1234, "ucosm"), "fooPort", "fooChannel", undefined, Math.floor(Date.now() / 1000) + 60, memo);
                // CheckTx must pass but the execution must fail in DeliverTx due to invalid channel/port
                expect(stargateclient_1.isBroadcastTxFailure(result)).toEqual(true);
            }
        });
        it("works with Amino signing", async () => {
            testutils_spec_1.pendingWithoutSimapp();
            const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
            const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
            const memo = "Cross-chain fun";
            // both timeouts set
            {
                const result = await client.sendIbcTokens(testutils_spec_1.faucet.address0, testutils_spec_1.faucet.address1, proto_signing_1.coin(1234, "ucosm"), "fooPort", "fooChannel", { revisionHeight: long_1.default.fromNumber(123), revisionNumber: long_1.default.fromNumber(456) }, Math.floor(Date.now() / 1000) + 60, memo);
                // CheckTx must pass but the execution must fail in DeliverTx due to invalid channel/port
                expect(stargateclient_1.isBroadcastTxFailure(result)).toEqual(true);
            }
            // no height timeout
            {
                const result = await client.sendIbcTokens(testutils_spec_1.faucet.address0, testutils_spec_1.faucet.address1, proto_signing_1.coin(1234, "ucosm"), "fooPort", "fooChannel", undefined, Math.floor(Date.now() / 1000) + 60, memo);
                // CheckTx must pass but the execution must fail in DeliverTx due to invalid channel/port
                expect(stargateclient_1.isBroadcastTxFailure(result)).toEqual(true);
            }
        });
    });
    describe("signAndBroadcast", () => {
        describe("direct mode", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
                await utils_1.sleep(1000);
                const searchResult = await client.getTx(result.transactionHash);
                utils_1.assert(searchResult, "Must find transaction");
                const tx = build_1.decodeTxRaw(searchResult.tx);
                // From ModifyingDirectSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect(Object.assign({}, tx.authInfo.fee.amount[0])).toEqual(proto_signing_1.coin(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msgSend = {
                    fromAddress: testutils_spec_1.faucet.address0,
                    toAddress: testutils_spec_1.makeRandomAddress(),
                    amount: proto_signing_1.coins(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with staking MsgDelegate", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a custom registry and custom message", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = Object.assign({}, baseCustomMsgDelegate);
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new aminotypes_1.AminoTypes({
                    additions: {
                        "/cosmos.staking.v1beta1.MsgDelegate": {
                            aminoType: "cosmos-sdk/MsgDelegate",
                            toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                                utils_1.assert(customDelegatorAddress, "missing customDelegatorAddress");
                                utils_1.assert(customValidatorAddress, "missing validatorAddress");
                                utils_1.assert(customAmount, "missing amount");
                                return {
                                    delegator_address: customDelegatorAddress,
                                    validator_address: customValidatorAddress,
                                    amount: {
                                        amount: customAmount.amount,
                                        denom: customAmount.denom,
                                    },
                                };
                            },
                            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                                customDelegatorAddress: delegator_address,
                                customValidatorAddress: validator_address,
                                customAmount: coin_1.Coin.fromPartial(amount),
                            }),
                        },
                    },
                });
                const options = { registry: customRegistry, aminoTypes: customAminoTypes };
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.faucet.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const result = await client.signAndBroadcast(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                stargateclient_1.assertIsBroadcastTxSuccess(result);
                await utils_1.sleep(1000);
                const searchResult = await client.getTx(result.transactionHash);
                utils_1.assert(searchResult, "Must find transaction");
                const tx = build_1.decodeTxRaw(searchResult.tx);
                // From ModifyingSecp256k1HdWallet
                expect(tx.body.memo).toEqual("This was modified");
                expect(Object.assign({}, tx.authInfo.fee.amount[0])).toEqual(proto_signing_1.coin(3000, "ucosm"));
                expect(tx.authInfo.fee.gasLimit.toNumber()).toEqual(333333);
            });
        });
    });
    describe("sign", () => {
        describe("direct mode", () => {
            it("works", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await proto_signing_1.DirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await testutils_spec_1.ModifyingDirectSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = tx_2.MsgDelegate.fromPartial({
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                });
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "180000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingDirectSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect(Object.assign({}, authInfo.fee.amount[0])).toEqual(proto_signing_1.coin(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
        });
        describe("legacy Amino mode", () => {
            it("works with bank MsgSend", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msgSend = {
                    fromAddress: testutils_spec_1.faucet.address0,
                    toAddress: testutils_spec_1.makeRandomAddress(),
                    amount: proto_signing_1.coins(1234, "ucosm"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                    value: msgSend,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with staking MsgDelegate", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msgDelegate = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msgDelegate,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ustake"),
                    gas: "200000",
                };
                const memo = "Use your tokens wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a custom registry and custom message", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await amino_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const customRegistry = new proto_signing_1.Registry();
                const msgDelegateTypeUrl = "/cosmos.staking.v1beta1.MsgDelegate";
                const baseCustomMsgDelegate = {
                    customDelegatorAddress: "",
                    customValidatorAddress: "",
                };
                const CustomMsgDelegate = {
                    // Adapted from autogenerated MsgDelegate implementation
                    encode(message, writer = minimal_1.default.Writer.create()) {
                        var _a, _b;
                        writer.uint32(10).string((_a = message.customDelegatorAddress) !== null && _a !== void 0 ? _a : "");
                        writer.uint32(18).string((_b = message.customValidatorAddress) !== null && _b !== void 0 ? _b : "");
                        if (message.customAmount !== undefined && message.customAmount !== undefined) {
                            coin_1.Coin.encode(message.customAmount, writer.uint32(26).fork()).ldelim();
                        }
                        return writer;
                    },
                    decode() {
                        throw new Error("decode method should not be required");
                    },
                    fromJSON() {
                        throw new Error("fromJSON method should not be required");
                    },
                    fromPartial(object) {
                        const message = Object.assign({}, baseCustomMsgDelegate);
                        if (object.customDelegatorAddress !== undefined && object.customDelegatorAddress !== null) {
                            message.customDelegatorAddress = object.customDelegatorAddress;
                        }
                        else {
                            message.customDelegatorAddress = "";
                        }
                        if (object.customValidatorAddress !== undefined && object.customValidatorAddress !== null) {
                            message.customValidatorAddress = object.customValidatorAddress;
                        }
                        else {
                            message.customValidatorAddress = "";
                        }
                        if (object.customAmount !== undefined && object.customAmount !== null) {
                            message.customAmount = coin_1.Coin.fromPartial(object.customAmount);
                        }
                        else {
                            message.customAmount = undefined;
                        }
                        return message;
                    },
                    toJSON() {
                        throw new Error("toJSON method should not be required");
                    },
                };
                customRegistry.register(msgDelegateTypeUrl, CustomMsgDelegate);
                const customAminoTypes = new aminotypes_1.AminoTypes({
                    additions: {
                        "/cosmos.staking.v1beta1.MsgDelegate": {
                            aminoType: "cosmos-sdk/MsgDelegate",
                            toAmino: ({ customDelegatorAddress, customValidatorAddress, customAmount, }) => {
                                utils_1.assert(customDelegatorAddress, "missing customDelegatorAddress");
                                utils_1.assert(customValidatorAddress, "missing validatorAddress");
                                utils_1.assert(customAmount, "missing amount");
                                return {
                                    delegator_address: customDelegatorAddress,
                                    validator_address: customValidatorAddress,
                                    amount: {
                                        amount: customAmount.amount,
                                        denom: customAmount.denom,
                                    },
                                };
                            },
                            fromAmino: ({ delegator_address, validator_address, amount, }) => ({
                                customDelegatorAddress: delegator_address,
                                customValidatorAddress: validator_address,
                                customAmount: coin_1.Coin.fromPartial(amount),
                            }),
                        },
                    },
                });
                const options = { registry: customRegistry, aminoTypes: customAminoTypes };
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet, options);
                const msg = {
                    customDelegatorAddress: testutils_spec_1.faucet.address0,
                    customValidatorAddress: testutils_spec_1.validator.validatorAddress,
                    customAmount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
            it("works with a modifying signer", async () => {
                testutils_spec_1.pendingWithoutSimapp();
                const wallet = await testutils_spec_1.ModifyingSecp256k1HdWallet.fromMnemonic(testutils_spec_1.faucet.mnemonic);
                const client = await signingstargateclient_1.SigningStargateClient.connectWithSigner(testutils_spec_1.simapp.tendermintUrl, wallet);
                const msg = {
                    delegatorAddress: testutils_spec_1.faucet.address0,
                    validatorAddress: testutils_spec_1.validator.validatorAddress,
                    amount: proto_signing_1.coin(1234, "ustake"),
                };
                const msgAny = {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: msg,
                };
                const fee = {
                    amount: proto_signing_1.coins(2000, "ucosm"),
                    gas: "200000",
                };
                const memo = "Use your power wisely";
                const signed = await client.sign(testutils_spec_1.faucet.address0, [msgAny], fee, memo);
                const body = tx_3.TxBody.decode(signed.bodyBytes);
                const authInfo = tx_3.AuthInfo.decode(signed.authInfoBytes);
                // From ModifyingSecp256k1HdWallet
                expect(body.memo).toEqual("This was modified");
                expect(Object.assign({}, authInfo.fee.amount[0])).toEqual(proto_signing_1.coin(3000, "ucosm"));
                expect(authInfo.fee.gasLimit.toNumber()).toEqual(333333);
                // ensure signature is valid
                const result = await client.broadcastTx(Uint8Array.from(tx_3.TxRaw.encode(signed).finish()));
                stargateclient_1.assertIsBroadcastTxSuccess(result);
            });
        });
    });
});
//# sourceMappingURL=signingstargateclient.spec.js.map