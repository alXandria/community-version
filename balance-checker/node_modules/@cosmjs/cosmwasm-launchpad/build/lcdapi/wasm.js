"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupWasmExtension = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const types_1 = require("../types");
function isWasmError(resp) {
    return resp.error !== undefined;
}
function unwrapWasmResponse(response) {
    if (isWasmError(response)) {
        throw new Error(response.error);
    }
    return response.result;
}
function setupWasmExtension(base) {
    return {
        wasm: {
            listCodeInfo: async () => {
                const path = `/wasm/code`;
                const responseData = (await base.get(path));
                return launchpad_1.normalizeLcdApiArray(unwrapWasmResponse(responseData));
            },
            getCode: async (id) => {
                const path = `/wasm/code/${id}`;
                const responseData = (await base.get(path));
                return unwrapWasmResponse(responseData);
            },
            listContractsByCodeId: async (id) => {
                const path = `/wasm/code/${id}/contracts`;
                const responseData = (await base.get(path));
                return launchpad_1.normalizeLcdApiArray(unwrapWasmResponse(responseData));
            },
            getContractInfo: async (address) => {
                const path = `/wasm/contract/${address}`;
                const response = (await base.get(path));
                return unwrapWasmResponse(response);
            },
            getContractCodeHistory: async (address) => {
                const path = `/wasm/contract/${address}/history`;
                const response = (await base.get(path));
                return unwrapWasmResponse(response);
            },
            getAllContractState: async (address) => {
                const path = `/wasm/contract/${address}/state`;
                const responseData = (await base.get(path));
                return launchpad_1.normalizeLcdApiArray(unwrapWasmResponse(responseData)).map(types_1.parseWasmData);
            },
            queryContractRaw: async (address, key) => {
                const hexKey = encoding_1.toHex(key);
                const path = `/wasm/contract/${address}/raw/${hexKey}?encoding=hex`;
                const responseData = (await base.get(path));
                const data = unwrapWasmResponse(responseData);
                if (Array.isArray(data)) {
                    // The CosmWasm 0.10 interface
                    return data.length === 0 ? null : encoding_1.fromBase64(data[0].val);
                }
                else {
                    // The CosmWasm 0.11 interface
                    return !data ? null : encoding_1.fromBase64(data); // Yes, we cannot differentiate empty fields from non-existent fields :(
                }
            },
            queryContractSmart: async (address, query) => {
                const encoded = encoding_1.toHex(encoding_1.toUtf8(JSON.stringify(query)));
                const path = `/wasm/contract/${address}/smart/${encoded}?encoding=hex`;
                const responseData = (await base.get(path));
                const result = unwrapWasmResponse(responseData);
                // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)
                return JSON.parse(encoding_1.fromUtf8(encoding_1.fromBase64(result.smart)));
            },
        },
    };
}
exports.setupWasmExtension = setupWasmExtension;
//# sourceMappingURL=wasm.js.map