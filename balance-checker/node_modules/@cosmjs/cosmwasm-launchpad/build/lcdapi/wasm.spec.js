"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const utils_1 = require("@cosmjs/utils");
const msgs_1 = require("../msgs");
const testutils_spec_1 = require("../testutils.spec");
const wasm_1 = require("./wasm");
function makeWasmClient(apiUrl) {
    return launchpad_1.LcdClient.withExtensions({ apiUrl }, launchpad_1.setupAuthExtension, wasm_1.setupWasmExtension);
}
async function uploadContract(signer, contract) {
    const memo = "My first contract on chain";
    const theMsg = {
        type: "wasm/MsgStoreCode",
        value: {
            sender: testutils_spec_1.alice.address0,
            wasm_byte_code: encoding_1.toBase64(contract.data),
            source: contract.source || "",
            builder: contract.builder || "",
        },
    };
    const fee = {
        amount: launchpad_1.coins(5000000, "ucosm"),
        gas: "89000000",
    };
    const firstAddress = (await signer.getAccounts())[0].address;
    const client = new launchpad_1.SigningCosmosClient(testutils_spec_1.launchpad.endpoint, firstAddress, signer);
    return client.signAndBroadcast([theMsg], fee, memo);
}
async function instantiateContract(signer, codeId, beneficiaryAddress, funds) {
    const memo = "Create an escrow instance";
    const theMsg = {
        type: "wasm/MsgInstantiateContract",
        value: {
            sender: testutils_spec_1.alice.address0,
            code_id: codeId.toString(),
            label: "my escrow",
            init_msg: {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            },
            init_funds: funds || [],
        },
    };
    const fee = {
        amount: launchpad_1.coins(5000000, "ucosm"),
        gas: "89000000",
    };
    const firstAddress = (await signer.getAccounts())[0].address;
    const client = new launchpad_1.SigningCosmosClient(testutils_spec_1.launchpad.endpoint, firstAddress, signer);
    return client.signAndBroadcast([theMsg], fee, memo);
}
async function executeContract(client, signer, contractAddress, msg) {
    const memo = "Time for action";
    const theMsg = {
        type: "wasm/MsgExecuteContract",
        value: {
            sender: testutils_spec_1.alice.address0,
            contract: contractAddress,
            msg: msg,
            sent_funds: [],
        },
    };
    const fee = {
        amount: launchpad_1.coins(5000000, "ucosm"),
        gas: "89000000",
    };
    const { account_number, sequence } = (await client.auth.account(testutils_spec_1.alice.address0)).result.value;
    const signDoc = launchpad_1.makeSignDoc([theMsg], fee, testutils_spec_1.launchpad.chainId, memo, account_number, sequence);
    const { signed, signature } = await signer.signAmino(testutils_spec_1.alice.address0, signDoc);
    const signedTx = launchpad_1.makeStdTx(signed, signature);
    return client.broadcastTx(signedTx);
}
describe("WasmExtension", () => {
    const hackatom = testutils_spec_1.getHackatom();
    const hackatomConfigKey = encoding_1.toAscii("config");
    let hackatomCodeId;
    let hackatomContractAddress;
    beforeAll(async () => {
        if (testutils_spec_1.launchpadEnabled()) {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const result = await uploadContract(wallet, hackatom);
            launchpad_1.assertIsBroadcastTxSuccess(result);
            const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
            const codeIdAttr = launchpad_1.logs.findAttribute(parsedLogs, "message", "code_id");
            hackatomCodeId = Number.parseInt(codeIdAttr.value, 10);
            const instantiateResult = await instantiateContract(wallet, hackatomCodeId, testutils_spec_1.makeRandomAddress());
            launchpad_1.assertIsBroadcastTxSuccess(instantiateResult);
            const instantiateLogs = launchpad_1.logs.parseLogs(instantiateResult.logs);
            const contractAddressAttr = launchpad_1.logs.findAttribute(instantiateLogs, "message", "contract_address");
            hackatomContractAddress = contractAddressAttr.value;
        }
    });
    describe("listCodeInfo", () => {
        it("has recently uploaded contract as last entry", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const codesList = await client.wasm.listCodeInfo();
            const lastCode = codesList[codesList.length - 1];
            expect(lastCode.id).toEqual(hackatomCodeId);
            expect(lastCode.creator).toEqual(testutils_spec_1.alice.address0);
            expect(lastCode.source).toEqual(hackatom.source);
            expect(lastCode.builder).toEqual(hackatom.builder);
            expect(lastCode.data_hash.toLowerCase()).toEqual(encoding_1.toHex(crypto_1.sha256(hackatom.data)));
        });
    });
    describe("getCode", () => {
        it("contains fill code information", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const code = await client.wasm.getCode(hackatomCodeId);
            expect(code.id).toEqual(hackatomCodeId);
            expect(code.creator).toEqual(testutils_spec_1.alice.address0);
            expect(code.source).toEqual(hackatom.source);
            expect(code.builder).toEqual(hackatom.builder);
            expect(code.data_hash.toLowerCase()).toEqual(encoding_1.toHex(crypto_1.sha256(hackatom.data)));
            expect(code.data).toEqual(encoding_1.toBase64(hackatom.data));
        });
    });
    // TODO: move listContractsByCodeId tests out of here
    describe("getContractInfo", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            // create new instance and compare before and after
            const existingContractsByCode = await client.wasm.listContractsByCodeId(hackatomCodeId);
            for (const contract of existingContractsByCode) {
                expect(contract.address).toMatch(testutils_spec_1.bech32AddressMatcher);
                expect(contract.code_id).toEqual(hackatomCodeId);
                expect(contract.creator).toMatch(testutils_spec_1.bech32AddressMatcher);
                expect(contract.label).toMatch(/^.+$/);
            }
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const funds = launchpad_1.coins(707707, "ucosm");
            const result = await instantiateContract(wallet, hackatomCodeId, beneficiaryAddress, funds);
            launchpad_1.assertIsBroadcastTxSuccess(result);
            const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
            const contractAddressAttr = launchpad_1.logs.findAttribute(parsedLogs, "message", "contract_address");
            const myAddress = contractAddressAttr.value;
            const newContractsByCode = await client.wasm.listContractsByCodeId(hackatomCodeId);
            expect(newContractsByCode.length).toEqual(existingContractsByCode.length + 1);
            const newContract = newContractsByCode[newContractsByCode.length - 1];
            expect(newContract).toEqual(jasmine.objectContaining({
                code_id: hackatomCodeId,
                creator: testutils_spec_1.alice.address0,
                label: "my escrow",
            }));
            const info = await client.wasm.getContractInfo(myAddress);
            utils_1.assert(info);
            expect(info).toEqual(jasmine.objectContaining({
                code_id: hackatomCodeId,
                creator: testutils_spec_1.alice.address0,
                label: "my escrow",
            }));
            expect(info.admin).toBeUndefined();
        });
        it("returns null for non-existent address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const info = await client.wasm.getContractInfo(nonExistentAddress);
            expect(info).toBeNull();
        });
    });
    describe("getContractCodeHistory", () => {
        it("can list contract history", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            // create new instance and compare before and after
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const funds = launchpad_1.coins(707707, "ucosm");
            const result = await instantiateContract(wallet, hackatomCodeId, beneficiaryAddress, funds);
            launchpad_1.assertIsBroadcastTxSuccess(result);
            const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
            const contractAddressAttr = launchpad_1.logs.findAttribute(parsedLogs, "message", "contract_address");
            const myAddress = contractAddressAttr.value;
            const history = await client.wasm.getContractCodeHistory(myAddress);
            utils_1.assert(history);
            expect(history).toContain({
                code_id: hackatomCodeId,
                operation: "Init",
                msg: {
                    verifier: testutils_spec_1.alice.address0,
                    beneficiary: beneficiaryAddress,
                },
            });
        });
        it("returns null for non-existent address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomCodeId);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const history = await client.wasm.getContractCodeHistory(nonExistentAddress);
            expect(history).toBeNull();
        });
    });
    describe("getAllContractState", () => {
        it("can get all state", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomContractAddress);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const state = await client.wasm.getAllContractState(hackatomContractAddress);
            expect(state.length).toEqual(1);
            const data = state[0];
            expect(data.key).toEqual(hackatomConfigKey);
            const value = JSON.parse(encoding_1.fromUtf8(data.val));
            expect(value.verifier).toMatch(testutils_spec_1.base64Matcher);
            expect(value.beneficiary).toMatch(testutils_spec_1.base64Matcher);
        });
        it("is empty for non-existent address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const state = await client.wasm.getAllContractState(nonExistentAddress);
            expect(state).toEqual([]);
        });
    });
    describe("queryContractRaw", () => {
        it("can query by key", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomContractAddress);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const raw = await client.wasm.queryContractRaw(hackatomContractAddress, hackatomConfigKey);
            utils_1.assert(raw, "must get result");
            const model = JSON.parse(encoding_1.fromAscii(raw));
            expect(model.verifier).toMatch(testutils_spec_1.base64Matcher);
            expect(model.beneficiary).toMatch(testutils_spec_1.base64Matcher);
        });
        it("returns null for missing key", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomContractAddress);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const info = await client.wasm.queryContractRaw(hackatomContractAddress, encoding_1.fromHex("cafe0dad"));
            expect(info).toBeNull();
        });
        it("returns null for non-existent address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const info = await client.wasm.queryContractRaw(nonExistentAddress, hackatomConfigKey);
            expect(info).toBeNull();
        });
    });
    describe("queryContractSmart", () => {
        it("can make smart queries", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomContractAddress);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const request = { verifier: {} };
            const response = await client.wasm.queryContractSmart(hackatomContractAddress, request);
            expect(response).toEqual({ verifier: testutils_spec_1.alice.address0 });
        });
        it("throws for invalid query requests", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(hackatomContractAddress);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const request = { nosuchkey: {} };
            await client.wasm.queryContractSmart(hackatomContractAddress, request).then(() => fail("shouldn't succeed"), (error) => expect(error).toMatch(/query wasm contract failed: Error parsing into type hackatom::contract::QueryMsg: unknown variant/));
        });
        it("throws for non-existent address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const request = { verifier: {} };
            await client.wasm.queryContractSmart(nonExistentAddress, request).then(() => fail("shouldn't succeed"), (error) => expect(error).toMatch("not found"));
        });
    });
    describe("txsQuery", () => {
        it("can query by tags (module + code_id)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.txsQuery(`message.module=wasm&message.code_id=${testutils_spec_1.deployedHackatom.codeId}`);
            expect(parseInt(result.count, 10)).toBeGreaterThanOrEqual(4);
            // Check first 4 results
            const [store, zero, one, two] = result.txs.map((tx) => testutils_spec_1.fromOneElementArray(tx.tx.value.msg));
            utils_1.assert(msgs_1.isMsgStoreCode(store));
            utils_1.assert(msgs_1.isMsgInstantiateContract(zero));
            utils_1.assert(msgs_1.isMsgInstantiateContract(one));
            utils_1.assert(msgs_1.isMsgInstantiateContract(two));
            expect(store.value).toEqual(jasmine.objectContaining({
                sender: testutils_spec_1.alice.address0,
                source: testutils_spec_1.deployedHackatom.source,
                builder: testutils_spec_1.deployedHackatom.builder,
            }));
            expect(zero.value).toEqual({
                code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                init_funds: [],
                init_msg: jasmine.objectContaining({
                    beneficiary: testutils_spec_1.deployedHackatom.instances[0].beneficiary,
                }),
                label: testutils_spec_1.deployedHackatom.instances[0].label,
                sender: testutils_spec_1.alice.address0,
            });
            expect(one.value).toEqual({
                code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                init_funds: [],
                init_msg: jasmine.objectContaining({
                    beneficiary: testutils_spec_1.deployedHackatom.instances[1].beneficiary,
                }),
                label: testutils_spec_1.deployedHackatom.instances[1].label,
                sender: testutils_spec_1.alice.address0,
            });
            expect(two.value).toEqual({
                code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                init_funds: [],
                init_msg: jasmine.objectContaining({
                    beneficiary: testutils_spec_1.deployedHackatom.instances[2].beneficiary,
                }),
                label: testutils_spec_1.deployedHackatom.instances[2].label,
                sender: testutils_spec_1.alice.address0,
                admin: testutils_spec_1.alice.address1,
            });
        });
        // Like previous test but filtered by message.action=store-code and message.action=instantiate
        it("can query by tags (module + code_id + action)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            {
                const uploads = await client.txsQuery(`message.module=wasm&message.code_id=${testutils_spec_1.deployedHackatom.codeId}&message.action=store-code`);
                expect(parseInt(uploads.count, 10)).toEqual(1);
                const store = testutils_spec_1.fromOneElementArray(uploads.txs[0].tx.value.msg);
                utils_1.assert(msgs_1.isMsgStoreCode(store));
                expect(store.value).toEqual(jasmine.objectContaining({
                    sender: testutils_spec_1.alice.address0,
                    source: testutils_spec_1.deployedHackatom.source,
                    builder: testutils_spec_1.deployedHackatom.builder,
                }));
            }
            {
                const instantiations = await client.txsQuery(`message.module=wasm&message.code_id=${testutils_spec_1.deployedHackatom.codeId}&message.action=instantiate`);
                expect(parseInt(instantiations.count, 10)).toBeGreaterThanOrEqual(3);
                const [zero, one, two] = instantiations.txs.map((tx) => testutils_spec_1.fromOneElementArray(tx.tx.value.msg));
                utils_1.assert(msgs_1.isMsgInstantiateContract(zero));
                utils_1.assert(msgs_1.isMsgInstantiateContract(one));
                utils_1.assert(msgs_1.isMsgInstantiateContract(two));
                expect(zero.value).toEqual({
                    code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                    init_funds: [],
                    init_msg: jasmine.objectContaining({
                        beneficiary: testutils_spec_1.deployedHackatom.instances[0].beneficiary,
                    }),
                    label: testutils_spec_1.deployedHackatom.instances[0].label,
                    sender: testutils_spec_1.alice.address0,
                });
                expect(one.value).toEqual({
                    code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                    init_funds: [],
                    init_msg: jasmine.objectContaining({
                        beneficiary: testutils_spec_1.deployedHackatom.instances[1].beneficiary,
                    }),
                    label: testutils_spec_1.deployedHackatom.instances[1].label,
                    sender: testutils_spec_1.alice.address0,
                });
                expect(two.value).toEqual({
                    code_id: testutils_spec_1.deployedHackatom.codeId.toString(),
                    init_funds: [],
                    init_msg: jasmine.objectContaining({
                        beneficiary: testutils_spec_1.deployedHackatom.instances[2].beneficiary,
                    }),
                    label: testutils_spec_1.deployedHackatom.instances[2].label,
                    sender: testutils_spec_1.alice.address0,
                    admin: testutils_spec_1.alice.address1,
                });
            }
        });
    });
    describe("broadcastTx", () => {
        it("can upload, instantiate and execute wasm", async () => {
            var _a;
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            let codeId;
            // upload
            {
                // console.log("Raw log:", result.raw_log);
                const result = await uploadContract(wallet, testutils_spec_1.getHackatom());
                launchpad_1.assertIsBroadcastTxSuccess(result);
                const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
                const codeIdAttr = launchpad_1.logs.findAttribute(parsedLogs, "message", "code_id");
                codeId = Number.parseInt(codeIdAttr.value, 10);
                expect(codeId).toBeGreaterThanOrEqual(1);
                expect(codeId).toBeLessThanOrEqual(200);
                expect(result.data).toEqual(encoding_1.toAscii(`${codeId}`));
            }
            const funds = [launchpad_1.coin(1234, "ucosm"), launchpad_1.coin(321, "ustake")];
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            let contractAddress;
            // instantiate
            {
                const result = await instantiateContract(wallet, codeId, beneficiaryAddress, funds);
                launchpad_1.assertIsBroadcastTxSuccess(result);
                // console.log("Raw log:", result.raw_log);
                const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
                const contractAddressAttr = launchpad_1.logs.findAttribute(parsedLogs, "message", "contract_address");
                contractAddress = contractAddressAttr.value;
                const amountAttr = launchpad_1.logs.findAttribute(parsedLogs, "transfer", "amount");
                expect(amountAttr.value).toEqual("1234ucosm,321ustake");
                expect(result.data).toEqual(encoding_1.Bech32.decode(contractAddress).data);
                const balance = (await client.auth.account(contractAddress)).result.value.coins;
                expect(balance).toEqual(funds);
            }
            // execute
            {
                const result = await executeContract(client, wallet, contractAddress, { release: {} });
                utils_1.assert(!result.code);
                expect(result.data).toEqual("F00BAA");
                // console.log("Raw log:", result.logs);
                const parsedLogs = launchpad_1.logs.parseLogs(result.logs);
                const wasmEvent = (_a = parsedLogs.find(() => true)) === null || _a === void 0 ? void 0 : _a.events.find((e) => e.type === "wasm");
                utils_1.assert(wasmEvent, "Event of type wasm expected");
                expect(wasmEvent.attributes).toContain({ key: "action", value: "release" });
                expect(wasmEvent.attributes).toContain({
                    key: "destination",
                    value: beneficiaryAddress,
                });
                // Verify token transfer from contract to beneficiary
                const beneficiaryBalance = (await client.auth.account(beneficiaryAddress)).result.value.coins;
                expect(beneficiaryBalance).toEqual(funds);
                const contractBalance = (await client.auth.account(contractAddress)).result.value.coins;
                expect(contractBalance).toEqual([]);
            }
        });
    });
});
//# sourceMappingURL=wasm.spec.js.map