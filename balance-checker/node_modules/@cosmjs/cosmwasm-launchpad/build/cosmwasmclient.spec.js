"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const utils_1 = require("@cosmjs/utils");
const readonly_date_1 = require("readonly-date");
const cosmwasmclient_1 = require("./cosmwasmclient");
const signingcosmwasmclient_1 = require("./signingcosmwasmclient");
const cosmoshub_json_1 = __importDefault(require("./testdata/cosmoshub.json"));
const testutils_spec_1 = require("./testutils.spec");
const blockTime = 1000; // ms
describe("CosmWasmClient", () => {
    describe("makeReadOnly", () => {
        it("can be constructed", () => {
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            expect(client).toBeTruthy();
        });
    });
    describe("getChainId", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            expect(await client.getChainId()).toEqual(testutils_spec_1.launchpad.chainId);
        });
        it("caches chain ID", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const openedClient = client;
            const getCodeSpy = spyOn(openedClient.lcdClient, "nodeInfo").and.callThrough();
            expect(await client.getChainId()).toEqual(testutils_spec_1.launchpad.chainId); // from network
            expect(await client.getChainId()).toEqual(testutils_spec_1.launchpad.chainId); // from cache
            expect(getCodeSpy).toHaveBeenCalledTimes(1);
        });
    });
    describe("getHeight", () => {
        it("gets height via last block", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const openedClient = client;
            const blockLatestSpy = spyOn(openedClient.lcdClient, "blocksLatest").and.callThrough();
            const height1 = await client.getHeight();
            expect(height1).toBeGreaterThan(0);
            await utils_1.sleep(blockTime * 1.4); // tolerate chain being 40% slower than expected
            const height2 = await client.getHeight();
            expect(height2).toBeGreaterThanOrEqual(height1 + 1);
            expect(height2).toBeLessThanOrEqual(height1 + 2);
            expect(blockLatestSpy).toHaveBeenCalledTimes(2);
        });
        it("gets height via authAccount once an address is known", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const openedClient = client;
            const blockLatestSpy = spyOn(openedClient.lcdClient, "blocksLatest").and.callThrough();
            const authAccountsSpy = spyOn(openedClient.lcdClient.auth, "account").and.callThrough();
            const height1 = await client.getHeight();
            expect(height1).toBeGreaterThan(0);
            await client.getCodes(); // warm up the client
            const height2 = await client.getHeight();
            expect(height2).toBeGreaterThan(0);
            await utils_1.sleep(blockTime * 1.3); // tolerate chain being 30% slower than expected
            const height3 = await client.getHeight();
            expect(height3).toBeGreaterThanOrEqual(height2 + 1);
            expect(height3).toBeLessThanOrEqual(height2 + 2);
            expect(blockLatestSpy).toHaveBeenCalledTimes(1);
            expect(authAccountsSpy).toHaveBeenCalledTimes(2);
        });
    });
    describe("getSequence", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            expect(await client.getSequence(testutils_spec_1.unused.address)).toEqual({
                accountNumber: testutils_spec_1.unused.accountNumber,
                sequence: testutils_spec_1.unused.sequence,
            });
        });
        it("throws for missing accounts", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const missing = testutils_spec_1.makeRandomAddress();
            await client.getSequence(missing).then(() => fail("this must not succeed"), (error) => expect(error).toMatch(/account does not exist on chain/i));
        });
    });
    describe("getAccount", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            expect(await client.getAccount(testutils_spec_1.unused.address)).toEqual({
                address: testutils_spec_1.unused.address,
                accountNumber: testutils_spec_1.unused.accountNumber,
                sequence: testutils_spec_1.unused.sequence,
                pubkey: undefined,
                balance: [
                    { denom: "ucosm", amount: "1000000000" },
                    { denom: "ustake", amount: "1000000000" },
                ],
            });
        });
        it("returns undefined for missing accounts", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const missing = testutils_spec_1.makeRandomAddress();
            expect(await client.getAccount(missing)).toBeUndefined();
        });
    });
    describe("getBlock", () => {
        it("works for latest block", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const response = await client.getBlock();
            // id
            expect(response.id).toMatch(testutils_spec_1.tendermintIdMatcher);
            // header
            expect(response.header.height).toBeGreaterThanOrEqual(1);
            expect(response.header.chainId).toEqual(await client.getChainId());
            expect(new readonly_date_1.ReadonlyDate(response.header.time).getTime()).toBeLessThan(readonly_date_1.ReadonlyDate.now());
            expect(new readonly_date_1.ReadonlyDate(response.header.time).getTime()).toBeGreaterThanOrEqual(readonly_date_1.ReadonlyDate.now() - 5000);
            // txs
            expect(Array.isArray(response.txs)).toEqual(true);
        });
        it("works for block by height", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const height = (await client.getBlock()).header.height;
            const response = await client.getBlock(height - 1);
            // id
            expect(response.id).toMatch(testutils_spec_1.tendermintIdMatcher);
            // header
            expect(response.header.height).toEqual(height - 1);
            expect(response.header.chainId).toEqual(await client.getChainId());
            expect(new readonly_date_1.ReadonlyDate(response.header.time).getTime()).toBeLessThan(readonly_date_1.ReadonlyDate.now());
            expect(new readonly_date_1.ReadonlyDate(response.header.time).getTime()).toBeGreaterThanOrEqual(readonly_date_1.ReadonlyDate.now() - 5000);
            // txs
            expect(Array.isArray(response.txs)).toEqual(true);
        });
    });
    describe("getIdentifier", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            utils_1.assert(launchpad_1.isWrappedStdTx(cosmoshub_json_1.default.tx));
            expect(await client.getIdentifier(cosmoshub_json_1.default.tx)).toEqual(cosmoshub_json_1.default.id);
        });
    });
    describe("broadcastTx", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const memo = "My first contract on chain";
            const sendMsg = {
                type: "cosmos-sdk/MsgSend",
                value: {
                    from_address: testutils_spec_1.alice.address0,
                    to_address: testutils_spec_1.makeRandomAddress(),
                    amount: [
                        {
                            denom: "ucosm",
                            amount: "1234567",
                        },
                    ],
                },
            };
            const fee = {
                amount: [
                    {
                        amount: "5000",
                        denom: "ucosm",
                    },
                ],
                gas: "890000",
            };
            const chainId = await client.getChainId();
            const { accountNumber, sequence } = await client.getSequence(testutils_spec_1.alice.address0);
            const signDoc = launchpad_1.makeSignDoc([sendMsg], fee, chainId, memo, accountNumber, sequence);
            const { signed, signature } = await wallet.signAmino(testutils_spec_1.alice.address0, signDoc);
            const signedTx = launchpad_1.makeStdTx(signed, signature);
            const result = await client.broadcastTx(signedTx);
            launchpad_1.assertIsBroadcastTxSuccess(result);
            const amountAttr = launchpad_1.logs.findAttribute(result.logs, "transfer", "amount");
            expect(amountAttr.value).toEqual("1234567ucosm");
            expect(result.transactionHash).toMatch(/^[0-9A-F]{64}$/);
        });
    });
    describe("getCodes", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.getCodes();
            expect(result.length).toBeGreaterThanOrEqual(1);
            const [first] = result;
            expect(first).toEqual({
                id: testutils_spec_1.deployedHackatom.codeId,
                source: testutils_spec_1.deployedHackatom.source,
                builder: testutils_spec_1.deployedHackatom.builder,
                checksum: testutils_spec_1.deployedHackatom.checksum,
                creator: testutils_spec_1.alice.address0,
            });
        });
    });
    describe("getCodeDetails", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.getCodeDetails(1);
            const expectedInfo = {
                id: testutils_spec_1.deployedHackatom.codeId,
                source: testutils_spec_1.deployedHackatom.source,
                builder: testutils_spec_1.deployedHackatom.builder,
                checksum: testutils_spec_1.deployedHackatom.checksum,
                creator: testutils_spec_1.alice.address0,
            };
            // check info
            expect(result).toEqual(jasmine.objectContaining(expectedInfo));
            // check data
            expect(crypto_1.sha256(result.data)).toEqual(encoding_1.fromHex(expectedInfo.checksum));
        });
        it("caches downloads", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const openedClient = client;
            const getCodeSpy = spyOn(openedClient.lcdClient.wasm, "getCode").and.callThrough();
            const result1 = await client.getCodeDetails(testutils_spec_1.deployedHackatom.codeId); // from network
            const result2 = await client.getCodeDetails(testutils_spec_1.deployedHackatom.codeId); // from cache
            expect(result2).toEqual(result1);
            expect(getCodeSpy).toHaveBeenCalledTimes(1);
        });
    });
    describe("getContracts", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.getContracts(1);
            expect(result.length).toBeGreaterThanOrEqual(3);
            const [zero, one, two] = result;
            expect(zero).toEqual({
                address: testutils_spec_1.deployedHackatom.instances[0].address,
                codeId: testutils_spec_1.deployedHackatom.codeId,
                creator: testutils_spec_1.alice.address0,
                admin: undefined,
                label: testutils_spec_1.deployedHackatom.instances[0].label,
            });
            expect(one).toEqual({
                address: testutils_spec_1.deployedHackatom.instances[1].address,
                codeId: testutils_spec_1.deployedHackatom.codeId,
                creator: testutils_spec_1.alice.address0,
                admin: undefined,
                label: testutils_spec_1.deployedHackatom.instances[1].label,
            });
            expect(two).toEqual({
                address: testutils_spec_1.deployedHackatom.instances[2].address,
                codeId: testutils_spec_1.deployedHackatom.codeId,
                creator: testutils_spec_1.alice.address0,
                admin: testutils_spec_1.alice.address1,
                label: testutils_spec_1.deployedHackatom.instances[2].label,
            });
        });
    });
    describe("getContract", () => {
        it("works for instance without admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const zero = await client.getContract(testutils_spec_1.deployedHackatom.instances[0].address);
            expect(zero).toEqual({
                address: testutils_spec_1.deployedHackatom.instances[0].address,
                codeId: testutils_spec_1.deployedHackatom.codeId,
                creator: testutils_spec_1.alice.address0,
                label: testutils_spec_1.deployedHackatom.instances[0].label,
                admin: undefined,
            });
        });
        it("works for instance with admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const two = await client.getContract(testutils_spec_1.deployedHackatom.instances[2].address);
            expect(two).toEqual(jasmine.objectContaining({
                address: testutils_spec_1.deployedHackatom.instances[2].address,
                codeId: testutils_spec_1.deployedHackatom.codeId,
                creator: testutils_spec_1.alice.address0,
                label: testutils_spec_1.deployedHackatom.instances[2].label,
                admin: testutils_spec_1.alice.address1,
            }));
        });
    });
    describe("queryContractRaw", () => {
        const configKey = encoding_1.toAscii("config");
        const otherKey = encoding_1.toAscii("this_does_not_exist");
        let contract;
        beforeAll(async () => {
            if (testutils_spec_1.launchpadEnabled()) {
                testutils_spec_1.pendingWithoutLaunchpad();
                const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
                const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
                const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
                const initMsg = { verifier: testutils_spec_1.makeRandomAddress(), beneficiary: testutils_spec_1.makeRandomAddress() };
                const { contractAddress } = await client.instantiate(codeId, initMsg, "random hackatom");
                contract = { initMsg: initMsg, address: contractAddress };
            }
        });
        it("can query existing key", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(contract);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const raw = await client.queryContractRaw(contract.address, configKey);
            utils_1.assert(raw, "must get result");
            expect(JSON.parse(encoding_1.fromUtf8(raw))).toEqual({
                verifier: encoding_1.toBase64(encoding_1.Bech32.decode(contract.initMsg.verifier).data),
                beneficiary: encoding_1.toBase64(encoding_1.Bech32.decode(contract.initMsg.beneficiary).data),
                funder: encoding_1.toBase64(encoding_1.Bech32.decode(testutils_spec_1.alice.address0).data),
            });
        });
        it("can query non-existent key", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(contract);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const raw = await client.queryContractRaw(contract.address, otherKey);
            expect(raw).toBeNull();
        });
        it("errors for non-existent contract", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(contract);
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            await client.queryContractRaw(nonExistentAddress, configKey).then(() => fail("must not succeed"), (error) => expect(error).toMatch(`No contract found at address "${nonExistentAddress}"`));
        });
    });
    describe("queryContractSmart", () => {
        let contract;
        beforeAll(async () => {
            if (testutils_spec_1.launchpadEnabled()) {
                testutils_spec_1.pendingWithoutLaunchpad();
                const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
                const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
                const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
                const initMsg = { verifier: testutils_spec_1.makeRandomAddress(), beneficiary: testutils_spec_1.makeRandomAddress() };
                const { contractAddress } = await client.instantiate(codeId, initMsg, "a different hackatom");
                contract = { initMsg: initMsg, address: contractAddress };
            }
        });
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(contract);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const resultDocument = await client.queryContractSmart(contract.address, { verifier: {} });
            expect(resultDocument).toEqual({ verifier: contract.initMsg.verifier });
        });
        it("errors for malformed query message", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            utils_1.assert(contract);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            await client.queryContractSmart(contract.address, { broken: {} }).then(() => fail("must not succeed"), (error) => expect(error).toMatch(/query wasm contract failed: Error parsing into type hackatom::contract::QueryMsg: unknown variant/i));
        });
        it("errors for non-existent contract", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const nonExistentAddress = testutils_spec_1.makeRandomAddress();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            await client.queryContractSmart(nonExistentAddress, { verifier: {} }).then(() => fail("must not succeed"), (error) => expect(error).toMatch(`No contract found at address "${nonExistentAddress}"`));
        });
    });
});
//# sourceMappingURL=cosmwasmclient.spec.js.map