"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const utils_1 = require("@cosmjs/utils");
const wasm_1 = require("./lcdapi/wasm");
const signingcosmwasmclient_1 = require("./signingcosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
function makeWasmClient(apiUrl) {
    return launchpad_1.LcdClient.withExtensions({ apiUrl }, launchpad_1.setupAuthExtension, wasm_1.setupWasmExtension);
}
describe("SigningCosmWasmClient", () => {
    describe("makeReadOnly", () => {
        it("can be constructed", async () => {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            expect(client).toBeTruthy();
        });
        it("can be constructed with custom gas price", async () => {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const gasPrice = launchpad_1.GasPrice.fromString("3.14utest");
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, gasPrice);
            expect(client.fees).toEqual({
                upload: {
                    amount: [
                        {
                            amount: "4710000",
                            denom: "utest",
                        },
                    ],
                    gas: "1500000",
                },
                init: {
                    amount: [
                        {
                            amount: "1570000",
                            denom: "utest",
                        },
                    ],
                    gas: "500000",
                },
                migrate: {
                    amount: [
                        {
                            amount: "628000",
                            denom: "utest",
                        },
                    ],
                    gas: "200000",
                },
                exec: {
                    amount: [
                        {
                            amount: "628000",
                            denom: "utest",
                        },
                    ],
                    gas: "200000",
                },
                send: {
                    amount: [
                        {
                            amount: "251200",
                            denom: "utest",
                        },
                    ],
                    gas: "80000",
                },
                changeAdmin: {
                    amount: [
                        {
                            amount: "251200",
                            denom: "utest",
                        },
                    ],
                    gas: "80000",
                },
            });
        });
        it("can be constructed with custom gas limits", async () => {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const gasLimits = {
                send: 160000,
            };
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, undefined, gasLimits);
            expect(client.fees).toEqual({
                upload: {
                    amount: [
                        {
                            amount: "37500",
                            denom: "ucosm",
                        },
                    ],
                    gas: "1500000",
                },
                init: {
                    amount: [
                        {
                            amount: "12500",
                            denom: "ucosm",
                        },
                    ],
                    gas: "500000",
                },
                migrate: {
                    amount: [
                        {
                            amount: "5000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "200000",
                },
                exec: {
                    amount: [
                        {
                            amount: "5000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "200000",
                },
                send: {
                    amount: [
                        {
                            amount: "4000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "160000",
                },
                changeAdmin: {
                    amount: [
                        {
                            amount: "2000",
                            denom: "ucosm",
                        },
                    ],
                    gas: "80000",
                },
            });
        });
        it("can be constructed with custom gas price and gas limits", async () => {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const gasPrice = launchpad_1.GasPrice.fromString("3.14utest");
            const gasLimits = {
                send: 160000,
            };
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, gasPrice, gasLimits);
            expect(client.fees).toEqual({
                upload: {
                    amount: [
                        {
                            amount: "4710000",
                            denom: "utest",
                        },
                    ],
                    gas: "1500000",
                },
                init: {
                    amount: [
                        {
                            amount: "1570000",
                            denom: "utest",
                        },
                    ],
                    gas: "500000",
                },
                migrate: {
                    amount: [
                        {
                            amount: "628000",
                            denom: "utest",
                        },
                    ],
                    gas: "200000",
                },
                exec: {
                    amount: [
                        {
                            amount: "628000",
                            denom: "utest",
                        },
                    ],
                    gas: "200000",
                },
                send: {
                    amount: [
                        {
                            amount: "502400",
                            denom: "utest",
                        },
                    ],
                    gas: "160000",
                },
                changeAdmin: {
                    amount: [
                        {
                            amount: "251200",
                            denom: "utest",
                        },
                    ],
                    gas: "80000",
                },
            });
        });
    });
    describe("getHeight", () => {
        it("always uses authAccount implementation", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const openedClient = client;
            const blockLatestSpy = spyOn(openedClient.lcdClient, "blocksLatest").and.callThrough();
            const authAccountsSpy = spyOn(openedClient.lcdClient.auth, "account").and.callThrough();
            const height = await client.getHeight();
            expect(height).toBeGreaterThan(0);
            expect(blockLatestSpy).toHaveBeenCalledTimes(0);
            expect(authAccountsSpy).toHaveBeenCalledTimes(1);
        });
    });
    describe("upload", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const wasm = testutils_spec_1.getHackatom().data;
            const { codeId, originalChecksum, originalSize, compressedChecksum, compressedSize } = await client.upload(wasm);
            expect(originalChecksum).toEqual(encoding_1.toHex(crypto_1.sha256(wasm)));
            expect(originalSize).toEqual(wasm.length);
            expect(compressedChecksum).toMatch(/^[0-9a-f]{64}$/);
            expect(compressedSize).toBeLessThan(wasm.length * 0.5);
            expect(codeId).toBeGreaterThanOrEqual(1);
        });
        it("can set builder and source", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const hackatom = testutils_spec_1.getHackatom();
            const meta = {
                source: "https://crates.io/api/v1/crates/cw-nameservice/0.1.0/download",
                builder: "confio/cosmwasm-opt:0.6.2",
            };
            const { codeId } = await client.upload(hackatom.data, meta);
            const codeDetails = await client.getCodeDetails(codeId);
            expect(codeDetails.source).toEqual(meta.source);
            expect(codeDetails.builder).toEqual(meta.builder);
        });
    });
    describe("instantiate", () => {
        it("works with transfer amount", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            const funds = [launchpad_1.coin(1234, "ucosm"), launchpad_1.coin(321, "ustake")];
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                memo: "Let's see if the memo is used",
                transferAmount: funds,
            });
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const balance = (await lcdClient.auth.account(contractAddress)).result.value.coins;
            expect(balance).toEqual(funds);
        });
        it("works with admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", { admin: testutils_spec_1.unused.address });
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const contract = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(contract);
            expect(contract.admin).toEqual(testutils_spec_1.unused.address);
        });
        it("can instantiate one code multiple times", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            const contractAddress1 = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: testutils_spec_1.makeRandomAddress(),
            }, "contract 1");
            const contractAddress2 = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: testutils_spec_1.makeRandomAddress(),
            }, "contract 2");
            expect(contractAddress1).not.toEqual(contractAddress2);
        });
    });
    describe("updateAdmin", () => {
        it("can update an admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const state1 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state1);
            expect(state1.admin).toEqual(testutils_spec_1.alice.address0);
            await client.updateAdmin(contractAddress, testutils_spec_1.unused.address);
            const state2 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state2);
            expect(state2.admin).toEqual(testutils_spec_1.unused.address);
        });
    });
    describe("clearAdmin", () => {
        it("can clear an admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const state1 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state1);
            expect(state1.admin).toEqual(testutils_spec_1.alice.address0);
            await client.clearAdmin(contractAddress);
            const state2 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state2);
            expect(state2.admin).toBeUndefined();
        });
    });
    describe("migrate", () => {
        it("can can migrate from one code ID to another", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId: codeId1 } = await client.upload(testutils_spec_1.getHackatom().data);
            const { codeId: codeId2 } = await client.upload(testutils_spec_1.getHackatom().data);
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId1, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "My cool label", {
                admin: testutils_spec_1.alice.address0,
            });
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const state1 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state1);
            expect(state1.admin).toEqual(testutils_spec_1.alice.address0);
            const newVerifier = testutils_spec_1.makeRandomAddress();
            await client.migrate(contractAddress, codeId2, { verifier: newVerifier });
            const state2 = await lcdClient.wasm.getContractInfo(contractAddress);
            utils_1.assert(state2);
            expect(state2).toEqual(Object.assign(Object.assign({}, state1), { code_id: codeId2 }));
        });
    });
    describe("execute", () => {
        it("works", async () => {
            var _a;
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const { codeId } = await client.upload(testutils_spec_1.getHackatom().data);
            // instantiate
            const funds = [launchpad_1.coin(233444, "ucosm"), launchpad_1.coin(5454, "ustake")];
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            const { contractAddress } = await client.instantiate(codeId, {
                verifier: testutils_spec_1.alice.address0,
                beneficiary: beneficiaryAddress,
            }, "amazing random contract", {
                transferAmount: funds,
            });
            // execute
            const result = await client.execute(contractAddress, { release: {} }, undefined);
            const wasmEvent = (_a = result.logs.find(() => true)) === null || _a === void 0 ? void 0 : _a.events.find((e) => e.type === "wasm");
            utils_1.assert(wasmEvent, "Event of type wasm expected");
            expect(wasmEvent.attributes).toContain({ key: "action", value: "release" });
            expect(wasmEvent.attributes).toContain({
                key: "destination",
                value: beneficiaryAddress,
            });
            // Verify token transfer from contract to beneficiary
            const lcdClient = makeWasmClient(testutils_spec_1.launchpad.endpoint);
            const beneficiaryBalance = (await lcdClient.auth.account(beneficiaryAddress)).result.value.coins;
            expect(beneficiaryBalance).toEqual(funds);
            const contractBalance = (await lcdClient.auth.account(contractAddress)).result.value.coins;
            expect(contractBalance).toEqual([]);
        });
    });
    describe("sendTokens", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const amount = launchpad_1.coins(7890, "ucosm");
            const beneficiaryAddress = testutils_spec_1.makeRandomAddress();
            // no tokens here
            const before = await client.getAccount(beneficiaryAddress);
            expect(before).toBeUndefined();
            // send
            const result = await client.sendTokens(beneficiaryAddress, amount, "for dinner");
            launchpad_1.assertIsBroadcastTxSuccess(result);
            const [firstLog] = result.logs;
            expect(firstLog).toBeTruthy();
            // got tokens
            const after = await client.getAccount(beneficiaryAddress);
            utils_1.assert(after);
            expect(after.balance).toEqual(amount);
        });
    });
    describe("signAndBroadcast", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            const msg = {
                type: "cosmos-sdk/MsgDelegate",
                value: {
                    delegator_address: testutils_spec_1.alice.address0,
                    validator_address: testutils_spec_1.launchpad.validator.address,
                    amount: launchpad_1.coin(1234, "ustake"),
                },
            };
            const fee = {
                amount: launchpad_1.coins(2000, "ucosm"),
                gas: "180000",
            };
            const result = await client.signAndBroadcast([msg], fee, "Use your power wisely");
            launchpad_1.assertIsBroadcastTxSuccess(result);
        });
    });
});
//# sourceMappingURL=signingcosmwasmclient.spec.js.map