"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigningCosmWasmClient = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const math_1 = require("@cosmjs/math");
const pako_1 = __importDefault(require("pako"));
const builder_1 = require("./builder");
const cosmwasmclient_1 = require("./cosmwasmclient");
function prepareBuilder(builder) {
    if (builder === undefined) {
        return ""; // normalization needed by backend
    }
    else {
        if (!builder_1.isValidBuilder(builder))
            throw new Error("The builder (Docker Hub image with tag) is not valid");
        return builder;
    }
}
const defaultGasPrice = launchpad_1.GasPrice.fromString("0.025ucosm");
const defaultGasLimits = {
    upload: 1500000,
    init: 500000,
    migrate: 200000,
    exec: 200000,
    send: 80000,
    changeAdmin: 80000,
};
function createBroadcastTxErrorMessage(result) {
    return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
}
class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
    /**
     * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.
     *
     * This instance does a lot of caching. In order to benefit from that you should try to use one instance
     * for the lifetime of your application. When switching backends, a new instance must be created.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param signerAddress The address that will sign transactions using this instance. The `signer` must be able to sign with this address.
     * @param signer An implementation of OfflineSigner which can provide signatures for transactions, potentially requiring user input.
     * @param gasPrice The price paid per unit of gas
     * @param gasLimits Custom overrides for gas limits related to specific transaction types
     * @param broadcastMode Defines at which point of the transaction processing the broadcastTx method returns
     */
    constructor(apiUrl, signerAddress, signer, gasPrice = defaultGasPrice, gasLimits = {}, broadcastMode = launchpad_1.BroadcastMode.Block) {
        super(apiUrl, broadcastMode);
        this.anyValidAddress = signerAddress;
        this.signerAddress = signerAddress;
        this.signer = signer;
        this.fees = launchpad_1.buildFeeTable(gasPrice, defaultGasLimits, gasLimits);
    }
    async getSequence(address) {
        return super.getSequence(address || this.signerAddress);
    }
    async getAccount(address) {
        return super.getAccount(address || this.signerAddress);
    }
    /** Uploads code and returns a receipt, including the code ID */
    async upload(wasmCode, meta = {}, memo = "") {
        const source = meta.source || "";
        const builder = prepareBuilder(meta.builder);
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
            type: "wasm/MsgStoreCode",
            value: {
                sender: this.signerAddress,
                wasm_byte_code: encoding_1.toBase64(compressed),
                source: source,
                builder: builder,
            },
        };
        const result = await this.signAndBroadcast([storeCodeMsg], this.fees.upload, memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const codeIdAttr = launchpad_1.logs.findAttribute(result.logs, "message", "code_id");
        return {
            originalSize: wasmCode.length,
            originalChecksum: encoding_1.toHex(crypto_1.sha256(wasmCode)),
            compressedSize: compressed.length,
            compressedChecksum: encoding_1.toHex(crypto_1.sha256(compressed)),
            codeId: Number.parseInt(codeIdAttr.value, 10),
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async instantiate(codeId, msg, label, options = {}) {
        const instantiateMsg = {
            type: "wasm/MsgInstantiateContract",
            value: {
                sender: this.signerAddress,
                code_id: new math_1.Uint53(codeId).toString(),
                label: label,
                init_msg: msg,
                init_funds: options.transferAmount || [],
                admin: options.admin,
            },
        };
        const result = await this.signAndBroadcast([instantiateMsg], this.fees.init, options.memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const contractAddressAttr = launchpad_1.logs.findAttribute(result.logs, "message", "contract_address");
        return {
            contractAddress: contractAddressAttr.value,
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async updateAdmin(contractAddress, newAdmin, memo = "") {
        const updateAdminMsg = {
            type: "wasm/MsgUpdateAdmin",
            value: {
                sender: this.signerAddress,
                contract: contractAddress,
                new_admin: newAdmin,
            },
        };
        const result = await this.signAndBroadcast([updateAdminMsg], this.fees.changeAdmin, memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async clearAdmin(contractAddress, memo = "") {
        const clearAdminMsg = {
            type: "wasm/MsgClearAdmin",
            value: {
                sender: this.signerAddress,
                contract: contractAddress,
            },
        };
        const result = await this.signAndBroadcast([clearAdminMsg], this.fees.changeAdmin, memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async migrate(contractAddress, codeId, migrateMsg, memo = "") {
        const msg = {
            type: "wasm/MsgMigrateContract",
            value: {
                sender: this.signerAddress,
                contract: contractAddress,
                code_id: new math_1.Uint53(codeId).toString(),
                msg: migrateMsg,
            },
        };
        const result = await this.signAndBroadcast([msg], this.fees.migrate, memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async execute(contractAddress, msg, memo = "", funds) {
        const executeMsg = {
            type: "wasm/MsgExecuteContract",
            value: {
                sender: this.signerAddress,
                contract: contractAddress,
                msg: msg,
                sent_funds: funds || [],
            },
        };
        const result = await this.signAndBroadcast([executeMsg], this.fees.exec, memo);
        if (launchpad_1.isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        return {
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async sendTokens(recipientAddress, amount, memo = "") {
        const sendMsg = {
            type: "cosmos-sdk/MsgSend",
            value: {
                from_address: this.signerAddress,
                to_address: recipientAddress,
                amount: amount,
            },
        };
        return this.signAndBroadcast([sendMsg], this.fees.send, memo);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature, assembles the signed transaction and broadcasts it.
     */
    async signAndBroadcast(msgs, fee, memo = "") {
        const { accountNumber, sequence } = await this.getSequence();
        const chainId = await this.getChainId();
        const signDoc = launchpad_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signed, signature } = await this.signer.signAmino(this.signerAddress, signDoc);
        const signedTx = launchpad_1.makeStdTx(signed, signature);
        return this.broadcastTx(signedTx);
    }
}
exports.SigningCosmWasmClient = SigningCosmWasmClient;
//# sourceMappingURL=signingcosmwasmclient.js.map