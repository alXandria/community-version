"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const launchpad_1 = require("@cosmjs/launchpad");
const utils_1 = require("@cosmjs/utils");
const cosmwasmclient_1 = require("./cosmwasmclient");
const msgs_1 = require("./msgs");
const signingcosmwasmclient_1 = require("./signingcosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
describe("CosmWasmClient.getTx and .searchTx", () => {
    let sendSuccessful;
    let sendSelfSuccessful;
    let sendUnsuccessful;
    let execute;
    beforeAll(async () => {
        if (testutils_spec_1.launchpadEnabled() && testutils_spec_1.erc20Enabled()) {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new signingcosmwasmclient_1.SigningCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet);
            {
                const recipient = testutils_spec_1.makeRandomAddress();
                const amount = launchpad_1.coins(1234567, "ucosm");
                const result = await client.sendTokens(recipient, amount);
                await utils_1.sleep(75); // wait until tx is indexed
                const txDetails = await new launchpad_1.LcdClient(testutils_spec_1.launchpad.endpoint).txById(result.transactionHash);
                sendSuccessful = {
                    sender: testutils_spec_1.alice.address0,
                    recipient: recipient,
                    hash: result.transactionHash,
                    height: Number.parseInt(txDetails.height, 10),
                    tx: txDetails.tx,
                };
            }
            {
                const recipient = testutils_spec_1.alice.address0;
                const amount = launchpad_1.coins(2345678, "ucosm");
                const result = await client.sendTokens(recipient, amount);
                await utils_1.sleep(75); // wait until tx is indexed
                const txDetails = await new launchpad_1.LcdClient(testutils_spec_1.launchpad.endpoint).txById(result.transactionHash);
                sendSelfSuccessful = {
                    sender: testutils_spec_1.alice.address0,
                    recipient: recipient,
                    hash: result.transactionHash,
                    height: Number.parseInt(txDetails.height, 10),
                    tx: txDetails.tx,
                };
            }
            {
                const memo = "Sending more than I can afford";
                const recipient = testutils_spec_1.makeRandomAddress();
                const amount = launchpad_1.coins(123456700000000, "ucosm");
                const sendMsg = {
                    type: "cosmos-sdk/MsgSend",
                    value: {
                        from_address: testutils_spec_1.alice.address0,
                        to_address: recipient,
                        amount: amount,
                    },
                };
                const fee = {
                    amount: launchpad_1.coins(2000, "ucosm"),
                    gas: "80000",
                };
                const { accountNumber, sequence } = await client.getSequence();
                const chainId = await client.getChainId();
                const signDoc = launchpad_1.makeSignDoc([sendMsg], fee, chainId, memo, accountNumber, sequence);
                const { signed, signature } = await wallet.signAmino(testutils_spec_1.alice.address0, signDoc);
                const tx = {
                    type: "cosmos-sdk/StdTx",
                    value: launchpad_1.makeStdTx(signed, signature),
                };
                const transactionId = await client.getIdentifier(tx);
                const result = await client.broadcastTx(tx.value);
                if (launchpad_1.isBroadcastTxFailure(result)) {
                    sendUnsuccessful = {
                        sender: testutils_spec_1.alice.address0,
                        recipient: recipient,
                        hash: transactionId,
                        height: result.height,
                        tx: tx,
                    };
                }
            }
            {
                const hashInstance = testutils_spec_1.deployedErc20.instances[0];
                const msg = {
                    approve: {
                        spender: testutils_spec_1.makeRandomAddress(),
                        amount: "12",
                    },
                };
                const result = await client.execute(hashInstance, msg);
                await utils_1.sleep(75); // wait until tx is indexed
                const txDetails = await new launchpad_1.LcdClient(testutils_spec_1.launchpad.endpoint).txById(result.transactionHash);
                execute = {
                    sender: testutils_spec_1.alice.address0,
                    contract: hashInstance,
                    hash: result.transactionHash,
                    height: Number.parseInt(txDetails.height, 10),
                    tx: txDetails.tx,
                };
            }
        }
    });
    describe("getTx", () => {
        it("can get successful tx by ID", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.getTx(sendSuccessful.hash);
            expect(result).toEqual(jasmine.objectContaining({
                height: sendSuccessful.height,
                hash: sendSuccessful.hash,
                code: 0,
                tx: sendSuccessful.tx,
            }));
        });
        it("can get unsuccessful tx by ID", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendUnsuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.getTx(sendUnsuccessful.hash);
            expect(result).toEqual(jasmine.objectContaining({
                height: sendUnsuccessful.height,
                hash: sendUnsuccessful.hash,
                code: 5,
                tx: sendUnsuccessful.tx,
            }));
        });
        it("can get by ID (non existent)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const nonExistentId = "0000000000000000000000000000000000000000000000000000000000000000";
            const result = await client.getTx(nonExistentId);
            expect(result).toBeNull();
        });
    });
    describe("with SearchByHeightQuery", () => {
        it("can search successful tx by height", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.searchTx({ height: sendSuccessful.height });
            expect(result.length).toBeGreaterThanOrEqual(1);
            expect(result).toContain(jasmine.objectContaining({
                height: sendSuccessful.height,
                hash: sendSuccessful.hash,
                code: 0,
                tx: sendSuccessful.tx,
            }));
        });
        it("can search unsuccessful tx by height", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendUnsuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const result = await client.searchTx({ height: sendUnsuccessful.height });
            expect(result.length).toBeGreaterThanOrEqual(1);
            expect(result).toContain(jasmine.objectContaining({
                height: sendUnsuccessful.height,
                hash: sendUnsuccessful.hash,
                code: 5,
                tx: sendUnsuccessful.tx,
            }));
        });
    });
    describe("with SearchBySentFromOrToQuery", () => {
        it("can search by sender", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({ sentFromOrTo: sendSuccessful.sender });
            expect(results.length).toBeGreaterThanOrEqual(1);
            // Check basic structure of all results
            for (const result of results) {
                const containsMsgWithSender = !!result.tx.value.msg.find((msg) => launchpad_1.isMsgSend(msg) && msg.value.from_address == sendSuccessful.sender);
                const containsMsgWithRecipient = !!result.tx.value.msg.find((msg) => launchpad_1.isMsgSend(msg) && msg.value.to_address === sendSuccessful.sender);
                expect(containsMsgWithSender || containsMsgWithRecipient).toEqual(true);
            }
            // Check details of most recent result (not sent to self)
            expect(results[results.length - 2]).toEqual(jasmine.objectContaining({
                height: sendSuccessful.height,
                hash: sendSuccessful.hash,
                tx: sendSuccessful.tx,
            }));
        });
        it("can search by recipient", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({ sentFromOrTo: sendSuccessful.recipient });
            expect(results.length).toBeGreaterThanOrEqual(1);
            // Check basic structure of all results
            for (const result of results) {
                const msg = testutils_spec_1.fromOneElementArray(result.tx.value.msg);
                utils_1.assert(launchpad_1.isMsgSend(msg), `${result.hash} (height ${result.height}) is not a bank send transaction`);
                expect(msg.value.to_address === sendSuccessful.recipient ||
                    msg.value.from_address == sendSuccessful.recipient).toEqual(true);
            }
            // Check details of most recent result
            expect(results[results.length - 1]).toEqual(jasmine.objectContaining({
                height: sendSuccessful.height,
                hash: sendSuccessful.hash,
                tx: sendSuccessful.tx,
            }));
        });
        it("can search by sender or recipient (sorted and deduplicated)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSelfSuccessful, "value must be set in beforeAll()");
            const txhash = sendSelfSuccessful.hash;
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({ sentFromOrTo: sendSelfSuccessful.recipient });
            expect(Array.from(results).sort((tx1, tx2) => tx1.height - tx2.height)).toEqual(results);
            expect(results.filter((result) => result.hash === txhash).length).toEqual(1);
        });
        it("can search by recipient and filter by minHeight", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const query = { sentFromOrTo: sendSuccessful.recipient };
            {
                const result = await client.searchTx(query, { minHeight: 0 });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { minHeight: sendSuccessful.height - 1 });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { minHeight: sendSuccessful.height });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { minHeight: sendSuccessful.height + 1 });
                expect(result.length).toEqual(0);
            }
        });
        it("can search by recipient and filter by maxHeight", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful);
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const query = { sentFromOrTo: sendSuccessful.recipient };
            {
                const result = await client.searchTx(query, { maxHeight: 9999999999999 });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { maxHeight: sendSuccessful.height + 1 });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { maxHeight: sendSuccessful.height });
                expect(result.length).toEqual(1);
            }
            {
                const result = await client.searchTx(query, { maxHeight: sendSuccessful.height - 1 });
                expect(result.length).toEqual(0);
            }
        });
    });
    describe("with SearchByTagsQuery", () => {
        it("can search by transfer.recipient", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(sendSuccessful, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({
                tags: [{ key: "transfer.recipient", value: sendSuccessful.recipient }],
            });
            expect(results.length).toBeGreaterThanOrEqual(1);
            // Check basic structure of all results
            for (const result of results) {
                const msg = testutils_spec_1.fromOneElementArray(result.tx.value.msg);
                utils_1.assert(launchpad_1.isMsgSend(msg), `${result.hash} (height ${result.height}) is not a bank send transaction`);
                expect(msg.value.to_address).toEqual(sendSuccessful.recipient);
            }
            // Check details of most recent result
            expect(results[results.length - 1]).toEqual(jasmine.objectContaining({
                height: sendSuccessful.height,
                hash: sendSuccessful.hash,
                tx: sendSuccessful.tx,
            }));
        });
        it("can search by message.contract_address", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(execute, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({
                tags: [{ key: "message.contract_address", value: execute.contract }],
            });
            expect(results.length).toBeGreaterThanOrEqual(1);
            // Check basic structure of all results
            for (const result of results) {
                const msg = testutils_spec_1.fromOneElementArray(result.tx.value.msg);
                utils_1.assert(msgs_1.isMsgExecuteContract(msg) || msgs_1.isMsgInstantiateContract(msg), `${result.hash} (at ${result.height}) not an execute or instantiate msg`);
            }
            // Check that the first result is the instantiation
            const first = testutils_spec_1.fromOneElementArray(results[0].tx.value.msg);
            utils_1.assert(msgs_1.isMsgInstantiateContract(first), "First contract search result must be an instantiation");
            expect(first).toEqual({
                type: "wasm/MsgInstantiateContract",
                value: {
                    sender: testutils_spec_1.alice.address0,
                    code_id: testutils_spec_1.deployedErc20.codeId.toString(),
                    label: "HASH",
                    init_msg: jasmine.objectContaining({ symbol: "HASH" }),
                    init_funds: [],
                },
            });
            // Check details of most recent result
            expect(results[results.length - 1]).toEqual(jasmine.objectContaining({
                height: execute.height,
                hash: execute.hash,
                tx: execute.tx,
            }));
        });
        it("can search by message.contract_address + message.action", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutErc20();
            utils_1.assert(execute, "value must be set in beforeAll()");
            const client = new cosmwasmclient_1.CosmWasmClient(testutils_spec_1.launchpad.endpoint);
            const results = await client.searchTx({
                tags: [
                    { key: "message.contract_address", value: execute.contract },
                    { key: "message.action", value: "execute" },
                ],
            });
            expect(results.length).toBeGreaterThanOrEqual(1);
            // Check basic structure of all results
            for (const result of results) {
                const msg = testutils_spec_1.fromOneElementArray(result.tx.value.msg);
                utils_1.assert(msgs_1.isMsgExecuteContract(msg), `${result.hash} (at ${result.height}) not an execute msg`);
                expect(msg.value.contract).toEqual(execute.contract);
            }
            // Check details of most recent result
            expect(results[results.length - 1]).toEqual(jasmine.objectContaining({
                height: execute.height,
                hash: execute.hash,
                tx: execute.tx,
            }));
        });
    });
});
//# sourceMappingURL=cosmwasmclient.searchtx.spec.js.map