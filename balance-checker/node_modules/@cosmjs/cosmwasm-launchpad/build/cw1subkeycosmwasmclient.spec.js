"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const launchpad_1 = require("@cosmjs/launchpad");
const cw1subkeycosmwasmclient_1 = require("./cw1subkeycosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
describe("Cw1SubkeyCosmWasmClient", () => {
    describe("getAdmins", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getAdmins();
            expect(result).toEqual([testutils_spec_1.alice.address0]);
        });
    });
    describe("isAdmin", () => {
        it("returns true if client signer is admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.isAdmin();
            expect(result).toEqual(true);
        });
        it("returns false if client signer is not admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address1, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.isAdmin();
            expect(result).toEqual(false);
        });
        it("returns true if supplied signer is admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address1, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.isAdmin(testutils_spec_1.alice.address0);
            expect(result).toEqual(true);
        });
        it("returns false if supplied signer is not admin", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.isAdmin(testutils_spec_1.alice.address1);
            expect(result).toEqual(false);
        });
    });
    describe("getAllAllowances", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getAllAllowances();
            expect(result).toBeTruthy();
        });
    });
    describe("getAllowance", () => {
        it("works for client signer", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getAllowance();
            expect(result).toEqual({ balance: [], expires: { never: {} } });
        });
    });
    describe("getAllPermissions", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getAllPermissions();
            expect(result.length).toEqual(1);
            // TODO: test content of permissions
        });
    });
    describe("getPermissions", () => {
        it("works for client signer", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getPermissions();
            expect(result).toEqual({
                delegate: false,
                redelegate: false,
                undelegate: false,
                withdraw: false,
            });
        });
        it("works for supplied signer", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const result = await client.getPermissions(testutils_spec_1.alice.address1);
            expect(result).toEqual({
                delegate: false,
                redelegate: false,
                undelegate: false,
                withdraw: false,
            });
        });
    });
    describe("addAdmin and removeAdmin", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const newAdmin = testutils_spec_1.makeRandomAddress();
            expect(await client.isAdmin(newAdmin)).toBeFalse();
            const addResult = await client.addAdmin(newAdmin);
            expect(addResult.transactionHash).toBeTruthy();
            expect(await client.isAdmin(newAdmin)).toBeTrue();
            const removeResult = await client.removeAdmin(newAdmin);
            expect(removeResult.transactionHash).toBeTruthy();
            expect(await client.isAdmin(newAdmin)).toBeFalse();
        });
    });
    describe("increaseAllowance and decreaseAllowance", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const spender = testutils_spec_1.makeRandomAddress();
            expect(await client.getAllowance(spender)).toEqual({ balance: [], expires: { never: {} } });
            const increaseAmount = launchpad_1.coin(100, "ucosm");
            const increaseResult = await client.increaseAllowance(spender, increaseAmount);
            expect(increaseResult.transactionHash).toBeTruthy();
            expect(await client.getAllowance(spender)).toEqual({
                balance: [increaseAmount],
                expires: { never: {} },
            });
            const decreaseAmount = launchpad_1.coin(20, "ucosm");
            const decreaseResult = await client.decreaseAllowance(spender, decreaseAmount);
            expect(decreaseResult.transactionHash).toBeTruthy();
            expect(await client.getAllowance(spender)).toEqual({
                balance: launchpad_1.coins(80, "ucosm"),
                expires: { never: {} },
            });
        });
        it("works with expiration", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const spender = testutils_spec_1.makeRandomAddress();
            expect(await client.getAllowance(spender)).toEqual({ balance: [], expires: { never: {} } });
            const increaseAmount = launchpad_1.coin(100, "ucosm");
            const increaseExpiration = { at_height: 88888888888 };
            const increaseResult = await client.increaseAllowance(spender, increaseAmount, increaseExpiration);
            expect(increaseResult.transactionHash).toBeTruthy();
            expect(await client.getAllowance(spender)).toEqual({
                balance: [increaseAmount],
                expires: increaseExpiration,
            });
            const decreaseAmount = launchpad_1.coin(20, "ucosm");
            const decreaseExpiration = { at_height: 99999999999 };
            const decreaseResult = await client.decreaseAllowance(spender, decreaseAmount, decreaseExpiration);
            expect(decreaseResult.transactionHash).toBeTruthy();
            expect(await client.getAllowance(spender)).toEqual({
                balance: launchpad_1.coins(80, "ucosm"),
                expires: decreaseExpiration,
            });
        });
    });
    describe("setPermissions", () => {
        it("works", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw1();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw1subkeycosmwasmclient_1.Cw1SubkeyCosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw1.instances[0]);
            const spender = testutils_spec_1.makeRandomAddress();
            const defaultPermissions = {
                delegate: false,
                redelegate: false,
                undelegate: false,
                withdraw: false,
            };
            expect(await client.getPermissions(spender)).toEqual(defaultPermissions);
            const newPermissions = {
                delegate: true,
                redelegate: true,
                undelegate: true,
                withdraw: false,
            };
            const setPermissionsResult = await client.setPermissions(spender, newPermissions);
            expect(setPermissionsResult.transactionHash).toBeTruthy();
            expect(await client.getPermissions(spender)).toEqual(newPermissions);
            const resetPermissionsResult = await client.setPermissions(spender, defaultPermissions);
            expect(resetPermissionsResult.transactionHash).toBeTruthy();
            expect(await client.getPermissions(spender)).toEqual(defaultPermissions);
        });
    });
});
//# sourceMappingURL=cw1subkeycosmwasmclient.spec.js.map