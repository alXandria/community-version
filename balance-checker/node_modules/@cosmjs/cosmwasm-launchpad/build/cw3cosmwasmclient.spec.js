"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const launchpad_1 = require("@cosmjs/launchpad");
const utils_1 = require("@cosmjs/utils");
const cw3cosmwasmclient_1 = require("./cw3cosmwasmclient");
const testutils_spec_1 = require("./testutils.spec");
describe("Cw3CosmWasmClient", () => {
    describe("constructor", () => {
        it("can be constructed", async () => {
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw3.instances[0]);
            expect(client).toBeTruthy();
        });
    });
    describe("queries", () => {
        const contractAddress = testutils_spec_1.deployedCw3.instances[0];
        const toAddress = testutils_spec_1.makeRandomAddress();
        const msg = {
            bank: {
                send: {
                    from_address: contractAddress,
                    to_address: toAddress,
                    amount: [
                        {
                            amount: "1",
                            denom: "ucosm",
                        },
                    ],
                },
            },
        };
        let proposalId;
        let expirationHeight;
        beforeAll(async () => {
            if (testutils_spec_1.launchpadEnabled() && testutils_spec_1.cw3Enabled()) {
                const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
                const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
                const currentHeight = await client.getHeight();
                expirationHeight = currentHeight + 1;
                const { logs } = await client.createMultisigProposal("My proposal", "A proposal to propose proposing proposals", [msg], undefined, { at_height: expirationHeight });
                const wasmEvents = logs[0].events.find((event) => event.type === "wasm");
                utils_1.assert(wasmEvents, "Wasm events not found in logs");
                const proposalIdAttribute = wasmEvents.attributes.find((log) => log.key === "proposal_id");
                utils_1.assert(proposalIdAttribute, "Proposal ID not found in logs");
                proposalId = parseInt(proposalIdAttribute.value, 10);
            }
        });
        it("getThreshold", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, testutils_spec_1.deployedCw3.instances[0]);
            const result = await client.getThreshold();
            expect(result).toEqual({ absolute_count: { weight_needed: 1, total_weight: 3 } });
        });
        it("getProposal", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            utils_1.assert(proposalId, "value must be set in beforeAll()");
            utils_1.assert(expirationHeight, "value must be set in beforeAll()");
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.getProposal(proposalId);
            expect(result).toEqual({
                id: proposalId,
                title: "My proposal",
                description: "A proposal to propose proposing proposals",
                msgs: [msg],
                expires: { at_height: expirationHeight },
                status: "passed",
            });
        });
        it("listProposals", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            utils_1.assert(proposalId, "value must be set in beforeAll()");
            utils_1.assert(expirationHeight, "value must be set in beforeAll()");
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.listProposals({ startAfter: proposalId - 1, limit: 1 });
            expect(result).toEqual({
                proposals: [
                    {
                        id: proposalId,
                        title: "My proposal",
                        description: "A proposal to propose proposing proposals",
                        msgs: [msg],
                        expires: { at_height: expirationHeight },
                        status: "passed",
                    },
                ],
            });
        });
        it("reverseProposals", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            utils_1.assert(proposalId, "value must be set in beforeAll()");
            utils_1.assert(expirationHeight, "value must be set in beforeAll()");
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.reverseProposals({ limit: 1 });
            expect(result).toEqual({
                proposals: [
                    {
                        id: proposalId,
                        title: "My proposal",
                        description: "A proposal to propose proposing proposals",
                        msgs: [msg],
                        expires: { at_height: expirationHeight },
                        status: "passed",
                    },
                ],
            });
        });
        it("getVote", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            utils_1.assert(proposalId, "value must be set in beforeAll()");
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.getVote(proposalId, testutils_spec_1.alice.address0);
            expect(result).toEqual({ vote: cw3cosmwasmclient_1.Vote.Yes });
        });
        it("listVotes", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            utils_1.assert(proposalId, "value must be set in beforeAll()");
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.listVotes(proposalId);
            expect(result).toEqual({ votes: [{ voter: testutils_spec_1.alice.address0, vote: cw3cosmwasmclient_1.Vote.Yes, weight: 1 }] });
        });
        it("getVoter", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.getVoter(testutils_spec_1.alice.address0);
            expect(result).toEqual({ addr: testutils_spec_1.alice.address0, weight: 1 });
        });
        it("listVoters", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const result = await client.listVoters();
            expect(result.voters.length).toEqual(3);
            expect(result.voters).toEqual(jasmine.arrayContaining([
                { addr: testutils_spec_1.alice.address0, weight: 1 },
                { addr: testutils_spec_1.alice.address1, weight: 1 },
                { addr: testutils_spec_1.alice.address2, weight: 1 },
            ]));
        });
    });
    describe("Proposal lifecycle", () => {
        it("proposal is accepted (proposer has enough weight alone)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const contractAddress = testutils_spec_1.deployedCw3.instances[0];
            const wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const client = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, wallet, contractAddress);
            const toAddress = testutils_spec_1.makeRandomAddress();
            const msg = {
                bank: {
                    send: {
                        from_address: contractAddress,
                        to_address: toAddress,
                        amount: [
                            {
                                amount: "1",
                                denom: "ucosm",
                            },
                        ],
                    },
                },
            };
            await client.createMultisigProposal("My proposal", "A proposal to propose proposing proposals", [msg]);
            const { proposals } = await client.reverseProposals({ limit: 1 });
            const proposalId = proposals[0].id;
            const executeResult = await client.executeMultisigProposal(proposalId);
            expect(executeResult).toBeTruthy();
        });
        it("proposal is accepted (proposer does not have enough weight alone)", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const contractAddress = testutils_spec_1.deployedCw3.instances[1];
            const proposerWallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const proposer = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, proposerWallet, contractAddress);
            const voterWallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                hdPaths: [launchpad_1.makeCosmoshubPath(1)],
            });
            const voter = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address1, voterWallet, contractAddress);
            const toAddress = testutils_spec_1.makeRandomAddress();
            const msg = {
                bank: {
                    send: {
                        from_address: contractAddress,
                        to_address: toAddress,
                        amount: [
                            {
                                amount: "1",
                                denom: "ucosm",
                            },
                        ],
                    },
                },
            };
            await proposer.createMultisigProposal("My proposal", "A proposal to propose proposing proposals", [
                msg,
            ]);
            const { proposals } = await voter.reverseProposals({ limit: 1 });
            const proposalId = proposals[0].id;
            await expectAsync(proposer.executeMultisigProposal(proposalId)).toBeRejectedWithError(/proposal must have passed and not yet been executed/i);
            const voteResult = await voter.voteMultisigProposal(proposalId, cw3cosmwasmclient_1.Vote.Yes);
            expect(voteResult).toBeTruthy();
            const executeResult = await proposer.executeMultisigProposal(proposalId);
            expect(executeResult).toBeTruthy();
        });
        it("proposal is rejected", async () => {
            testutils_spec_1.pendingWithoutLaunchpad();
            testutils_spec_1.pendingWithoutCw3();
            const contractAddress = testutils_spec_1.deployedCw3.instances[1];
            const proposerWallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic);
            const proposer = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address0, proposerWallet, contractAddress);
            const voter1Wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                hdPaths: [launchpad_1.makeCosmoshubPath(1)],
            });
            const voter1 = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address1, voter1Wallet, contractAddress);
            const voter2Wallet = await launchpad_1.Secp256k1HdWallet.fromMnemonic(testutils_spec_1.alice.mnemonic, {
                hdPaths: [launchpad_1.makeCosmoshubPath(2)],
            });
            const voter2 = new cw3cosmwasmclient_1.Cw3CosmWasmClient(testutils_spec_1.launchpad.endpoint, testutils_spec_1.alice.address2, voter2Wallet, contractAddress);
            const toAddress = testutils_spec_1.makeRandomAddress();
            const msg = {
                bank: {
                    send: {
                        from_address: contractAddress,
                        to_address: toAddress,
                        amount: [
                            {
                                amount: "1",
                                denom: "ucosm",
                            },
                        ],
                    },
                },
            };
            const currentHeight = await proposer.getHeight();
            await proposer.createMultisigProposal("My proposal", "A proposal to propose proposing proposals", [msg], {
                at_height: currentHeight,
            }, {
                at_height: currentHeight + 5,
            });
            const { proposals } = await voter1.reverseProposals({ limit: 1 });
            const proposalId = proposals[0].id;
            const vote1Result = await voter1.voteMultisigProposal(proposalId, cw3cosmwasmclient_1.Vote.Abstain);
            expect(vote1Result).toBeTruthy();
            const vote2Result = await voter2.voteMultisigProposal(proposalId, cw3cosmwasmclient_1.Vote.No);
            expect(vote2Result).toBeTruthy();
            await expectAsync(proposer.executeMultisigProposal(proposalId)).toBeRejectedWithError(/proposal must have passed and not yet been executed/i);
            const closeResult = await proposer.closeMultisigProposal(proposalId);
            expect(closeResult).toBeTruthy();
        });
    });
});
//# sourceMappingURL=cw3cosmwasmclient.spec.js.map