{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nconst connection_1 = require(\"../../../../ibc/core/connection/v1/connection\");\n\nconst any_1 = require(\"../../../../google/protobuf/any\");\n\nconst client_1 = require(\"../../../../ibc/core/client/v1/client\");\n\nexports.protobufPackage = \"ibc.core.connection.v1\";\nconst baseMsgConnectionOpenInit = {\n  clientId: \"\",\n  delayPeriod: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgConnectionOpenInit = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    if (message.counterparty !== undefined) {\n      connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.version !== undefined) {\n      connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(32).uint64(message.delayPeriod);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenInit);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.version = connection_1.Version.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenInit);\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromJSON(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n    message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenInit);\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromPartial(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenInitResponse = {};\nexports.MsgConnectionOpenInitResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenTry = {\n  clientId: \"\",\n  previousConnectionId: \"\",\n  delayPeriod: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgConnectionOpenTry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    if (message.previousConnectionId !== \"\") {\n      writer.uint32(18).string(message.previousConnectionId);\n    }\n\n    if (message.clientState !== undefined) {\n      any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.counterparty !== undefined) {\n      connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(40).uint64(message.delayPeriod);\n    }\n\n    for (const v of message.counterpartyVersions) {\n      connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(66).bytes(message.proofInit);\n    }\n\n    if (message.proofClient.length !== 0) {\n      writer.uint32(74).bytes(message.proofClient);\n    }\n\n    if (message.proofConsensus.length !== 0) {\n      writer.uint32(82).bytes(message.proofConsensus);\n    }\n\n    if (message.consensusHeight !== undefined) {\n      client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(98).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.counterpartyVersions = [];\n    message.proofInit = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.previousConnectionId = reader.string();\n          break;\n\n        case 3:\n          message.clientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        case 6:\n          message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));\n          break;\n\n        case 7:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 9:\n          message.proofClient = reader.bytes();\n          break;\n\n        case 10:\n          message.proofConsensus = reader.bytes();\n          break;\n\n        case 11:\n          message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 12:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.counterpartyVersions = [];\n    message.proofInit = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.previousConnectionId !== undefined && object.previousConnectionId !== null) {\n      message.previousConnectionId = String(object.previousConnectionId);\n    } else {\n      message.previousConnectionId = \"\";\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromJSON(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n      for (const e of object.counterpartyVersions) {\n        message.counterpartyVersions.push(connection_1.Version.fromJSON(e));\n      }\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = bytesFromBase64(object.proofClient);\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = bytesFromBase64(object.proofConsensus);\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.previousConnectionId !== undefined && (obj.previousConnectionId = message.previousConnectionId);\n    message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n\n    if (message.counterpartyVersions) {\n      obj.counterpartyVersions = message.counterpartyVersions.map(e => e ? connection_1.Version.toJSON(e) : undefined);\n    } else {\n      obj.counterpartyVersions = [];\n    }\n\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofClient !== undefined && (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n    message.proofConsensus !== undefined && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n    message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenTry);\n    message.counterpartyVersions = [];\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.previousConnectionId !== undefined && object.previousConnectionId !== null) {\n      message.previousConnectionId = object.previousConnectionId;\n    } else {\n      message.previousConnectionId = \"\";\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromPartial(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n      for (const e of object.counterpartyVersions) {\n        message.counterpartyVersions.push(connection_1.Version.fromPartial(e));\n      }\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = object.proofClient;\n    } else {\n      message.proofClient = new Uint8Array();\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = object.proofConsensus;\n    } else {\n      message.proofConsensus = new Uint8Array();\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenTryResponse = {};\nexports.MsgConnectionOpenTryResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenAck = {\n  connectionId: \"\",\n  counterpartyConnectionId: \"\",\n  signer: \"\"\n};\nexports.MsgConnectionOpenAck = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.connectionId !== \"\") {\n      writer.uint32(10).string(message.connectionId);\n    }\n\n    if (message.counterpartyConnectionId !== \"\") {\n      writer.uint32(18).string(message.counterpartyConnectionId);\n    }\n\n    if (message.version !== undefined) {\n      connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.clientState !== undefined) {\n      any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();\n    }\n\n    if (message.proofTry.length !== 0) {\n      writer.uint32(50).bytes(message.proofTry);\n    }\n\n    if (message.proofClient.length !== 0) {\n      writer.uint32(58).bytes(message.proofClient);\n    }\n\n    if (message.proofConsensus.length !== 0) {\n      writer.uint32(66).bytes(message.proofConsensus);\n    }\n\n    if (message.consensusHeight !== undefined) {\n      client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(82).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenAck);\n    message.proofTry = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.connectionId = reader.string();\n          break;\n\n        case 2:\n          message.counterpartyConnectionId = reader.string();\n          break;\n\n        case 3:\n          message.version = connection_1.Version.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.clientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.proofTry = reader.bytes();\n          break;\n\n        case 7:\n          message.proofClient = reader.bytes();\n          break;\n\n        case 8:\n          message.proofConsensus = reader.bytes();\n          break;\n\n        case 9:\n          message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 10:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenAck);\n    message.proofTry = new Uint8Array();\n    message.proofClient = new Uint8Array();\n    message.proofConsensus = new Uint8Array();\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.counterpartyConnectionId !== undefined && object.counterpartyConnectionId !== null) {\n      message.counterpartyConnectionId = String(object.counterpartyConnectionId);\n    } else {\n      message.counterpartyConnectionId = \"\";\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromJSON(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromJSON(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = bytesFromBase64(object.proofTry);\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = bytesFromBase64(object.proofClient);\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = bytesFromBase64(object.proofConsensus);\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.counterpartyConnectionId !== undefined && (obj.counterpartyConnectionId = message.counterpartyConnectionId);\n    message.version !== undefined && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n    message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofClient !== undefined && (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n    message.proofConsensus !== undefined && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n    message.consensusHeight !== undefined && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenAck);\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = object.connectionId;\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.counterpartyConnectionId !== undefined && object.counterpartyConnectionId !== null) {\n      message.counterpartyConnectionId = object.counterpartyConnectionId;\n    } else {\n      message.counterpartyConnectionId = \"\";\n    }\n\n    if (object.version !== undefined && object.version !== null) {\n      message.version = connection_1.Version.fromPartial(object.version);\n    } else {\n      message.version = undefined;\n    }\n\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromPartial(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = object.proofTry;\n    } else {\n      message.proofTry = new Uint8Array();\n    }\n\n    if (object.proofClient !== undefined && object.proofClient !== null) {\n      message.proofClient = object.proofClient;\n    } else {\n      message.proofClient = new Uint8Array();\n    }\n\n    if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n      message.proofConsensus = object.proofConsensus;\n    } else {\n      message.proofConsensus = new Uint8Array();\n    }\n\n    if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n      message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n    } else {\n      message.consensusHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenAckResponse = {};\nexports.MsgConnectionOpenAckResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenConfirm = {\n  connectionId: \"\",\n  signer: \"\"\n};\nexports.MsgConnectionOpenConfirm = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.connectionId !== \"\") {\n      writer.uint32(10).string(message.connectionId);\n    }\n\n    if (message.proofAck.length !== 0) {\n      writer.uint32(18).bytes(message.proofAck);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.connectionId = reader.string();\n          break;\n\n        case 2:\n          message.proofAck = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = bytesFromBase64(object.proofAck);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = object.connectionId;\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = object.proofAck;\n    } else {\n      message.proofAck = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgConnectionOpenConfirmResponse = {};\nexports.MsgConnectionOpenConfirmResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n    return message;\n  }\n\n};\n\nclass MsgClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n  }\n\n  ConnectionOpenInit(request) {\n    const data = exports.MsgConnectionOpenInit.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenInit\", data);\n    return promise.then(data => exports.MsgConnectionOpenInitResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ConnectionOpenTry(request) {\n    const data = exports.MsgConnectionOpenTry.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenTry\", data);\n    return promise.then(data => exports.MsgConnectionOpenTryResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ConnectionOpenAck(request) {\n    const data = exports.MsgConnectionOpenAck.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenAck\", data);\n    return promise.then(data => exports.MsgConnectionOpenAckResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ConnectionOpenConfirm(request) {\n    const data = exports.MsgConnectionOpenConfirm.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenConfirm\", data);\n    return promise.then(data => exports.MsgConnectionOpenConfirmResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n}\n\nexports.MsgClientImpl = MsgClientImpl;\n\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\n\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\n\nfunction base64FromBytes(arr) {\n  const bin = [];\n\n  for (let i = 0; i < arr.byteLength; ++i) {\n    bin.push(String.fromCharCode(arr[i]));\n  }\n\n  return btoa(bin.join(\"\"));\n}\n\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../../../../src/codec/ibc/core/connection/v1/tx.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MsgClientImpl = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst connection_1 = require(\"../../../../ibc/core/connection/v1/connection\");\nconst any_1 = require(\"../../../../google/protobuf/any\");\nconst client_1 = require(\"../../../../ibc/core/client/v1/client\");\nexports.protobufPackage = \"ibc.core.connection.v1\";\nconst baseMsgConnectionOpenInit = { clientId: \"\", delayPeriod: long_1.default.UZERO, signer: \"\" };\nexports.MsgConnectionOpenInit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        if (message.counterparty !== undefined) {\n            connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.version !== undefined) {\n            connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n        }\n        if (!message.delayPeriod.isZero()) {\n            writer.uint32(32).uint64(message.delayPeriod);\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(42).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenInit);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.version = connection_1.Version.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.delayPeriod = reader.uint64();\n                    break;\n                case 5:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenInit);\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = connection_1.Version.fromJSON(object.version);\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        message.counterparty !== undefined &&\n            (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n        message.version !== undefined &&\n            (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenInit);\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = connection_1.Version.fromPartial(object.version);\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = object.delayPeriod;\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgConnectionOpenInitResponse = {};\nexports.MsgConnectionOpenInitResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);\n        return message;\n    },\n};\nconst baseMsgConnectionOpenTry = {\n    clientId: \"\",\n    previousConnectionId: \"\",\n    delayPeriod: long_1.default.UZERO,\n    signer: \"\",\n};\nexports.MsgConnectionOpenTry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        if (message.previousConnectionId !== \"\") {\n            writer.uint32(18).string(message.previousConnectionId);\n        }\n        if (message.clientState !== undefined) {\n            any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.counterparty !== undefined) {\n            connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n        }\n        if (!message.delayPeriod.isZero()) {\n            writer.uint32(40).uint64(message.delayPeriod);\n        }\n        for (const v of message.counterpartyVersions) {\n            connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.proofInit.length !== 0) {\n            writer.uint32(66).bytes(message.proofInit);\n        }\n        if (message.proofClient.length !== 0) {\n            writer.uint32(74).bytes(message.proofClient);\n        }\n        if (message.proofConsensus.length !== 0) {\n            writer.uint32(82).bytes(message.proofConsensus);\n        }\n        if (message.consensusHeight !== undefined) {\n            client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(98).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenTry);\n        message.counterpartyVersions = [];\n        message.proofInit = new Uint8Array();\n        message.proofClient = new Uint8Array();\n        message.proofConsensus = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.previousConnectionId = reader.string();\n                    break;\n                case 3:\n                    message.clientState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.delayPeriod = reader.uint64();\n                    break;\n                case 6:\n                    message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.proofInit = reader.bytes();\n                    break;\n                case 9:\n                    message.proofClient = reader.bytes();\n                    break;\n                case 10:\n                    message.proofConsensus = reader.bytes();\n                    break;\n                case 11:\n                    message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenTry);\n        message.counterpartyVersions = [];\n        message.proofInit = new Uint8Array();\n        message.proofClient = new Uint8Array();\n        message.proofConsensus = new Uint8Array();\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.previousConnectionId !== undefined && object.previousConnectionId !== null) {\n            message.previousConnectionId = String(object.previousConnectionId);\n        }\n        else {\n            message.previousConnectionId = \"\";\n        }\n        if (object.clientState !== undefined && object.clientState !== null) {\n            message.clientState = any_1.Any.fromJSON(object.clientState);\n        }\n        else {\n            message.clientState = undefined;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n            for (const e of object.counterpartyVersions) {\n                message.counterpartyVersions.push(connection_1.Version.fromJSON(e));\n            }\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = bytesFromBase64(object.proofInit);\n        }\n        if (object.proofClient !== undefined && object.proofClient !== null) {\n            message.proofClient = bytesFromBase64(object.proofClient);\n        }\n        if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n            message.proofConsensus = bytesFromBase64(object.proofConsensus);\n        }\n        if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n            message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n        }\n        else {\n            message.consensusHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        message.previousConnectionId !== undefined && (obj.previousConnectionId = message.previousConnectionId);\n        message.clientState !== undefined &&\n            (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n        message.counterparty !== undefined &&\n            (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : undefined);\n        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n        if (message.counterpartyVersions) {\n            obj.counterpartyVersions = message.counterpartyVersions.map((e) => (e ? connection_1.Version.toJSON(e) : undefined));\n        }\n        else {\n            obj.counterpartyVersions = [];\n        }\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.proofInit !== undefined &&\n            (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n        message.proofClient !== undefined &&\n            (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n        message.proofConsensus !== undefined &&\n            (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n        message.consensusHeight !== undefined &&\n            (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenTry);\n        message.counterpartyVersions = [];\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.previousConnectionId !== undefined && object.previousConnectionId !== null) {\n            message.previousConnectionId = object.previousConnectionId;\n        }\n        else {\n            message.previousConnectionId = \"\";\n        }\n        if (object.clientState !== undefined && object.clientState !== null) {\n            message.clientState = any_1.Any.fromPartial(object.clientState);\n        }\n        else {\n            message.clientState = undefined;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = object.delayPeriod;\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        if (object.counterpartyVersions !== undefined && object.counterpartyVersions !== null) {\n            for (const e of object.counterpartyVersions) {\n                message.counterpartyVersions.push(connection_1.Version.fromPartial(e));\n            }\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = object.proofInit;\n        }\n        else {\n            message.proofInit = new Uint8Array();\n        }\n        if (object.proofClient !== undefined && object.proofClient !== null) {\n            message.proofClient = object.proofClient;\n        }\n        else {\n            message.proofClient = new Uint8Array();\n        }\n        if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n            message.proofConsensus = object.proofConsensus;\n        }\n        else {\n            message.proofConsensus = new Uint8Array();\n        }\n        if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n            message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n        }\n        else {\n            message.consensusHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgConnectionOpenTryResponse = {};\nexports.MsgConnectionOpenTryResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);\n        return message;\n    },\n};\nconst baseMsgConnectionOpenAck = { connectionId: \"\", counterpartyConnectionId: \"\", signer: \"\" };\nexports.MsgConnectionOpenAck = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.connectionId !== \"\") {\n            writer.uint32(10).string(message.connectionId);\n        }\n        if (message.counterpartyConnectionId !== \"\") {\n            writer.uint32(18).string(message.counterpartyConnectionId);\n        }\n        if (message.version !== undefined) {\n            connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.clientState !== undefined) {\n            any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.proofTry.length !== 0) {\n            writer.uint32(50).bytes(message.proofTry);\n        }\n        if (message.proofClient.length !== 0) {\n            writer.uint32(58).bytes(message.proofClient);\n        }\n        if (message.proofConsensus.length !== 0) {\n            writer.uint32(66).bytes(message.proofConsensus);\n        }\n        if (message.consensusHeight !== undefined) {\n            client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(82).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenAck);\n        message.proofTry = new Uint8Array();\n        message.proofClient = new Uint8Array();\n        message.proofConsensus = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.connectionId = reader.string();\n                    break;\n                case 2:\n                    message.counterpartyConnectionId = reader.string();\n                    break;\n                case 3:\n                    message.version = connection_1.Version.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.clientState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.proofTry = reader.bytes();\n                    break;\n                case 7:\n                    message.proofClient = reader.bytes();\n                    break;\n                case 8:\n                    message.proofConsensus = reader.bytes();\n                    break;\n                case 9:\n                    message.consensusHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenAck);\n        message.proofTry = new Uint8Array();\n        message.proofClient = new Uint8Array();\n        message.proofConsensus = new Uint8Array();\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = String(object.connectionId);\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.counterpartyConnectionId !== undefined && object.counterpartyConnectionId !== null) {\n            message.counterpartyConnectionId = String(object.counterpartyConnectionId);\n        }\n        else {\n            message.counterpartyConnectionId = \"\";\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = connection_1.Version.fromJSON(object.version);\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.clientState !== undefined && object.clientState !== null) {\n            message.clientState = any_1.Any.fromJSON(object.clientState);\n        }\n        else {\n            message.clientState = undefined;\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.proofTry !== undefined && object.proofTry !== null) {\n            message.proofTry = bytesFromBase64(object.proofTry);\n        }\n        if (object.proofClient !== undefined && object.proofClient !== null) {\n            message.proofClient = bytesFromBase64(object.proofClient);\n        }\n        if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n            message.proofConsensus = bytesFromBase64(object.proofConsensus);\n        }\n        if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n            message.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);\n        }\n        else {\n            message.consensusHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n        message.counterpartyConnectionId !== undefined &&\n            (obj.counterpartyConnectionId = message.counterpartyConnectionId);\n        message.version !== undefined &&\n            (obj.version = message.version ? connection_1.Version.toJSON(message.version) : undefined);\n        message.clientState !== undefined &&\n            (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.proofTry !== undefined &&\n            (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n        message.proofClient !== undefined &&\n            (obj.proofClient = base64FromBytes(message.proofClient !== undefined ? message.proofClient : new Uint8Array()));\n        message.proofConsensus !== undefined &&\n            (obj.proofConsensus = base64FromBytes(message.proofConsensus !== undefined ? message.proofConsensus : new Uint8Array()));\n        message.consensusHeight !== undefined &&\n            (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenAck);\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = object.connectionId;\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.counterpartyConnectionId !== undefined && object.counterpartyConnectionId !== null) {\n            message.counterpartyConnectionId = object.counterpartyConnectionId;\n        }\n        else {\n            message.counterpartyConnectionId = \"\";\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = connection_1.Version.fromPartial(object.version);\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.clientState !== undefined && object.clientState !== null) {\n            message.clientState = any_1.Any.fromPartial(object.clientState);\n        }\n        else {\n            message.clientState = undefined;\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.proofTry !== undefined && object.proofTry !== null) {\n            message.proofTry = object.proofTry;\n        }\n        else {\n            message.proofTry = new Uint8Array();\n        }\n        if (object.proofClient !== undefined && object.proofClient !== null) {\n            message.proofClient = object.proofClient;\n        }\n        else {\n            message.proofClient = new Uint8Array();\n        }\n        if (object.proofConsensus !== undefined && object.proofConsensus !== null) {\n            message.proofConsensus = object.proofConsensus;\n        }\n        else {\n            message.proofConsensus = new Uint8Array();\n        }\n        if (object.consensusHeight !== undefined && object.consensusHeight !== null) {\n            message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);\n        }\n        else {\n            message.consensusHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgConnectionOpenAckResponse = {};\nexports.MsgConnectionOpenAckResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);\n        return message;\n    },\n};\nconst baseMsgConnectionOpenConfirm = { connectionId: \"\", signer: \"\" };\nexports.MsgConnectionOpenConfirm = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.connectionId !== \"\") {\n            writer.uint32(10).string(message.connectionId);\n        }\n        if (message.proofAck.length !== 0) {\n            writer.uint32(18).bytes(message.proofAck);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(34).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n        message.proofAck = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.connectionId = reader.string();\n                    break;\n                case 2:\n                    message.proofAck = reader.bytes();\n                    break;\n                case 3:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n        message.proofAck = new Uint8Array();\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = String(object.connectionId);\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.proofAck !== undefined && object.proofAck !== null) {\n            message.proofAck = bytesFromBase64(object.proofAck);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n        message.proofAck !== undefined &&\n            (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgConnectionOpenConfirm);\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = object.connectionId;\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.proofAck !== undefined && object.proofAck !== null) {\n            message.proofAck = object.proofAck;\n        }\n        else {\n            message.proofAck = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgConnectionOpenConfirmResponse = {};\nexports.MsgConnectionOpenConfirmResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);\n        return message;\n    },\n};\nclass MsgClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n    }\n    ConnectionOpenInit(request) {\n        const data = exports.MsgConnectionOpenInit.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenInit\", data);\n        return promise.then((data) => exports.MsgConnectionOpenInitResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ConnectionOpenTry(request) {\n        const data = exports.MsgConnectionOpenTry.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenTry\", data);\n        return promise.then((data) => exports.MsgConnectionOpenTryResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ConnectionOpenAck(request) {\n        const data = exports.MsgConnectionOpenAck.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenAck\", data);\n        return promise.then((data) => exports.MsgConnectionOpenAckResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ConnectionOpenConfirm(request) {\n        const data = exports.MsgConnectionOpenConfirm.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.connection.v1.Msg\", \"ConnectionOpenConfirm\", data);\n        return promise.then((data) => exports.MsgConnectionOpenConfirmResponse.decode(new minimal_1.default.Reader(data)));\n    }\n}\nexports.MsgClientImpl = MsgClientImpl;\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (let i = 0; i < arr.byteLength; ++i) {\n        bin.push(String.fromCharCode(arr[i]));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map"]},"metadata":{},"sourceType":"script"}