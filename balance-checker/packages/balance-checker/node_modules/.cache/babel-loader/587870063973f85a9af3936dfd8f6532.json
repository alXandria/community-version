{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nfunction compress(proof) {\n  if (!proof.batch) {\n    return proof;\n  }\n\n  return {\n    compressed: compress_batch(proof.batch)\n  };\n}\n\nexports.compress = compress;\n\nfunction decompress(proof) {\n  if (!proof.compressed) {\n    return proof;\n  }\n\n  return {\n    batch: decompress_batch(proof.compressed)\n  };\n}\n\nexports.decompress = decompress; // tslint:disable:readonly-array\n\nfunction compress_batch(proof) {\n  const centries = [];\n  const lookup = [];\n  const registry = new Map();\n\n  for (const entry of proof.entries) {\n    if (!!entry.exist) {\n      const centry = {\n        exist: compress_exist(entry.exist, lookup, registry)\n      };\n      centries.push(centry);\n    } else if (!!entry.nonexist) {\n      const non = entry.nonexist;\n      const centry = {\n        nonexist: {\n          key: non.key,\n          left: compress_exist(non.left, lookup, registry),\n          right: compress_exist(non.right, lookup, registry)\n        }\n      };\n      centries.push(centry);\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  }\n\n  return {\n    entries: centries,\n    lookupInners: lookup\n  };\n}\n\nfunction compress_exist(exist, lookup, registry) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const path = exist.path.map(inner => {\n    const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n    let idx = registry.get(sig);\n\n    if (idx === undefined) {\n      idx = lookup.length;\n      lookup.push(inner);\n      registry.set(sig, idx);\n    }\n\n    return idx;\n  });\n  return {\n    key: exist.key,\n    value: exist.value,\n    leaf: exist.leaf,\n    path\n  };\n}\n\nfunction decompress_batch(proof) {\n  const lookup = proof.lookupInners;\n  const entries = proof.entries.map(comp => {\n    if (!!comp.exist) {\n      return {\n        exist: decompress_exist(comp.exist, lookup)\n      };\n    } else if (!!comp.nonexist) {\n      const non = comp.nonexist;\n      return {\n        nonexist: {\n          key: non.key,\n          left: decompress_exist(non.left, lookup),\n          right: decompress_exist(non.right, lookup)\n        }\n      };\n    } else {\n      throw new Error(\"Unexpected batch entry during compress\");\n    }\n  });\n  return {\n    entries\n  };\n}\n\nfunction decompress_exist(exist, lookup) {\n  if (!exist) {\n    return undefined;\n  }\n\n  const {\n    key,\n    value,\n    leaf,\n    path\n  } = exist;\n  const newPath = (path || []).map(idx => lookup[idx]);\n  return {\n    key,\n    value,\n    leaf,\n    path: newPath\n  };\n}","map":{"version":3,"sources":["../src/compress.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nfunction compress(proof) {\n    if (!proof.batch) {\n        return proof;\n    }\n    return { compressed: compress_batch(proof.batch) };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n    if (!proof.compressed) {\n        return proof;\n    }\n    return { batch: decompress_batch(proof.compressed) };\n}\nexports.decompress = decompress;\n// tslint:disable:readonly-array\nfunction compress_batch(proof) {\n    const centries = [];\n    const lookup = [];\n    const registry = new Map();\n    for (const entry of proof.entries) {\n        if (!!entry.exist) {\n            const centry = { exist: compress_exist(entry.exist, lookup, registry) };\n            centries.push(centry);\n        }\n        else if (!!entry.nonexist) {\n            const non = entry.nonexist;\n            const centry = {\n                nonexist: {\n                    key: non.key,\n                    left: compress_exist(non.left, lookup, registry),\n                    right: compress_exist(non.right, lookup, registry)\n                }\n            };\n            centries.push(centry);\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    }\n    return {\n        entries: centries,\n        lookupInners: lookup\n    };\n}\nfunction compress_exist(exist, lookup, registry) {\n    if (!exist) {\n        return undefined;\n    }\n    const path = exist.path.map(inner => {\n        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n        let idx = registry.get(sig);\n        if (idx === undefined) {\n            idx = lookup.length;\n            lookup.push(inner);\n            registry.set(sig, idx);\n        }\n        return idx;\n    });\n    return {\n        key: exist.key,\n        value: exist.value,\n        leaf: exist.leaf,\n        path\n    };\n}\nfunction decompress_batch(proof) {\n    const lookup = proof.lookupInners;\n    const entries = proof.entries.map(comp => {\n        if (!!comp.exist) {\n            return { exist: decompress_exist(comp.exist, lookup) };\n        }\n        else if (!!comp.nonexist) {\n            const non = comp.nonexist;\n            return {\n                nonexist: {\n                    key: non.key,\n                    left: decompress_exist(non.left, lookup),\n                    right: decompress_exist(non.right, lookup)\n                }\n            };\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    });\n    return {\n        entries\n    };\n}\nfunction decompress_exist(exist, lookup) {\n    if (!exist) {\n        return undefined;\n    }\n    const { key, value, leaf, path } = exist;\n    const newPath = (path || []).map(idx => lookup[idx]);\n    return { key, value, leaf, path: newPath };\n}\n//# sourceMappingURL=compress.js.map"]},"metadata":{},"sourceType":"script"}