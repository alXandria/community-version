{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupIbcExtension = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst query_1 = require(\"../codec/ibc/applications/transfer/v1/query\");\n\nconst channel_1 = require(\"../codec/ibc/core/channel/v1/channel\");\n\nconst query_2 = require(\"../codec/ibc/core/channel/v1/query\");\n\nconst query_3 = require(\"../codec/ibc/core/client/v1/query\");\n\nconst query_4 = require(\"../codec/ibc/core/connection/v1/query\");\n\nconst tendermint_1 = require(\"../codec/ibc/lightclients/tendermint/v1/tendermint\");\n\nconst utils_1 = require(\"./utils\");\n\nfunction decodeTendermintClientStateAny(clientState) {\n  if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== \"/ibc.lightclients.tendermint.v1.ClientState\") {\n    throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);\n  }\n\n  return tendermint_1.ClientState.decode(clientState.value);\n}\n\nfunction decodeTendermintConsensusStateAny(clientState) {\n  if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== \"/ibc.lightclients.tendermint.v1.ConsensusState\") {\n    throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);\n  }\n\n  return tendermint_1.ConsensusState.decode(clientState.value);\n}\n\nfunction setupIbcExtension(base) {\n  const rpc = utils_1.createProtobufRpcClient(base); // Use these services to get easy typed access to query methods\n  // These cannot be used for proof verification\n\n  const channelQueryService = new query_2.QueryClientImpl(rpc);\n  const clientQueryService = new query_3.QueryClientImpl(rpc);\n  const connectionQueryService = new query_4.QueryClientImpl(rpc);\n  const transferQueryService = new query_1.QueryClientImpl(rpc);\n  return {\n    ibc: {\n      channel: {\n        channel: async (portId, channelId) => channelQueryService.Channel({\n          portId: portId,\n          channelId: channelId\n        }),\n        channels: async paginationKey => channelQueryService.Channels({\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allChannels: async () => {\n          var _a;\n\n          const channels = [];\n          let response;\n          let key;\n\n          do {\n            response = await channelQueryService.Channels({\n              pagination: utils_1.createPagination(key)\n            });\n            channels.push(...response.channels);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            channels: channels,\n            height: response.height\n          };\n        },\n        connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({\n          connection: connection,\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allConnectionChannels: async connection => {\n          var _a;\n\n          const channels = [];\n          let response;\n          let key;\n\n          do {\n            response = await channelQueryService.ConnectionChannels({\n              connection: connection,\n              pagination: utils_1.createPagination(key)\n            });\n            channels.push(...response.channels);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            channels: channels,\n            height: response.height\n          };\n        },\n        clientState: async (portId, channelId) => channelQueryService.ChannelClientState({\n          portId: portId,\n          channelId: channelId\n        }),\n        consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({\n          portId: portId,\n          channelId: channelId,\n          revisionNumber: long_1.default.fromNumber(revisionNumber, true),\n          revisionHeight: long_1.default.fromNumber(revisionHeight, true)\n        }),\n        packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({\n          portId: portId,\n          channelId: channelId,\n          sequence: sequence\n        }),\n        packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({\n          channelId: channelId,\n          portId: portId,\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allPacketCommitments: async (portId, channelId) => {\n          var _a;\n\n          const commitments = [];\n          let response;\n          let key;\n\n          do {\n            response = await channelQueryService.PacketCommitments({\n              channelId: channelId,\n              portId: portId,\n              pagination: utils_1.createPagination(key)\n            });\n            commitments.push(...response.commitments);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            commitments: commitments,\n            height: response.height\n          };\n        },\n        packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({\n          portId: portId,\n          channelId: channelId,\n          sequence: long_1.default.fromNumber(sequence, true)\n        }),\n        packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({\n          portId: portId,\n          channelId: channelId,\n          sequence: long_1.default.fromNumber(sequence, true)\n        }),\n        packetAcknowledgements: async (portId, channelId, paginationKey) => channelQueryService.PacketAcknowledgements({\n          portId: portId,\n          channelId: channelId,\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allPacketAcknowledgements: async (portId, channelId) => {\n          var _a;\n\n          const acknowledgements = [];\n          let response;\n          let key;\n\n          do {\n            response = await channelQueryService.PacketAcknowledgements({\n              channelId: channelId,\n              portId: portId,\n              pagination: utils_1.createPagination(key)\n            });\n            acknowledgements.push(...response.acknowledgements);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            acknowledgements: acknowledgements,\n            height: response.height\n          };\n        },\n        unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({\n          portId: portId,\n          channelId: channelId,\n          packetCommitmentSequences: packetCommitmentSequences.map(s => long_1.default.fromNumber(s, true))\n        }),\n        unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({\n          portId: portId,\n          channelId: channelId,\n          packetAckSequences: packetAckSequences.map(s => long_1.default.fromNumber(s, true))\n        }),\n        nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({\n          portId: portId,\n          channelId: channelId\n        })\n      },\n      client: {\n        state: async clientId => clientQueryService.ClientState({\n          clientId\n        }),\n        states: async paginationKey => clientQueryService.ClientStates({\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allStates: async () => {\n          var _a;\n\n          const clientStates = [];\n          let response;\n          let key;\n\n          do {\n            response = await clientQueryService.ClientStates({\n              pagination: utils_1.createPagination(key)\n            });\n            clientStates.push(...response.clientStates);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            clientStates: clientStates\n          };\n        },\n        consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({\n          clientId: clientId,\n          revisionHeight: consensusHeight !== undefined ? long_1.default.fromNumber(consensusHeight, true) : undefined,\n          latestHeight: consensusHeight === undefined\n        })),\n        consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({\n          clientId: clientId,\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allConsensusStates: async clientId => {\n          var _a;\n\n          const consensusStates = [];\n          let response;\n          let key;\n\n          do {\n            response = await clientQueryService.ConsensusStates({\n              clientId: clientId,\n              pagination: utils_1.createPagination(key)\n            });\n            consensusStates.push(...response.consensusStates);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            consensusStates: consensusStates\n          };\n        },\n        params: async () => clientQueryService.ClientParams({}),\n        stateTm: async clientId => {\n          const response = await clientQueryService.ClientState({\n            clientId\n          });\n          return decodeTendermintClientStateAny(response.clientState);\n        },\n        statesTm: async paginationKey => {\n          const {\n            clientStates\n          } = await clientQueryService.ClientStates({\n            pagination: utils_1.createPagination(paginationKey)\n          });\n          return clientStates.map(({\n            clientState\n          }) => decodeTendermintClientStateAny(clientState));\n        },\n        allStatesTm: async () => {\n          var _a;\n\n          const clientStates = [];\n          let response;\n          let key;\n\n          do {\n            response = await clientQueryService.ClientStates({\n              pagination: utils_1.createPagination(key)\n            });\n            clientStates.push(...response.clientStates);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return clientStates.map(({\n            clientState\n          }) => decodeTendermintClientStateAny(clientState));\n        },\n        consensusStateTm: async (clientId, consensusHeight) => {\n          const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({\n            clientId: clientId,\n            revisionHeight: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionHeight,\n            revisionNumber: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionNumber,\n            latestHeight: consensusHeight === undefined\n          }));\n          return decodeTendermintConsensusStateAny(response.consensusState);\n        }\n      },\n      connection: {\n        connection: async connectionId => connectionQueryService.Connection({\n          connectionId: connectionId\n        }),\n        connections: async paginationKey => connectionQueryService.Connections({\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allConnections: async () => {\n          var _a;\n\n          const connections = [];\n          let response;\n          let key;\n\n          do {\n            response = await connectionQueryService.Connections({\n              pagination: utils_1.createPagination(key)\n            });\n            connections.push(...response.connections);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            connections: connections,\n            height: response.height\n          };\n        },\n        clientConnections: async clientId => connectionQueryService.ClientConnections({\n          clientId: clientId\n        }),\n        clientState: async connectionId => connectionQueryService.ConnectionClientState({\n          connectionId: connectionId\n        }),\n        consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({\n          connectionId: connectionId,\n          revisionHeight: long_1.default.fromNumber(revisionHeight, true)\n        }))\n      },\n      transfer: {\n        denomTrace: async hash => transferQueryService.DenomTrace({\n          hash: hash\n        }),\n        denomTraces: async paginationKey => transferQueryService.DenomTraces({\n          pagination: utils_1.createPagination(paginationKey)\n        }),\n        allDenomTraces: async () => {\n          var _a;\n\n          const denomTraces = [];\n          let response;\n          let key;\n\n          do {\n            response = await transferQueryService.DenomTraces({\n              pagination: utils_1.createPagination(key)\n            });\n            denomTraces.push(...response.denomTraces);\n            key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n          } while (key && key.length);\n\n          return {\n            denomTraces: denomTraces\n          };\n        },\n        params: async () => transferQueryService.Params({})\n      },\n      verified: {\n        channel: {\n          channel: async (portId, channelId) => {\n            // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L55-L65\n            // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L117-L120\n            const key = encoding_1.toAscii(`channelEnds/ports/${portId}/channels/${channelId}`);\n            const responseData = await base.queryVerified(\"ibc\", key);\n            return responseData.length ? channel_1.Channel.decode(responseData) : null;\n          },\n          packetCommitment: async (portId, channelId, sequence) => {\n            // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L128-L133\n            // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L183-L185\n            const key = encoding_1.toAscii(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);\n            const responseData = await base.queryVerified(\"ibc\", key); // keeper code doesn't parse, but returns raw\n\n            return responseData;\n          },\n          packetAcknowledgement: async (portId, channelId, sequence) => {\n            // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L159-L166\n            // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L153-L156\n            const key = encoding_1.toAscii(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);\n            const responseData = await base.queryVerified(\"ibc\", key); // keeper code doesn't parse, but returns raw\n\n            return responseData;\n          },\n          nextSequenceReceive: async (portId, channelId) => {\n            // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L92-L101\n            // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L133-L136\n            const key = encoding_1.toAscii(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);\n            const responseData = await base.queryVerified(\"ibc\", key);\n            return responseData.length ? math_1.Uint64.fromBytes(responseData).toNumber() : null;\n          }\n        }\n      }\n    }\n  };\n}\n\nexports.setupIbcExtension = setupIbcExtension;","map":{"version":3,"sources":["../../src/queries/ibc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupIbcExtension = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst long_1 = __importDefault(require(\"long\"));\nconst query_1 = require(\"../codec/ibc/applications/transfer/v1/query\");\nconst channel_1 = require(\"../codec/ibc/core/channel/v1/channel\");\nconst query_2 = require(\"../codec/ibc/core/channel/v1/query\");\nconst query_3 = require(\"../codec/ibc/core/client/v1/query\");\nconst query_4 = require(\"../codec/ibc/core/connection/v1/query\");\nconst tendermint_1 = require(\"../codec/ibc/lightclients/tendermint/v1/tendermint\");\nconst utils_1 = require(\"./utils\");\nfunction decodeTendermintClientStateAny(clientState) {\n    if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== \"/ibc.lightclients.tendermint.v1.ClientState\") {\n        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);\n    }\n    return tendermint_1.ClientState.decode(clientState.value);\n}\nfunction decodeTendermintConsensusStateAny(clientState) {\n    if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== \"/ibc.lightclients.tendermint.v1.ConsensusState\") {\n        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);\n    }\n    return tendermint_1.ConsensusState.decode(clientState.value);\n}\nfunction setupIbcExtension(base) {\n    const rpc = utils_1.createProtobufRpcClient(base);\n    // Use these services to get easy typed access to query methods\n    // These cannot be used for proof verification\n    const channelQueryService = new query_2.QueryClientImpl(rpc);\n    const clientQueryService = new query_3.QueryClientImpl(rpc);\n    const connectionQueryService = new query_4.QueryClientImpl(rpc);\n    const transferQueryService = new query_1.QueryClientImpl(rpc);\n    return {\n        ibc: {\n            channel: {\n                channel: async (portId, channelId) => channelQueryService.Channel({\n                    portId: portId,\n                    channelId: channelId,\n                }),\n                channels: async (paginationKey) => channelQueryService.Channels({\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allChannels: async () => {\n                    var _a;\n                    const channels = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await channelQueryService.Channels({\n                            pagination: utils_1.createPagination(key),\n                        });\n                        channels.push(...response.channels);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        channels: channels,\n                        height: response.height,\n                    };\n                },\n                connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({\n                    connection: connection,\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allConnectionChannels: async (connection) => {\n                    var _a;\n                    const channels = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await channelQueryService.ConnectionChannels({\n                            connection: connection,\n                            pagination: utils_1.createPagination(key),\n                        });\n                        channels.push(...response.channels);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        channels: channels,\n                        height: response.height,\n                    };\n                },\n                clientState: async (portId, channelId) => channelQueryService.ChannelClientState({\n                    portId: portId,\n                    channelId: channelId,\n                }),\n                consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({\n                    portId: portId,\n                    channelId: channelId,\n                    revisionNumber: long_1.default.fromNumber(revisionNumber, true),\n                    revisionHeight: long_1.default.fromNumber(revisionHeight, true),\n                }),\n                packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({\n                    portId: portId,\n                    channelId: channelId,\n                    sequence: sequence,\n                }),\n                packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({\n                    channelId: channelId,\n                    portId: portId,\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allPacketCommitments: async (portId, channelId) => {\n                    var _a;\n                    const commitments = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await channelQueryService.PacketCommitments({\n                            channelId: channelId,\n                            portId: portId,\n                            pagination: utils_1.createPagination(key),\n                        });\n                        commitments.push(...response.commitments);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        commitments: commitments,\n                        height: response.height,\n                    };\n                },\n                packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({\n                    portId: portId,\n                    channelId: channelId,\n                    sequence: long_1.default.fromNumber(sequence, true),\n                }),\n                packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({\n                    portId: portId,\n                    channelId: channelId,\n                    sequence: long_1.default.fromNumber(sequence, true),\n                }),\n                packetAcknowledgements: async (portId, channelId, paginationKey) => channelQueryService.PacketAcknowledgements({\n                    portId: portId,\n                    channelId: channelId,\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allPacketAcknowledgements: async (portId, channelId) => {\n                    var _a;\n                    const acknowledgements = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await channelQueryService.PacketAcknowledgements({\n                            channelId: channelId,\n                            portId: portId,\n                            pagination: utils_1.createPagination(key),\n                        });\n                        acknowledgements.push(...response.acknowledgements);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        acknowledgements: acknowledgements,\n                        height: response.height,\n                    };\n                },\n                unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({\n                    portId: portId,\n                    channelId: channelId,\n                    packetCommitmentSequences: packetCommitmentSequences.map((s) => long_1.default.fromNumber(s, true)),\n                }),\n                unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({\n                    portId: portId,\n                    channelId: channelId,\n                    packetAckSequences: packetAckSequences.map((s) => long_1.default.fromNumber(s, true)),\n                }),\n                nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({\n                    portId: portId,\n                    channelId: channelId,\n                }),\n            },\n            client: {\n                state: async (clientId) => clientQueryService.ClientState({ clientId }),\n                states: async (paginationKey) => clientQueryService.ClientStates({\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allStates: async () => {\n                    var _a;\n                    const clientStates = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await clientQueryService.ClientStates({\n                            pagination: utils_1.createPagination(key),\n                        });\n                        clientStates.push(...response.clientStates);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        clientStates: clientStates,\n                    };\n                },\n                consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({\n                    clientId: clientId,\n                    revisionHeight: consensusHeight !== undefined ? long_1.default.fromNumber(consensusHeight, true) : undefined,\n                    latestHeight: consensusHeight === undefined,\n                })),\n                consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({\n                    clientId: clientId,\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allConsensusStates: async (clientId) => {\n                    var _a;\n                    const consensusStates = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await clientQueryService.ConsensusStates({\n                            clientId: clientId,\n                            pagination: utils_1.createPagination(key),\n                        });\n                        consensusStates.push(...response.consensusStates);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        consensusStates: consensusStates,\n                    };\n                },\n                params: async () => clientQueryService.ClientParams({}),\n                stateTm: async (clientId) => {\n                    const response = await clientQueryService.ClientState({ clientId });\n                    return decodeTendermintClientStateAny(response.clientState);\n                },\n                statesTm: async (paginationKey) => {\n                    const { clientStates } = await clientQueryService.ClientStates({\n                        pagination: utils_1.createPagination(paginationKey),\n                    });\n                    return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));\n                },\n                allStatesTm: async () => {\n                    var _a;\n                    const clientStates = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await clientQueryService.ClientStates({\n                            pagination: utils_1.createPagination(key),\n                        });\n                        clientStates.push(...response.clientStates);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));\n                },\n                consensusStateTm: async (clientId, consensusHeight) => {\n                    const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({\n                        clientId: clientId,\n                        revisionHeight: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionHeight,\n                        revisionNumber: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionNumber,\n                        latestHeight: consensusHeight === undefined,\n                    }));\n                    return decodeTendermintConsensusStateAny(response.consensusState);\n                },\n            },\n            connection: {\n                connection: async (connectionId) => connectionQueryService.Connection({\n                    connectionId: connectionId,\n                }),\n                connections: async (paginationKey) => connectionQueryService.Connections({\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allConnections: async () => {\n                    var _a;\n                    const connections = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await connectionQueryService.Connections({\n                            pagination: utils_1.createPagination(key),\n                        });\n                        connections.push(...response.connections);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        connections: connections,\n                        height: response.height,\n                    };\n                },\n                clientConnections: async (clientId) => connectionQueryService.ClientConnections({\n                    clientId: clientId,\n                }),\n                clientState: async (connectionId) => connectionQueryService.ConnectionClientState({\n                    connectionId: connectionId,\n                }),\n                consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({\n                    connectionId: connectionId,\n                    revisionHeight: long_1.default.fromNumber(revisionHeight, true),\n                })),\n            },\n            transfer: {\n                denomTrace: async (hash) => transferQueryService.DenomTrace({ hash: hash }),\n                denomTraces: async (paginationKey) => transferQueryService.DenomTraces({\n                    pagination: utils_1.createPagination(paginationKey),\n                }),\n                allDenomTraces: async () => {\n                    var _a;\n                    const denomTraces = [];\n                    let response;\n                    let key;\n                    do {\n                        response = await transferQueryService.DenomTraces({\n                            pagination: utils_1.createPagination(key),\n                        });\n                        denomTraces.push(...response.denomTraces);\n                        key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;\n                    } while (key && key.length);\n                    return {\n                        denomTraces: denomTraces,\n                    };\n                },\n                params: async () => transferQueryService.Params({}),\n            },\n            verified: {\n                channel: {\n                    channel: async (portId, channelId) => {\n                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L55-L65\n                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L117-L120\n                        const key = encoding_1.toAscii(`channelEnds/ports/${portId}/channels/${channelId}`);\n                        const responseData = await base.queryVerified(\"ibc\", key);\n                        return responseData.length ? channel_1.Channel.decode(responseData) : null;\n                    },\n                    packetCommitment: async (portId, channelId, sequence) => {\n                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L128-L133\n                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L183-L185\n                        const key = encoding_1.toAscii(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);\n                        const responseData = await base.queryVerified(\"ibc\", key);\n                        // keeper code doesn't parse, but returns raw\n                        return responseData;\n                    },\n                    packetAcknowledgement: async (portId, channelId, sequence) => {\n                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L159-L166\n                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L153-L156\n                        const key = encoding_1.toAscii(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);\n                        const responseData = await base.queryVerified(\"ibc\", key);\n                        // keeper code doesn't parse, but returns raw\n                        return responseData;\n                    },\n                    nextSequenceReceive: async (portId, channelId) => {\n                        // keeper: https://github.com/cosmos/cosmos-sdk/blob/3bafd8255a502e5a9cee07391cf8261538245dfd/x/ibc/04-channel/keeper/keeper.go#L92-L101\n                        // key: https://github.com/cosmos/cosmos-sdk/blob/ef0a7344af345882729598bc2958a21143930a6b/x/ibc/24-host/keys.go#L133-L136\n                        const key = encoding_1.toAscii(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);\n                        const responseData = await base.queryVerified(\"ibc\", key);\n                        return responseData.length ? math_1.Uint64.fromBytes(responseData).toNumber() : null;\n                    },\n                },\n            },\n        },\n    };\n}\nexports.setupIbcExtension = setupIbcExtension;\n//# sourceMappingURL=ibc.js.map"]},"metadata":{},"sourceType":"script"}