{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\n\nconst ics23_1 = require(\"@confio/ics23\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n  }\n\n  if (!utils_1.arrayContentEquals(key, op.key)) {\n    throw new Error(`Proven key different than queried key.\\nQuery: ${encoding_1.toHex(key)}\\nProven: ${encoding_1.toHex(op.key)}`);\n  }\n\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\n\nclass QueryClient {\n  constructor(tmClient) {\n    this.tmClient = tmClient;\n  }\n\n  static withExtensions(tmClient, ...extensionSetups) {\n    const client = new QueryClient(tmClient);\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n\n    for (const extension of extensions) {\n      utils_1.assert(utils_1.isNonNullObject(extension), `Extension must be a non-null object`);\n\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        utils_1.assert(utils_1.isNonNullObject(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n        const current = client[moduleKey] || {};\n        client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n      }\n    }\n\n    return client;\n  }\n\n  async queryVerified(store, key, desiredHeight) {\n    const {\n      height,\n      proof,\n      value\n    } = await this.queryRawProof(store, key, desiredHeight);\n    const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store)); // this must always be existence, if the store is not a typo\n\n    utils_1.assert(storeProof.exist);\n    utils_1.assert(storeProof.exist.value); // this may be exist or non-exist, depends on response\n\n    if (!value || value.length === 0) {\n      // non-existence check\n      utils_1.assert(subProof.nonexist); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      ics23_1.verifyNonExistence(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n    } else {\n      // existence check\n      utils_1.assert(subProof.exist);\n      utils_1.assert(subProof.exist.value); // the subproof must map the desired key to the \"value\" of the storeProof\n\n      ics23_1.verifyExistence(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n    } // the store proof must map its declared value (root of subProof) to the appHash of the next block\n\n\n    const header = await this.getNextHeader(height);\n    ics23_1.verifyExistence(storeProof.exist, ics23_1.tendermintSpec, header.appHash, encoding_1.toAscii(store), storeProof.exist.value);\n    return value;\n  }\n\n  async queryRawProof(store, queryKey, desiredHeight) {\n    var _a;\n\n    const {\n      key,\n      value,\n      height,\n      proof,\n      code,\n      log\n    } = await this.tmClient.abciQuery({\n      // we need the StoreKey for the module, not the module name\n      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n      path: `/store/${store}/key`,\n      data: queryKey,\n      prove: true,\n      height: desiredHeight\n    });\n\n    if (code) {\n      throw new Error(`Query failed with (${code}): ${log}`);\n    }\n\n    if (!utils_1.arrayContentEquals(queryKey, key)) {\n      throw new Error(`Response key ${encoding_1.toHex(key)} doesn't match query key ${encoding_1.toHex(queryKey)}`);\n    }\n\n    if (!height) {\n      throw new Error(\"No query height returned\");\n    }\n\n    if (!proof || proof.ops.length !== 2) {\n      throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n    } // we don't need the results, but we can ensure the data is the proper format\n\n\n    checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store));\n    return {\n      key: key,\n      value: value,\n      height: height,\n      // need to clone this: readonly input / writeable output\n      proof: {\n        ops: [...proof.ops]\n      }\n    };\n  }\n\n  async queryUnverified(path, request) {\n    const response = await this.tmClient.abciQuery({\n      path: path,\n      data: request,\n      prove: false\n    });\n\n    if (response.code) {\n      throw new Error(`Query failed with (${response.code}): ${response.log}`);\n    }\n\n    return response.value;\n  } // this must return the header for height+1\n  // throws an error if height is 0 or undefined\n\n\n  async getNextHeader(height) {\n    utils_1.assertDefined(height);\n\n    if (height === 0) {\n      throw new Error(\"Query returned height 0, cannot prove it\");\n    }\n\n    const searchHeight = height + 1;\n    let nextHeader;\n    let headersSubscription;\n\n    try {\n      headersSubscription = this.tmClient.subscribeNewBlockHeader();\n    } catch (_a) {// Ignore exception caused by non-WebSocket Tendermint clients\n    }\n\n    if (headersSubscription) {\n      const firstHeader = await stream_1.firstEvent(headersSubscription); // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n\n      if (firstHeader.height === searchHeight) {\n        nextHeader = firstHeader;\n      }\n    }\n\n    while (!nextHeader) {\n      // start from current height to avoid backend error for minHeight in the future\n      const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map(meta => meta.header).find(h => h.height === searchHeight);\n\n      if (correctHeader) {\n        nextHeader = correctHeader;\n      } else {\n        await utils_1.sleep(1000);\n      }\n    }\n\n    utils_1.assert(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n    return nextHeader;\n  }\n\n}\n\nexports.QueryClient = QueryClient;","map":{"version":3,"sources":["../../src/queries/queryclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nconst ics23_1 = require(\"@confio/ics23\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n    if (op.type !== kind) {\n        throw new Error(`Op expected to be ${kind}, got \"${op.type}`);\n    }\n    if (!utils_1.arrayContentEquals(key, op.key)) {\n        throw new Error(`Proven key different than queried key.\\nQuery: ${encoding_1.toHex(key)}\\nProven: ${encoding_1.toHex(op.key)}`);\n    }\n    return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nclass QueryClient {\n    constructor(tmClient) {\n        this.tmClient = tmClient;\n    }\n    static withExtensions(tmClient, ...extensionSetups) {\n        const client = new QueryClient(tmClient);\n        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));\n        for (const extension of extensions) {\n            utils_1.assert(utils_1.isNonNullObject(extension), `Extension must be a non-null object`);\n            for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n                utils_1.assert(utils_1.isNonNullObject(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module \"${moduleKey}\".`);\n                const current = client[moduleKey] || {};\n                client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n            }\n        }\n        return client;\n    }\n    async queryVerified(store, key, desiredHeight) {\n        const { height, proof, value } = await this.queryRawProof(store, key, desiredHeight);\n        const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store));\n        // this must always be existence, if the store is not a typo\n        utils_1.assert(storeProof.exist);\n        utils_1.assert(storeProof.exist.value);\n        // this may be exist or non-exist, depends on response\n        if (!value || value.length === 0) {\n            // non-existence check\n            utils_1.assert(subProof.nonexist);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            ics23_1.verifyNonExistence(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n        }\n        else {\n            // existence check\n            utils_1.assert(subProof.exist);\n            utils_1.assert(subProof.exist.value);\n            // the subproof must map the desired key to the \"value\" of the storeProof\n            ics23_1.verifyExistence(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n        }\n        // the store proof must map its declared value (root of subProof) to the appHash of the next block\n        const header = await this.getNextHeader(height);\n        ics23_1.verifyExistence(storeProof.exist, ics23_1.tendermintSpec, header.appHash, encoding_1.toAscii(store), storeProof.exist.value);\n        return value;\n    }\n    async queryRawProof(store, queryKey, desiredHeight) {\n        var _a;\n        const { key, value, height, proof, code, log } = await this.tmClient.abciQuery({\n            // we need the StoreKey for the module, not the module name\n            // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n            path: `/store/${store}/key`,\n            data: queryKey,\n            prove: true,\n            height: desiredHeight,\n        });\n        if (code) {\n            throw new Error(`Query failed with (${code}): ${log}`);\n        }\n        if (!utils_1.arrayContentEquals(queryKey, key)) {\n            throw new Error(`Response key ${encoding_1.toHex(key)} doesn't match query key ${encoding_1.toHex(queryKey)}`);\n        }\n        if (!height) {\n            throw new Error(\"No query height returned\");\n        }\n        if (!proof || proof.ops.length !== 2) {\n            throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);\n        }\n        // we don't need the results, but we can ensure the data is the proper format\n        checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n        checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store));\n        return {\n            key: key,\n            value: value,\n            height: height,\n            // need to clone this: readonly input / writeable output\n            proof: {\n                ops: [...proof.ops],\n            },\n        };\n    }\n    async queryUnverified(path, request) {\n        const response = await this.tmClient.abciQuery({\n            path: path,\n            data: request,\n            prove: false,\n        });\n        if (response.code) {\n            throw new Error(`Query failed with (${response.code}): ${response.log}`);\n        }\n        return response.value;\n    }\n    // this must return the header for height+1\n    // throws an error if height is 0 or undefined\n    async getNextHeader(height) {\n        utils_1.assertDefined(height);\n        if (height === 0) {\n            throw new Error(\"Query returned height 0, cannot prove it\");\n        }\n        const searchHeight = height + 1;\n        let nextHeader;\n        let headersSubscription;\n        try {\n            headersSubscription = this.tmClient.subscribeNewBlockHeader();\n        }\n        catch (_a) {\n            // Ignore exception caused by non-WebSocket Tendermint clients\n        }\n        if (headersSubscription) {\n            const firstHeader = await stream_1.firstEvent(headersSubscription);\n            // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n            if (firstHeader.height === searchHeight) {\n                nextHeader = firstHeader;\n            }\n        }\n        while (!nextHeader) {\n            // start from current height to avoid backend error for minHeight in the future\n            const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas\n                .map((meta) => meta.header)\n                .find((h) => h.height === searchHeight);\n            if (correctHeader) {\n                nextHeader = correctHeader;\n            }\n            else {\n                await utils_1.sleep(1000);\n            }\n        }\n        utils_1.assert(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n        return nextHeader;\n    }\n}\nexports.QueryClient = QueryClient;\n//# sourceMappingURL=queryclient.js.map"]},"metadata":{},"sourceType":"script"}