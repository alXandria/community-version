{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;\n\nconst compatibility_1 = require(\"./compatibility\");\n/**\n * Extracts ID field from request or response object.\n *\n * Returns `null` when no valid ID was found.\n */\n\n\nfunction parseJsonRpcId(data) {\n  if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n\n  const id = data.id;\n\n  if (typeof id !== \"number\" && typeof id !== \"string\") {\n    return null;\n  }\n\n  return id;\n}\n\nexports.parseJsonRpcId = parseJsonRpcId;\n\nfunction parseJsonRpcRequest(data) {\n  if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);\n  }\n\n  const id = parseJsonRpcId(data);\n\n  if (id === null) {\n    throw new Error(\"Invalid id field\");\n  }\n\n  const method = data.method;\n\n  if (typeof method !== \"string\") {\n    throw new Error(\"Invalid method field\");\n  }\n\n  if (!compatibility_1.isJsonCompatibleArray(data.params) && !compatibility_1.isJsonCompatibleDictionary(data.params)) {\n    throw new Error(\"Invalid params field\");\n  }\n\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    method: method,\n    params: data.params\n  };\n}\n\nexports.parseJsonRpcRequest = parseJsonRpcRequest;\n\nfunction parseError(error) {\n  if (typeof error.code !== \"number\") {\n    throw new Error(\"Error property 'code' is not a number\");\n  }\n\n  if (typeof error.message !== \"string\") {\n    throw new Error(\"Error property 'message' is not a string\");\n  }\n\n  let maybeUndefinedData;\n\n  if (error.data === undefined) {\n    maybeUndefinedData = undefined;\n  } else if (compatibility_1.isJsonCompatibleValue(error.data)) {\n    maybeUndefinedData = error.data;\n  } else {\n    throw new Error(\"Error property 'data' is defined but not a JSON compatible value.\");\n  }\n\n  return Object.assign({\n    code: error.code,\n    message: error.message\n  }, maybeUndefinedData !== undefined ? {\n    data: maybeUndefinedData\n  } : {});\n}\n/** Throws if data is not a JsonRpcErrorResponse */\n\n\nfunction parseJsonRpcErrorResponse(data) {\n  if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n  }\n\n  const id = data.id;\n\n  if (typeof id !== \"number\" && typeof id !== \"string\" && id !== null) {\n    throw new Error(\"Invalid id field\");\n  }\n\n  if (typeof data.error === \"undefined\" || !compatibility_1.isJsonCompatibleDictionary(data.error)) {\n    throw new Error(\"Invalid error field\");\n  }\n\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    error: parseError(data.error)\n  };\n}\n\nexports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;\n/** Throws if data is not a JsonRpcSuccessResponse */\n\nfunction parseJsonRpcSuccessResponse(data) {\n  if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n    throw new Error(\"Data must be JSON compatible dictionary\");\n  }\n\n  if (data.jsonrpc !== \"2.0\") {\n    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n  }\n\n  const id = data.id;\n\n  if (typeof id !== \"number\" && typeof id !== \"string\") {\n    throw new Error(\"Invalid id field\");\n  }\n\n  if (typeof data.result === \"undefined\") {\n    throw new Error(\"Invalid result field\");\n  }\n\n  const result = data.result;\n  return {\n    jsonrpc: \"2.0\",\n    id: id,\n    result: result\n  };\n}\n\nexports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;\n/**\n * Returns a JsonRpcErrorResponse if input can be parsed as a JSON-RPC error. Otherwise parses\n * input as JsonRpcSuccessResponse. Throws if input is neither a valid error nor success response.\n */\n\nfunction parseJsonRpcResponse(data) {\n  let response;\n\n  try {\n    response = parseJsonRpcErrorResponse(data);\n  } catch (_) {\n    response = parseJsonRpcSuccessResponse(data);\n  }\n\n  return response;\n}\n\nexports.parseJsonRpcResponse = parseJsonRpcResponse;","map":{"version":3,"sources":["../src/parse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;\nconst compatibility_1 = require(\"./compatibility\");\n/**\n * Extracts ID field from request or response object.\n *\n * Returns `null` when no valid ID was found.\n */\nfunction parseJsonRpcId(data) {\n    if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\") {\n        return null;\n    }\n    return id;\n}\nexports.parseJsonRpcId = parseJsonRpcId;\nfunction parseJsonRpcRequest(data) {\n    if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);\n    }\n    const id = parseJsonRpcId(data);\n    if (id === null) {\n        throw new Error(\"Invalid id field\");\n    }\n    const method = data.method;\n    if (typeof method !== \"string\") {\n        throw new Error(\"Invalid method field\");\n    }\n    if (!compatibility_1.isJsonCompatibleArray(data.params) && !compatibility_1.isJsonCompatibleDictionary(data.params)) {\n        throw new Error(\"Invalid params field\");\n    }\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        method: method,\n        params: data.params,\n    };\n}\nexports.parseJsonRpcRequest = parseJsonRpcRequest;\nfunction parseError(error) {\n    if (typeof error.code !== \"number\") {\n        throw new Error(\"Error property 'code' is not a number\");\n    }\n    if (typeof error.message !== \"string\") {\n        throw new Error(\"Error property 'message' is not a string\");\n    }\n    let maybeUndefinedData;\n    if (error.data === undefined) {\n        maybeUndefinedData = undefined;\n    }\n    else if (compatibility_1.isJsonCompatibleValue(error.data)) {\n        maybeUndefinedData = error.data;\n    }\n    else {\n        throw new Error(\"Error property 'data' is defined but not a JSON compatible value.\");\n    }\n    return Object.assign({ code: error.code, message: error.message }, (maybeUndefinedData !== undefined ? { data: maybeUndefinedData } : {}));\n}\n/** Throws if data is not a JsonRpcErrorResponse */\nfunction parseJsonRpcErrorResponse(data) {\n    if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\" && id !== null) {\n        throw new Error(\"Invalid id field\");\n    }\n    if (typeof data.error === \"undefined\" || !compatibility_1.isJsonCompatibleDictionary(data.error)) {\n        throw new Error(\"Invalid error field\");\n    }\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        error: parseError(data.error),\n    };\n}\nexports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;\n/** Throws if data is not a JsonRpcSuccessResponse */\nfunction parseJsonRpcSuccessResponse(data) {\n    if (!compatibility_1.isJsonCompatibleDictionary(data)) {\n        throw new Error(\"Data must be JSON compatible dictionary\");\n    }\n    if (data.jsonrpc !== \"2.0\") {\n        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);\n    }\n    const id = data.id;\n    if (typeof id !== \"number\" && typeof id !== \"string\") {\n        throw new Error(\"Invalid id field\");\n    }\n    if (typeof data.result === \"undefined\") {\n        throw new Error(\"Invalid result field\");\n    }\n    const result = data.result;\n    return {\n        jsonrpc: \"2.0\",\n        id: id,\n        result: result,\n    };\n}\nexports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;\n/**\n * Returns a JsonRpcErrorResponse if input can be parsed as a JSON-RPC error. Otherwise parses\n * input as JsonRpcSuccessResponse. Throws if input is neither a valid error nor success response.\n */\nfunction parseJsonRpcResponse(data) {\n    let response;\n    try {\n        response = parseJsonRpcErrorResponse(data);\n    }\n    catch (_) {\n        response = parseJsonRpcSuccessResponse(data);\n    }\n    return response;\n}\nexports.parseJsonRpcResponse = parseJsonRpcResponse;\n//# sourceMappingURL=parse.js.map"]},"metadata":{},"sourceType":"script"}