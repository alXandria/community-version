{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;\n/* eslint-disable */\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nconst commitment_1 = require(\"../../../../ibc/core/commitment/v1/commitment\");\n\nexports.protobufPackage = \"ibc.core.connection.v1\";\n/**\n * State defines if a connection is in one of the following states:\n * INIT, TRYOPEN, OPEN or UNINITIALIZED.\n */\n\nvar State;\n\n(function (State) {\n  /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */\n  State[State[\"STATE_UNINITIALIZED_UNSPECIFIED\"] = 0] = \"STATE_UNINITIALIZED_UNSPECIFIED\";\n  /** STATE_INIT - A connection end has just started the opening handshake. */\n\n  State[State[\"STATE_INIT\"] = 1] = \"STATE_INIT\";\n  /**\n   * STATE_TRYOPEN - A connection end has acknowledged the handshake step on the counterparty\n   * chain.\n   */\n\n  State[State[\"STATE_TRYOPEN\"] = 2] = \"STATE_TRYOPEN\";\n  /** STATE_OPEN - A connection end has completed the handshake. */\n\n  State[State[\"STATE_OPEN\"] = 3] = \"STATE_OPEN\";\n  State[State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(State = exports.State || (exports.State = {}));\n\nfunction stateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"STATE_UNINITIALIZED_UNSPECIFIED\":\n      return State.STATE_UNINITIALIZED_UNSPECIFIED;\n\n    case 1:\n    case \"STATE_INIT\":\n      return State.STATE_INIT;\n\n    case 2:\n    case \"STATE_TRYOPEN\":\n      return State.STATE_TRYOPEN;\n\n    case 3:\n    case \"STATE_OPEN\":\n      return State.STATE_OPEN;\n\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return State.UNRECOGNIZED;\n  }\n}\n\nexports.stateFromJSON = stateFromJSON;\n\nfunction stateToJSON(object) {\n  switch (object) {\n    case State.STATE_UNINITIALIZED_UNSPECIFIED:\n      return \"STATE_UNINITIALIZED_UNSPECIFIED\";\n\n    case State.STATE_INIT:\n      return \"STATE_INIT\";\n\n    case State.STATE_TRYOPEN:\n      return \"STATE_TRYOPEN\";\n\n    case State.STATE_OPEN:\n      return \"STATE_OPEN\";\n\n    default:\n      return \"UNKNOWN\";\n  }\n}\n\nexports.stateToJSON = stateToJSON;\nconst baseConnectionEnd = {\n  clientId: \"\",\n  state: 0,\n  delayPeriod: long_1.default.UZERO\n};\nexports.ConnectionEnd = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    for (const v of message.versions) {\n      exports.Version.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.state !== 0) {\n      writer.uint32(24).int32(message.state);\n    }\n\n    if (message.counterparty !== undefined) {\n      exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(40).uint64(message.delayPeriod);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.versions.push(exports.Version.decode(reader, reader.uint32()));\n          break;\n\n        case 3:\n          message.state = reader.int32();\n          break;\n\n        case 4:\n          message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromJSON(e));\n      }\n    }\n\n    if (object.state !== undefined && object.state !== null) {\n      message.state = stateFromJSON(object.state);\n    } else {\n      message.state = 0;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? exports.Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromPartial(e));\n      }\n    }\n\n    if (object.state !== undefined && object.state !== null) {\n      message.state = object.state;\n    } else {\n      message.state = 0;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    return message;\n  }\n\n};\nconst baseIdentifiedConnection = {\n  id: \"\",\n  clientId: \"\",\n  state: 0,\n  delayPeriod: long_1.default.UZERO\n};\nexports.IdentifiedConnection = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n\n    if (message.clientId !== \"\") {\n      writer.uint32(18).string(message.clientId);\n    }\n\n    for (const v of message.versions) {\n      exports.Version.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.state !== 0) {\n      writer.uint32(32).int32(message.state);\n    }\n\n    if (message.counterparty !== undefined) {\n      exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();\n    }\n\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(48).uint64(message.delayPeriod);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n\n        case 2:\n          message.clientId = reader.string();\n          break;\n\n        case 3:\n          message.versions.push(exports.Version.decode(reader, reader.uint32()));\n          break;\n\n        case 4:\n          message.state = reader.int32();\n          break;\n\n        case 5:\n          message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.delayPeriod = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n\n    if (object.id !== undefined && object.id !== null) {\n      message.id = String(object.id);\n    } else {\n      message.id = \"\";\n    }\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromJSON(e));\n      }\n    }\n\n    if (object.state !== undefined && object.state !== null) {\n      message.state = stateFromJSON(object.state);\n    } else {\n      message.state = 0;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.id !== undefined && (obj.id = message.id);\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? exports.Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n\n    if (object.id !== undefined && object.id !== null) {\n      message.id = object.id;\n    } else {\n      message.id = \"\";\n    }\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromPartial(e));\n      }\n    }\n\n    if (object.state !== undefined && object.state !== null) {\n      message.state = object.state;\n    } else {\n      message.state = 0;\n    }\n\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n\n    return message;\n  }\n\n};\nconst baseCounterparty = {\n  clientId: \"\",\n  connectionId: \"\"\n};\nexports.Counterparty = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    if (message.connectionId !== \"\") {\n      writer.uint32(18).string(message.connectionId);\n    }\n\n    if (message.prefix !== undefined) {\n      commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCounterparty);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.connectionId = reader.string();\n          break;\n\n        case 3:\n          message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseCounterparty);\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);\n    } else {\n      message.prefix = undefined;\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.prefix !== undefined && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : undefined);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseCounterparty);\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = object.connectionId;\n    } else {\n      message.connectionId = \"\";\n    }\n\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);\n    } else {\n      message.prefix = undefined;\n    }\n\n    return message;\n  }\n\n};\nconst baseClientPaths = {\n  paths: \"\"\n};\nexports.ClientPaths = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.paths) {\n      writer.uint32(10).string(v);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.paths.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(String(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(e);\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseConnectionPaths = {\n  clientId: \"\",\n  paths: \"\"\n};\nexports.ConnectionPaths = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n\n    for (const v of message.paths) {\n      writer.uint32(18).string(v);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n\n        case 2:\n          message.paths.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(String(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(e);\n      }\n    }\n\n    return message;\n  }\n\n};\nconst baseVersion = {\n  identifier: \"\",\n  features: \"\"\n};\nexports.Version = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.identifier !== \"\") {\n      writer.uint32(10).string(message.identifier);\n    }\n\n    for (const v of message.features) {\n      writer.uint32(18).string(v);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.identifier = reader.string();\n          break;\n\n        case 2:\n          message.features.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n\n    if (object.identifier !== undefined && object.identifier !== null) {\n      message.identifier = String(object.identifier);\n    } else {\n      message.identifier = \"\";\n    }\n\n    if (object.features !== undefined && object.features !== null) {\n      for (const e of object.features) {\n        message.features.push(String(e));\n      }\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.identifier !== undefined && (obj.identifier = message.identifier);\n\n    if (message.features) {\n      obj.features = message.features.map(e => e);\n    } else {\n      obj.features = [];\n    }\n\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n\n    if (object.identifier !== undefined && object.identifier !== null) {\n      message.identifier = object.identifier;\n    } else {\n      message.identifier = \"\";\n    }\n\n    if (object.features !== undefined && object.features !== null) {\n      for (const e of object.features) {\n        message.features.push(e);\n      }\n    }\n\n    return message;\n  }\n\n};\n\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../../../../src/codec/ibc/core/connection/v1/connection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst commitment_1 = require(\"../../../../ibc/core/commitment/v1/commitment\");\nexports.protobufPackage = \"ibc.core.connection.v1\";\n/**\n * State defines if a connection is in one of the following states:\n * INIT, TRYOPEN, OPEN or UNINITIALIZED.\n */\nvar State;\n(function (State) {\n    /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */\n    State[State[\"STATE_UNINITIALIZED_UNSPECIFIED\"] = 0] = \"STATE_UNINITIALIZED_UNSPECIFIED\";\n    /** STATE_INIT - A connection end has just started the opening handshake. */\n    State[State[\"STATE_INIT\"] = 1] = \"STATE_INIT\";\n    /**\n     * STATE_TRYOPEN - A connection end has acknowledged the handshake step on the counterparty\n     * chain.\n     */\n    State[State[\"STATE_TRYOPEN\"] = 2] = \"STATE_TRYOPEN\";\n    /** STATE_OPEN - A connection end has completed the handshake. */\n    State[State[\"STATE_OPEN\"] = 3] = \"STATE_OPEN\";\n    State[State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(State = exports.State || (exports.State = {}));\nfunction stateFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"STATE_UNINITIALIZED_UNSPECIFIED\":\n            return State.STATE_UNINITIALIZED_UNSPECIFIED;\n        case 1:\n        case \"STATE_INIT\":\n            return State.STATE_INIT;\n        case 2:\n        case \"STATE_TRYOPEN\":\n            return State.STATE_TRYOPEN;\n        case 3:\n        case \"STATE_OPEN\":\n            return State.STATE_OPEN;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return State.UNRECOGNIZED;\n    }\n}\nexports.stateFromJSON = stateFromJSON;\nfunction stateToJSON(object) {\n    switch (object) {\n        case State.STATE_UNINITIALIZED_UNSPECIFIED:\n            return \"STATE_UNINITIALIZED_UNSPECIFIED\";\n        case State.STATE_INIT:\n            return \"STATE_INIT\";\n        case State.STATE_TRYOPEN:\n            return \"STATE_TRYOPEN\";\n        case State.STATE_OPEN:\n            return \"STATE_OPEN\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.stateToJSON = stateToJSON;\nconst baseConnectionEnd = { clientId: \"\", state: 0, delayPeriod: long_1.default.UZERO };\nexports.ConnectionEnd = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        for (const v of message.versions) {\n            exports.Version.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.state !== 0) {\n            writer.uint32(24).int32(message.state);\n        }\n        if (message.counterparty !== undefined) {\n            exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n        }\n        if (!message.delayPeriod.isZero()) {\n            writer.uint32(40).uint64(message.delayPeriod);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseConnectionEnd);\n        message.versions = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.versions.push(exports.Version.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.state = reader.int32();\n                    break;\n                case 4:\n                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.delayPeriod = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseConnectionEnd);\n        message.versions = [];\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.versions !== undefined && object.versions !== null) {\n            for (const e of object.versions) {\n                message.versions.push(exports.Version.fromJSON(e));\n            }\n        }\n        if (object.state !== undefined && object.state !== null) {\n            message.state = stateFromJSON(object.state);\n        }\n        else {\n            message.state = 0;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        if (message.versions) {\n            obj.versions = message.versions.map((e) => (e ? exports.Version.toJSON(e) : undefined));\n        }\n        else {\n            obj.versions = [];\n        }\n        message.state !== undefined && (obj.state = stateToJSON(message.state));\n        message.counterparty !== undefined &&\n            (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseConnectionEnd);\n        message.versions = [];\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.versions !== undefined && object.versions !== null) {\n            for (const e of object.versions) {\n                message.versions.push(exports.Version.fromPartial(e));\n            }\n        }\n        if (object.state !== undefined && object.state !== null) {\n            message.state = object.state;\n        }\n        else {\n            message.state = 0;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = object.delayPeriod;\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        return message;\n    },\n};\nconst baseIdentifiedConnection = { id: \"\", clientId: \"\", state: 0, delayPeriod: long_1.default.UZERO };\nexports.IdentifiedConnection = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.clientId !== \"\") {\n            writer.uint32(18).string(message.clientId);\n        }\n        for (const v of message.versions) {\n            exports.Version.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.state !== 0) {\n            writer.uint32(32).int32(message.state);\n        }\n        if (message.counterparty !== undefined) {\n            exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();\n        }\n        if (!message.delayPeriod.isZero()) {\n            writer.uint32(48).uint64(message.delayPeriod);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseIdentifiedConnection);\n        message.versions = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.clientId = reader.string();\n                    break;\n                case 3:\n                    message.versions.push(exports.Version.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.state = reader.int32();\n                    break;\n                case 5:\n                    message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.delayPeriod = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseIdentifiedConnection);\n        message.versions = [];\n        if (object.id !== undefined && object.id !== null) {\n            message.id = String(object.id);\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.versions !== undefined && object.versions !== null) {\n            for (const e of object.versions) {\n                message.versions.push(exports.Version.fromJSON(e));\n            }\n        }\n        if (object.state !== undefined && object.state !== null) {\n            message.state = stateFromJSON(object.state);\n        }\n        else {\n            message.state = 0;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        if (message.versions) {\n            obj.versions = message.versions.map((e) => (e ? exports.Version.toJSON(e) : undefined));\n        }\n        else {\n            obj.versions = [];\n        }\n        message.state !== undefined && (obj.state = stateToJSON(message.state));\n        message.counterparty !== undefined &&\n            (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n        message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseIdentifiedConnection);\n        message.versions = [];\n        if (object.id !== undefined && object.id !== null) {\n            message.id = object.id;\n        }\n        else {\n            message.id = \"\";\n        }\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.versions !== undefined && object.versions !== null) {\n            for (const e of object.versions) {\n                message.versions.push(exports.Version.fromPartial(e));\n            }\n        }\n        if (object.state !== undefined && object.state !== null) {\n            message.state = object.state;\n        }\n        else {\n            message.state = 0;\n        }\n        if (object.counterparty !== undefined && object.counterparty !== null) {\n            message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n        }\n        else {\n            message.counterparty = undefined;\n        }\n        if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n            message.delayPeriod = object.delayPeriod;\n        }\n        else {\n            message.delayPeriod = long_1.default.UZERO;\n        }\n        return message;\n    },\n};\nconst baseCounterparty = { clientId: \"\", connectionId: \"\" };\nexports.Counterparty = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        if (message.connectionId !== \"\") {\n            writer.uint32(18).string(message.connectionId);\n        }\n        if (message.prefix !== undefined) {\n            commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseCounterparty);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.connectionId = reader.string();\n                    break;\n                case 3:\n                    message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseCounterparty);\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = String(object.connectionId);\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);\n        }\n        else {\n            message.prefix = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n        message.prefix !== undefined &&\n            (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseCounterparty);\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.connectionId !== undefined && object.connectionId !== null) {\n            message.connectionId = object.connectionId;\n        }\n        else {\n            message.connectionId = \"\";\n        }\n        if (object.prefix !== undefined && object.prefix !== null) {\n            message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);\n        }\n        else {\n            message.prefix = undefined;\n        }\n        return message;\n    },\n};\nconst baseClientPaths = { paths: \"\" };\nexports.ClientPaths = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.paths) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseClientPaths);\n        message.paths = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.paths.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseClientPaths);\n        message.paths = [];\n        if (object.paths !== undefined && object.paths !== null) {\n            for (const e of object.paths) {\n                message.paths.push(String(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.paths) {\n            obj.paths = message.paths.map((e) => e);\n        }\n        else {\n            obj.paths = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseClientPaths);\n        message.paths = [];\n        if (object.paths !== undefined && object.paths !== null) {\n            for (const e of object.paths) {\n                message.paths.push(e);\n            }\n        }\n        return message;\n    },\n};\nconst baseConnectionPaths = { clientId: \"\", paths: \"\" };\nexports.ConnectionPaths = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        for (const v of message.paths) {\n            writer.uint32(18).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseConnectionPaths);\n        message.paths = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.paths.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseConnectionPaths);\n        message.paths = [];\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = String(object.clientId);\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.paths !== undefined && object.paths !== null) {\n            for (const e of object.paths) {\n                message.paths.push(String(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        if (message.paths) {\n            obj.paths = message.paths.map((e) => e);\n        }\n        else {\n            obj.paths = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseConnectionPaths);\n        message.paths = [];\n        if (object.clientId !== undefined && object.clientId !== null) {\n            message.clientId = object.clientId;\n        }\n        else {\n            message.clientId = \"\";\n        }\n        if (object.paths !== undefined && object.paths !== null) {\n            for (const e of object.paths) {\n                message.paths.push(e);\n            }\n        }\n        return message;\n    },\n};\nconst baseVersion = { identifier: \"\", features: \"\" };\nexports.Version = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.identifier !== \"\") {\n            writer.uint32(10).string(message.identifier);\n        }\n        for (const v of message.features) {\n            writer.uint32(18).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseVersion);\n        message.features = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.identifier = reader.string();\n                    break;\n                case 2:\n                    message.features.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseVersion);\n        message.features = [];\n        if (object.identifier !== undefined && object.identifier !== null) {\n            message.identifier = String(object.identifier);\n        }\n        else {\n            message.identifier = \"\";\n        }\n        if (object.features !== undefined && object.features !== null) {\n            for (const e of object.features) {\n                message.features.push(String(e));\n            }\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.identifier !== undefined && (obj.identifier = message.identifier);\n        if (message.features) {\n            obj.features = message.features.map((e) => e);\n        }\n        else {\n            obj.features = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseVersion);\n        message.features = [];\n        if (object.identifier !== undefined && object.identifier !== null) {\n            message.identifier = object.identifier;\n        }\n        else {\n            message.identifier = \"\";\n        }\n        if (object.features !== undefined && object.features !== null) {\n            for (const e of object.features) {\n                message.features.push(e);\n            }\n        }\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"script"}