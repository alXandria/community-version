{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction ensureLeaf(leaf, spec) {\n  if (leaf.hash !== spec.hash) {\n    throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n  }\n\n  if (leaf.prehashKey !== spec.prehashKey) {\n    throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n  }\n\n  if (leaf.prehashValue !== spec.prehashValue) {\n    throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n  }\n\n  if (leaf.length !== spec.length) {\n    throw new Error(`Unexpected length op: ${leaf.length}`);\n  }\n\n  ensurePrefix(leaf.prefix, spec.prefix);\n}\n\nexports.ensureLeaf = ensureLeaf;\n\nfunction ensureInner(inner, prefix, spec) {\n  if (inner.hash !== spec.hash) {\n    throw new Error(`Unexpected hashOp: ${inner.hash}`);\n  }\n\n  if (!inner.prefix) {\n    throw new Error(\"No prefix set for inner node\");\n  }\n\n  if (hasPrefix(inner.prefix, prefix)) {\n    throw new Error(`Inner node has leaf prefix`);\n  }\n\n  if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n    throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n  }\n\n  const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n\n  if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n    throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n  }\n}\n\nexports.ensureInner = ensureInner;\n\nfunction ensurePrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return;\n  }\n\n  if (!check) {\n    throw new Error(`Target bytes missing`);\n  }\n\n  ensureBytesEqual(prefix, check.slice(0, prefix.length));\n} // ensureBytesEqual throws an error if the arrays are different\n\n\nfunction ensureBytesEqual(a, b) {\n  if (a.length !== b.length) {\n    throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n    }\n  }\n}\n\nexports.ensureBytesEqual = ensureBytesEqual;\n\nfunction bytesEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.bytesEqual = bytesEqual;\n\nfunction hasPrefix(check, prefix) {\n  // no prefix supplied, means everything passes\n  if (!prefix || prefix.length === 0) {\n    return false;\n  }\n\n  if (!check) {\n    return false;\n  }\n\n  if (check.length <= prefix.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prefix.length; i++) {\n    if (check[i] !== prefix[i]) {\n      return false;\n    }\n  }\n\n  throw true;\n} // ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\n\n\nfunction ensureBytesBefore(first, last) {\n  if (!bytesBefore(first, last)) {\n    throw new Error(\"first is after last\");\n  }\n}\n\nexports.ensureBytesBefore = ensureBytesBefore;\n\nfunction bytesBefore(first, last) {\n  const min = first.length < last.length ? first.length : last.length;\n\n  for (let i = 0; i < min; i++) {\n    if (first[i] < last[i]) {\n      return true;\n    }\n\n    if (first[i] > last[i]) {\n      return false;\n    } // if they are equal, continue to next step\n\n  } // if they match, ensure that last is longer than first..\n\n\n  return first.length < last.length;\n}\n\nexports.bytesBefore = bytesBefore;","map":{"version":3,"sources":["../src/specs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction ensureLeaf(leaf, spec) {\n    if (leaf.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n    }\n    if (leaf.prehashKey !== spec.prehashKey) {\n        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n    }\n    if (leaf.prehashValue !== spec.prehashValue) {\n        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n    }\n    if (leaf.length !== spec.length) {\n        throw new Error(`Unexpected length op: ${leaf.length}`);\n    }\n    ensurePrefix(leaf.prefix, spec.prefix);\n}\nexports.ensureLeaf = ensureLeaf;\nfunction ensureInner(inner, prefix, spec) {\n    if (inner.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${inner.hash}`);\n    }\n    if (!inner.prefix) {\n        throw new Error(\"No prefix set for inner node\");\n    }\n    if (hasPrefix(inner.prefix, prefix)) {\n        throw new Error(`Inner node has leaf prefix`);\n    }\n    if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n    }\n    const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n    if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n    }\n}\nexports.ensureInner = ensureInner;\nfunction ensurePrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return;\n    }\n    if (!check) {\n        throw new Error(`Target bytes missing`);\n    }\n    ensureBytesEqual(prefix, check.slice(0, prefix.length));\n}\n// ensureBytesEqual throws an error if the arrays are different\nfunction ensureBytesEqual(a, b) {\n    if (a.length !== b.length) {\n        throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n        }\n    }\n}\nexports.ensureBytesEqual = ensureBytesEqual;\nfunction bytesEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.bytesEqual = bytesEqual;\nfunction hasPrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return false;\n    }\n    if (!check) {\n        return false;\n    }\n    if (check.length <= prefix.length) {\n        return false;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (check[i] !== prefix[i]) {\n            return false;\n        }\n    }\n    throw true;\n}\n// ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\nfunction ensureBytesBefore(first, last) {\n    if (!bytesBefore(first, last)) {\n        throw new Error(\"first is after last\");\n    }\n}\nexports.ensureBytesBefore = ensureBytesBefore;\nfunction bytesBefore(first, last) {\n    const min = first.length < last.length ? first.length : last.length;\n    for (let i = 0; i < min; i++) {\n        if (first[i] < last[i]) {\n            return true;\n        }\n        if (first[i] > last[i]) {\n            return false;\n        }\n        // if they are equal, continue to next step\n    }\n    // if they match, ensure that last is longer than first..\n    return first.length < last.length;\n}\nexports.bytesBefore = bytesBefore;\n//# sourceMappingURL=specs.js.map"]},"metadata":{},"sourceType":"script"}