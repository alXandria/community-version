{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\n\nconst xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\n\n\nfunction fromListPromise(promise) {\n  const producer = {\n    start: listener => {\n      // the code in `start` runs as soon as anyone listens to the stream\n      promise.then(iterable => {\n        for (const element of iterable) {\n          listener.next(element);\n        }\n\n        listener.complete();\n      }).catch(error => listener.error(error));\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    stop: () => {}\n  };\n  return xstream_1.Stream.create(producer);\n}\n\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\n\nasync function toListPromise(stream, count) {\n  return new Promise((resolve, reject) => {\n    if (count === 0) {\n      resolve([]);\n      return;\n    }\n\n    const events = new Array(); // take() unsubscribes from source stream automatically\n\n    stream.take(count).subscribe({\n      next: event => {\n        events.push(event);\n\n        if (events.length === count) {\n          resolve(events);\n        }\n      },\n      complete: () => {\n        reject(`Stream completed before all events could be collected. ` + `Collected ${events.length}, expected ${count}`);\n      },\n      error: error => reject(error)\n    });\n  });\n}\n\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\n\nasync function firstEvent(stream) {\n  return (await toListPromise(stream, 1))[0];\n}\n\nexports.firstEvent = firstEvent;","map":{"version":3,"sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;AAGA,SAAgB,eAAhB,CAAmC,OAAnC,EAAgE;AAC9D,QAAM,QAAQ,GAAgB;AAC5B,IAAA,KAAK,EAAG,QAAD,IAAa;AAClB;AACA,MAAA,OAAO,CACJ,IADH,CACS,QAAD,IAAa;AACjB,aAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC9B,UAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;AACD;;AACD,QAAA,QAAQ,CAAC,QAAT;AACD,OANH,EAOG,KAPH,CAOU,KAAD,IAAW,QAAQ,CAAC,KAAT,CAAe,KAAf,CAPpB;AAQD,KAX2B;AAY5B;AACA,IAAA,IAAI,EAAE,MAAK,CAAG;AAbc,GAA9B;AAgBA,SAAO,SAAA,CAAA,MAAA,CAAO,MAAP,CAAc,QAAd,CAAP;AACD;;AAlBD,OAAA,CAAA,eAAA,GAAA,eAAA;AAoBA;;;;;;;AAMO,eAAe,aAAf,CAAgC,MAAhC,EAAmD,KAAnD,EAAgE;AACrE,SAAO,IAAI,OAAJ,CAA0B,CAAC,OAAD,EAAU,MAAV,KAAoB;AACnD,QAAI,KAAK,KAAK,CAAd,EAAiB;AACf,MAAA,OAAO,CAAC,EAAD,CAAP;AACA;AACD;;AAED,UAAM,MAAM,GAAG,IAAI,KAAJ,EAAf,CANmD,CAOnD;;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,SAAnB,CAA6B;AAC3B,MAAA,IAAI,EAAG,KAAD,IAAU;AACd,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;;AAEA,YAAI,MAAM,CAAC,MAAP,KAAkB,KAAtB,EAA6B;AAC3B,UAAA,OAAO,CAAC,MAAD,CAAP;AACD;AACF,OAP0B;AAQ3B,MAAA,QAAQ,EAAE,MAAK;AACb,QAAA,MAAM,CACJ,yDAAA,GACE,aAAa,MAAM,CAAC,MAAM,cAAc,KAAK,EAF3C,CAAN;AAID,OAb0B;AAc3B,MAAA,KAAK,EAAG,KAAD,IAAW,MAAM,CAAC,KAAD;AAdG,KAA7B;AAgBD,GAxBM,CAAP;AAyBD;;AA1BD,OAAA,CAAA,aAAA,GAAA,aAAA;AA4BA;;;;;;AAKO,eAAe,UAAf,CAA6B,MAA7B,EAA8C;AACnD,SAAO,CAAC,MAAM,aAAa,CAAC,MAAD,EAAS,CAAT,CAApB,EAAiC,CAAjC,CAAP;AACD;;AAFD,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * Emits one event for each list element as soon as the promise resolves\n */\nfunction fromListPromise(promise) {\n    const producer = {\n        start: (listener) => {\n            // the code in `start` runs as soon as anyone listens to the stream\n            promise\n                .then((iterable) => {\n                for (const element of iterable) {\n                    listener.next(element);\n                }\n                listener.complete();\n            })\n                .catch((error) => listener.error(error));\n        },\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        stop: () => { },\n    };\n    return xstream_1.Stream.create(producer);\n}\nexports.fromListPromise = fromListPromise;\n/**\n * Listens to stream and collects events. When `count` events are collected,\n * the promise resolves with an array of events.\n *\n * Rejects if stream completes before `count` events are collected.\n */\nasync function toListPromise(stream, count) {\n    return new Promise((resolve, reject) => {\n        if (count === 0) {\n            resolve([]);\n            return;\n        }\n        const events = new Array();\n        // take() unsubscribes from source stream automatically\n        stream.take(count).subscribe({\n            next: (event) => {\n                events.push(event);\n                if (events.length === count) {\n                    resolve(events);\n                }\n            },\n            complete: () => {\n                reject(`Stream completed before all events could be collected. ` +\n                    `Collected ${events.length}, expected ${count}`);\n            },\n            error: (error) => reject(error),\n        });\n    });\n}\nexports.toListPromise = toListPromise;\n/**\n * Listens to stream, collects one event and revolves.\n *\n * Rejects if stream completes before one event was fired.\n */\nasync function firstEvent(stream) {\n    return (await toListPromise(stream, 1))[0];\n}\nexports.firstEvent = firstEvent;\n//# sourceMappingURL=promise.js.map"]},"metadata":{},"sourceType":"script"}