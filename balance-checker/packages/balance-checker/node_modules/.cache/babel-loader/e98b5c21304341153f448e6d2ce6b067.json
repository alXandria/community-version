{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\n\nconst tx_1 = require(\"./codec/cosmos/bank/v1beta1/tx\");\n\nconst coin_1 = require(\"./codec/cosmos/base/v1beta1/coin\");\n\nconst tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nconst any_1 = require(\"./codec/google/protobuf/any\");\n\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\n\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\n\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\n\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\n\nfunction isTxBodyEncodeObject(encodeObject) {\n  return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\n\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\n\nclass Registry {\n  constructor(customTypes = []) {\n    const {\n      cosmosCoin,\n      cosmosMsgSend\n    } = defaultTypeUrls;\n    this.types = new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend], ...customTypes]);\n  }\n\n  register(typeUrl, type) {\n    this.types.set(typeUrl, type);\n  }\n  /**\n   * Looks up a type that was previously added to the registry.\n   *\n   * The generator information (ts-proto or pbjs) gets lost along the way.\n   * If you need to work with the result type in TypeScript, you can use:\n   *\n   * ```\n   * import { assert } from \"@cosmjs/utils\";\n   *\n   * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n   * assert(Coin); // Ensures not unset\n   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n   *\n   * // Coin is typed TsProtoGeneratedType now.\n   * ```\n   */\n\n\n  lookupType(typeUrl) {\n    return this.types.get(typeUrl);\n  }\n\n  lookupTypeWithError(typeUrl) {\n    const type = this.lookupType(typeUrl);\n\n    if (!type) {\n      throw new Error(`Unregistered type url: ${typeUrl}`);\n    }\n\n    return type;\n  }\n\n  encode(encodeObject) {\n    const {\n      value,\n      typeUrl\n    } = encodeObject;\n\n    if (isTxBodyEncodeObject(encodeObject)) {\n      return this.encodeTxBody(value);\n    }\n\n    const type = this.lookupTypeWithError(typeUrl);\n    const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n    return type.encode(instance).finish();\n  }\n\n  encodeTxBody(txBodyFields) {\n    const wrappedMessages = txBodyFields.messages.map(message => {\n      const messageBytes = this.encode(message);\n      return any_1.Any.fromPartial({\n        typeUrl: message.typeUrl,\n        value: messageBytes\n      });\n    });\n    const txBody = tx_2.TxBody.fromPartial(Object.assign(Object.assign({}, txBodyFields), {\n      messages: wrappedMessages\n    }));\n    return tx_2.TxBody.encode(txBody).finish();\n  }\n\n  decode({\n    typeUrl,\n    value\n  }) {\n    if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n      return this.decodeTxBody(value);\n    }\n\n    const type = this.lookupTypeWithError(typeUrl);\n    const decoded = type.decode(value);\n    Object.entries(decoded).forEach(([key, val]) => {\n      if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n        decoded[key] = Uint8Array.from(val);\n      }\n    });\n    return decoded;\n  }\n\n  decodeTxBody(txBody) {\n    const decodedTxBody = tx_2.TxBody.decode(txBody);\n    return Object.assign(Object.assign({}, decodedTxBody), {\n      messages: decodedTxBody.messages.map(({\n        typeUrl: typeUrl,\n        value\n      }) => {\n        if (!typeUrl) {\n          throw new Error(\"Missing type_url in Any\");\n        }\n\n        if (!value) {\n          throw new Error(\"Missing value in Any\");\n        }\n\n        return this.decode({\n          typeUrl,\n          value\n        });\n      })\n    });\n  }\n\n}\n\nexports.Registry = Registry;","map":{"version":3,"sources":["../src/registry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\nconst tx_1 = require(\"./codec/cosmos/bank/v1beta1/tx\");\nconst coin_1 = require(\"./codec/cosmos/base/v1beta1/coin\");\nconst tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\nconst any_1 = require(\"./codec/google/protobuf/any\");\nfunction isTsProtoGeneratedType(type) {\n    return typeof type.fromPartial === \"function\";\n}\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\nfunction isPbjsGeneratedType(type) {\n    return !isTsProtoGeneratedType(type);\n}\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nconst defaultTypeUrls = {\n    cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n    cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n    cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n    googleAny: \"/google.protobuf.Any\",\n};\nfunction isTxBodyEncodeObject(encodeObject) {\n    return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\nclass Registry {\n    constructor(customTypes = []) {\n        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;\n        this.types = new Map([\n            [cosmosCoin, coin_1.Coin],\n            [cosmosMsgSend, tx_1.MsgSend],\n            ...customTypes,\n        ]);\n    }\n    register(typeUrl, type) {\n        this.types.set(typeUrl, type);\n    }\n    /**\n     * Looks up a type that was previously added to the registry.\n     *\n     * The generator information (ts-proto or pbjs) gets lost along the way.\n     * If you need to work with the result type in TypeScript, you can use:\n     *\n     * ```\n     * import { assert } from \"@cosmjs/utils\";\n     *\n     * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n     * assert(Coin); // Ensures not unset\n     * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n     *\n     * // Coin is typed TsProtoGeneratedType now.\n     * ```\n     */\n    lookupType(typeUrl) {\n        return this.types.get(typeUrl);\n    }\n    lookupTypeWithError(typeUrl) {\n        const type = this.lookupType(typeUrl);\n        if (!type) {\n            throw new Error(`Unregistered type url: ${typeUrl}`);\n        }\n        return type;\n    }\n    encode(encodeObject) {\n        const { value, typeUrl } = encodeObject;\n        if (isTxBodyEncodeObject(encodeObject)) {\n            return this.encodeTxBody(value);\n        }\n        const type = this.lookupTypeWithError(typeUrl);\n        const instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n        return type.encode(instance).finish();\n    }\n    encodeTxBody(txBodyFields) {\n        const wrappedMessages = txBodyFields.messages.map((message) => {\n            const messageBytes = this.encode(message);\n            return any_1.Any.fromPartial({\n                typeUrl: message.typeUrl,\n                value: messageBytes,\n            });\n        });\n        const txBody = tx_2.TxBody.fromPartial(Object.assign(Object.assign({}, txBodyFields), { messages: wrappedMessages }));\n        return tx_2.TxBody.encode(txBody).finish();\n    }\n    decode({ typeUrl, value }) {\n        if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n            return this.decodeTxBody(value);\n        }\n        const type = this.lookupTypeWithError(typeUrl);\n        const decoded = type.decode(value);\n        Object.entries(decoded).forEach(([key, val]) => {\n            if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n                decoded[key] = Uint8Array.from(val);\n            }\n        });\n        return decoded;\n    }\n    decodeTxBody(txBody) {\n        const decodedTxBody = tx_2.TxBody.decode(txBody);\n        return Object.assign(Object.assign({}, decodedTxBody), { messages: decodedTxBody.messages.map(({ typeUrl: typeUrl, value }) => {\n                if (!typeUrl) {\n                    throw new Error(\"Missing type_url in Any\");\n                }\n                if (!value) {\n                    throw new Error(\"Missing value in Any\");\n                }\n                return this.decode({ typeUrl, value });\n            }) });\n    }\n}\nexports.Registry = Registry;\n//# sourceMappingURL=registry.js.map"]},"metadata":{},"sourceType":"script"}