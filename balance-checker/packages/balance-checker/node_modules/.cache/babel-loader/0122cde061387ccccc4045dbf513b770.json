{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReconnectingSocket = void 0;\n\nconst xstream_1 = require(\"xstream\");\n\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\n\n\nclass ReconnectingSocket {\n  constructor(url, timeout = 10000, reconnectedHandler) {\n    this.unconnected = true;\n    this.disconnected = false;\n    this.timeoutIndex = 0;\n    this.reconnectTimeout = null;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n    this.socket.events.subscribe({\n      next: event => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.next(event);\n        }\n      },\n      error: error => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.error(error);\n        }\n      }\n    });\n    this.connectionStatus = this.socket.connectionStatus;\n    this.connectionStatus.updates.subscribe({\n      next: status => {\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n          this.timeoutIndex = 0;\n        }\n\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n          if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n          }\n\n          this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n        }\n      }\n    });\n  }\n  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n\n\n  static calculateTimeout(index) {\n    return Math.min(2 ** index * 100, 5000);\n  }\n\n  connect() {\n    if (!this.unconnected) {\n      throw new Error(\"Cannot connect: socket has already connected\");\n    }\n\n    this.socket.connect();\n    this.unconnected = false;\n  }\n\n  disconnect() {\n    if (this.unconnected) {\n      throw new Error(\"Cannot disconnect: socket has not yet connected\");\n    }\n\n    this.socket.disconnect();\n\n    if (this.eventProducerListener) {\n      this.eventProducerListener.complete();\n    }\n\n    this.disconnected = true;\n  }\n\n  queueRequest(request) {\n    if (this.disconnected) {\n      throw new Error(\"Cannot queue request: socket has disconnected\");\n    }\n\n    this.socket.queueRequest(request);\n  }\n\n}\n\nexports.ReconnectingSocket = ReconnectingSocket;","map":{"version":3,"sources":["../src/reconnectingsocket.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReconnectingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nclass ReconnectingSocket {\n    constructor(url, timeout = 10000, reconnectedHandler) {\n        this.unconnected = true;\n        this.disconnected = false;\n        this.timeoutIndex = 0;\n        this.reconnectTimeout = null;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.next(event);\n                }\n            },\n            error: (error) => {\n                if (this.eventProducerListener) {\n                    this.eventProducerListener.error(error);\n                }\n            },\n        });\n        this.connectionStatus = this.socket.connectionStatus;\n        this.connectionStatus.updates.subscribe({\n            next: (status) => {\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n                    this.timeoutIndex = 0;\n                }\n                if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n                    if (this.reconnectTimeout) {\n                        clearTimeout(this.reconnectTimeout);\n                        this.reconnectTimeout = null;\n                    }\n                    this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n                }\n            },\n        });\n    }\n    /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n    static calculateTimeout(index) {\n        return Math.min(2 ** index * 100, 5000);\n    }\n    connect() {\n        if (!this.unconnected) {\n            throw new Error(\"Cannot connect: socket has already connected\");\n        }\n        this.socket.connect();\n        this.unconnected = false;\n    }\n    disconnect() {\n        if (this.unconnected) {\n            throw new Error(\"Cannot disconnect: socket has not yet connected\");\n        }\n        this.socket.disconnect();\n        if (this.eventProducerListener) {\n            this.eventProducerListener.complete();\n        }\n        this.disconnected = true;\n    }\n    queueRequest(request) {\n        if (this.disconnected) {\n            throw new Error(\"Cannot queue request: socket has disconnected\");\n        }\n        this.socket.queueRequest(request);\n    }\n}\nexports.ReconnectingSocket = ReconnectingSocket;\n//# sourceMappingURL=reconnectingsocket.js.map"]},"metadata":{},"sourceType":"script"}