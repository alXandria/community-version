{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst compress_1 = require(\"./compress\");\n\nconst proofs_1 = require(\"./proofs\");\n\nconst specs_1 = require(\"./specs\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\n\n\nfunction verifyMembership(proof, spec, root, key, value) {\n  const norm = compress_1.decompress(proof);\n  const exist = getExistForKey(norm, key);\n\n  if (!exist) {\n    return false;\n  }\n\n  try {\n    proofs_1.verifyExistence(exist, spec, root, key, value);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\n\nfunction verifyNonMembership(proof, spec, root, key) {\n  const norm = compress_1.decompress(proof);\n  const nonexist = getNonExistForKey(norm, key);\n\n  if (!nonexist) {\n    return false;\n  }\n\n  try {\n    proofs_1.verifyNonExistence(nonexist, spec, root, key);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\n\nfunction batchVerifyMembership(proof, spec, root, items) {\n  const norm = compress_1.decompress(proof);\n\n  for (const [key, value] of items.entries()) {\n    if (!verifyMembership(norm, spec, root, key, value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\n\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n  const norm = compress_1.decompress(proof);\n\n  for (const key of keys) {\n    if (!verifyNonMembership(norm, spec, root, key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\n\nfunction getExistForKey(proof, key) {\n  const match = p => !!p && specs_1.bytesEqual(key, p.key);\n\n  if (match(proof.exist)) {\n    return proof.exist;\n  } else if (!!proof.batch) {\n    return proof.batch.entries.map(x => x.exist || null).find(match);\n  }\n\n  return undefined;\n}\n\nfunction getNonExistForKey(proof, key) {\n  const match = p => {\n    return !!p && (!p.left || specs_1.bytesBefore(p.left.key, key)) && (!p.right || specs_1.bytesBefore(key, p.right.key));\n  };\n\n  if (match(proof.nonexist)) {\n    return proof.nonexist;\n  } else if (!!proof.batch) {\n    return proof.batch.entries.map(x => x.nonexist || null).find(match);\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["../src/ics23.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst compress_1 = require(\"./compress\");\nconst proofs_1 = require(\"./proofs\");\nconst specs_1 = require(\"./specs\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n    const norm = compress_1.decompress(proof);\n    const exist = getExistForKey(norm, key);\n    if (!exist) {\n        return false;\n    }\n    try {\n        proofs_1.verifyExistence(exist, spec, root, key, value);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n    const norm = compress_1.decompress(proof);\n    const nonexist = getNonExistForKey(norm, key);\n    if (!nonexist) {\n        return false;\n    }\n    try {\n        proofs_1.verifyNonExistence(nonexist, spec, root, key);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n    const norm = compress_1.decompress(proof);\n    for (const [key, value] of items.entries()) {\n        if (!verifyMembership(norm, spec, root, key, value)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n    const norm = compress_1.decompress(proof);\n    for (const key of keys) {\n        if (!verifyNonMembership(norm, spec, root, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n    const match = (p) => !!p && specs_1.bytesEqual(key, p.key);\n    if (match(proof.exist)) {\n        return proof.exist;\n    }\n    else if (!!proof.batch) {\n        return proof.batch.entries.map(x => x.exist || null).find(match);\n    }\n    return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n    const match = (p) => {\n        return (!!p &&\n            (!p.left || specs_1.bytesBefore(p.left.key, key)) &&\n            (!p.right || specs_1.bytesBefore(key, p.right.key)));\n    };\n    if (match(proof.nonexist)) {\n        return proof.nonexist;\n    }\n    else if (!!proof.batch) {\n        return proof.batch.entries.map(x => x.nonexist || null).find(match);\n    }\n    return undefined;\n}\n//# sourceMappingURL=ics23.js.map"]},"metadata":{},"sourceType":"script"}