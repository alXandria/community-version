{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst multisig_1 = require(\"./codec/cosmos/crypto/multisig/v1beta1/multisig\");\n\nconst signing_1 = require(\"./codec/cosmos/tx/signing/v1beta1/signing\");\n\nconst tx_1 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nconst tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nfunction makeCompactBitArray(bits) {\n  const byteCount = Math.ceil(bits.length / 8);\n  const extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n  const bytes = new Uint8Array(byteCount); // zero-filled\n\n  bits.forEach((value, index) => {\n    const bytePos = Math.floor(index / 8);\n    const bitPos = index % 8; // eslint-disable-next-line no-bitwise\n\n    if (value) bytes[bytePos] |= 0b1 << 8 - 1 - bitPos;\n  });\n  return multisig_1.CompactBitArray.fromPartial({\n    elems: bytes,\n    extraBitsStored: extraBits\n  });\n}\n\nexports.makeCompactBitArray = makeCompactBitArray;\n\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n  const addresses = Array.from(signatures.keys());\n  const prefix = encoding_1.Bech32.decode(addresses[0]).prefix;\n  const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n  const signaturesList = new Array();\n\n  for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n    const signerAddress = amino_1.pubkeyToAddress(multisigPubkey.value.pubkeys[i], prefix);\n    const signature = signatures.get(signerAddress);\n\n    if (signature) {\n      signers[i] = true;\n      signaturesList.push(signature);\n    }\n  }\n\n  const signerInfo = {\n    publicKey: proto_signing_1.encodePubkey(multisigPubkey),\n    modeInfo: {\n      multi: {\n        bitarray: makeCompactBitArray(signers),\n        modeInfos: signaturesList.map(_ => ({\n          single: {\n            mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n          }\n        }))\n      }\n    },\n    sequence: long_1.default.fromNumber(sequence)\n  };\n  const authInfo = tx_1.AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee: {\n      amount: [...fee.amount],\n      gasLimit: long_1.default.fromString(fee.gas)\n    }\n  });\n  const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n  const signedTx = tx_2.TxRaw.fromPartial({\n    bodyBytes: bodyBytes,\n    authInfoBytes: authInfoBytes,\n    signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n      signatures: signaturesList\n    })).finish()]\n  });\n  return signedTx;\n}\n\nexports.makeMultisignedTx = makeMultisignedTx;","map":{"version":3,"sources":["../src/multisignature.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst long_1 = __importDefault(require(\"long\"));\nconst multisig_1 = require(\"./codec/cosmos/crypto/multisig/v1beta1/multisig\");\nconst signing_1 = require(\"./codec/cosmos/tx/signing/v1beta1/signing\");\nconst tx_1 = require(\"./codec/cosmos/tx/v1beta1/tx\");\nconst tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\nfunction makeCompactBitArray(bits) {\n    const byteCount = Math.ceil(bits.length / 8);\n    const extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n    const bytes = new Uint8Array(byteCount); // zero-filled\n    bits.forEach((value, index) => {\n        const bytePos = Math.floor(index / 8);\n        const bitPos = index % 8;\n        // eslint-disable-next-line no-bitwise\n        if (value)\n            bytes[bytePos] |= 0b1 << (8 - 1 - bitPos);\n    });\n    return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });\n}\nexports.makeCompactBitArray = makeCompactBitArray;\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n    const addresses = Array.from(signatures.keys());\n    const prefix = encoding_1.Bech32.decode(addresses[0]).prefix;\n    const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n    const signaturesList = new Array();\n    for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n        const signerAddress = amino_1.pubkeyToAddress(multisigPubkey.value.pubkeys[i], prefix);\n        const signature = signatures.get(signerAddress);\n        if (signature) {\n            signers[i] = true;\n            signaturesList.push(signature);\n        }\n    }\n    const signerInfo = {\n        publicKey: proto_signing_1.encodePubkey(multisigPubkey),\n        modeInfo: {\n            multi: {\n                bitarray: makeCompactBitArray(signers),\n                modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } })),\n            },\n        },\n        sequence: long_1.default.fromNumber(sequence),\n    };\n    const authInfo = tx_1.AuthInfo.fromPartial({\n        signerInfos: [signerInfo],\n        fee: {\n            amount: [...fee.amount],\n            gasLimit: long_1.default.fromString(fee.gas),\n        },\n    });\n    const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n    const signedTx = tx_2.TxRaw.fromPartial({\n        bodyBytes: bodyBytes,\n        authInfoBytes: authInfoBytes,\n        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()],\n    });\n    return signedTx;\n}\nexports.makeMultisignedTx = makeMultisignedTx;\n//# sourceMappingURL=multisignature.js.map"]},"metadata":{},"sourceType":"script"}