{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketClient = void 0;\n\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\n\nconst socket_1 = require(\"@cosmjs/socket\");\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst xstream_1 = require(\"xstream\");\n\nconst rpcclient_1 = require(\"./rpcclient\");\n\nfunction defaultErrorHandler(error) {\n  throw error;\n}\n\nfunction toJsonRpcResponse(message) {\n  // this should never happen, but I want an alert if it does\n  if (message.type !== \"message\") {\n    throw new Error(`Unexcepted message type on websocket: ${message.type}`);\n  }\n\n  const jsonRpcEvent = json_rpc_1.parseJsonRpcResponse(JSON.parse(message.data));\n  return jsonRpcEvent;\n}\n\nclass RpcEventProducer {\n  constructor(request, socket) {\n    this.running = false;\n    this.subscriptions = [];\n    this.request = request;\n    this.socket = socket;\n  }\n  /**\n   * Implementation of Producer.start\n   */\n\n\n  start(listener) {\n    if (this.running) {\n      throw Error(\"Already started. Please stop first before restarting.\");\n    }\n\n    this.running = true;\n    this.connectToClient(listener);\n    this.socket.queueRequest(JSON.stringify(this.request));\n  }\n  /**\n   * Implementation of Producer.stop\n   *\n   * Called by the stream when the stream's last listener stopped listening\n   * or when the producer completed.\n   */\n\n\n  stop() {\n    this.running = false; // Tell the server we are done in order to save resources. We cannot wait for the result.\n    // This may fail when socket connection is not open, thus ignore errors in queueRequest\n\n    const endRequest = Object.assign(Object.assign({}, this.request), {\n      method: \"unsubscribe\"\n    });\n\n    try {\n      this.socket.queueRequest(JSON.stringify(endRequest));\n    } catch (error) {\n      if (error instanceof Error && error.message.match(/socket has disconnected/i)) {// ignore\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  connectToClient(listener) {\n    const responseStream = this.socket.events.map(toJsonRpcResponse); // this should unsubscribe itself, so doesn't need to be removed explicitly\n\n    const idSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        }\n\n        idSubscription.unsubscribe();\n      }\n    }); // this will fire on a response (success or error)\n    // Tendermint adds an \"#event\" suffix for events that follow a previous subscription\n    // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107\n\n    const idEventSubscription = responseStream.filter(response => response.id === this.request.id).subscribe({\n      next: response => {\n        if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n          this.closeSubscriptions();\n          listener.error(JSON.stringify(response.error));\n        } else {\n          listener.next(response.result);\n        }\n      }\n    }); // this will fire in case the websocket disconnects cleanly\n\n    const nonResponseSubscription = responseStream.subscribe({\n      error: error => {\n        this.closeSubscriptions();\n        listener.error(error);\n      },\n      complete: () => {\n        this.closeSubscriptions();\n        listener.complete();\n      }\n    });\n    this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);\n  }\n\n  closeSubscriptions() {\n    for (const subscription of this.subscriptions) {\n      subscription.unsubscribe();\n    } // clear unused subscriptions\n\n\n    this.subscriptions = [];\n  }\n\n}\n\nclass WebsocketClient {\n  constructor(baseUrl = \"ws://localhost:46657\", onError = defaultErrorHandler) {\n    // Lazily create streams and use the same stream when listening to the same query twice.\n    //\n    // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this\n    // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!\n    this.subscriptionStreams = new Map(); // accept host.name:port and assume ws protocol\n    // make sure we don't end up with ...//websocket\n\n    const path = baseUrl.endsWith(\"/\") ? \"websocket\" : \"/websocket\";\n    const cleanBaseUrl = rpcclient_1.hasProtocol(baseUrl) ? baseUrl : \"ws://\" + baseUrl;\n    this.url = cleanBaseUrl + path;\n    this.socket = new socket_1.ReconnectingSocket(this.url);\n    const errorSubscription = this.socket.events.subscribe({\n      error: error => {\n        onError(error);\n        errorSubscription.unsubscribe();\n      }\n    });\n    this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);\n    this.socket.connect();\n  }\n\n  async execute(request) {\n    const pendingResponse = this.responseForRequestId(request.id);\n    this.socket.queueRequest(JSON.stringify(request));\n    const response = await pendingResponse;\n\n    if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n      throw new Error(JSON.stringify(response.error));\n    }\n\n    return response;\n  }\n\n  listen(request) {\n    if (request.method !== \"subscribe\") {\n      throw new Error(`Request method must be \"subscribe\" to start event listening`);\n    }\n\n    const query = request.params.query;\n\n    if (typeof query !== \"string\") {\n      throw new Error(\"request.params.query must be a string\");\n    }\n\n    if (!this.subscriptionStreams.has(query)) {\n      const producer = new RpcEventProducer(request, this.socket);\n      const stream = xstream_1.Stream.create(producer);\n      this.subscriptionStreams.set(query, stream);\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return this.subscriptionStreams.get(query).filter(response => response.query !== undefined);\n  }\n  /**\n   * Resolves as soon as websocket is connected. execute() queues requests automatically,\n   * so this should be required for testing purposes only.\n   */\n\n\n  async connected() {\n    await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);\n  }\n\n  disconnect() {\n    this.socket.disconnect();\n  }\n\n  async responseForRequestId(id) {\n    return stream_1.firstEvent(this.jsonRpcResponseStream.filter(r => r.id === id));\n  }\n\n}\n\nexports.WebsocketClient = WebsocketClient;","map":{"version":3,"sources":["../../src/rpcclients/websocketclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebsocketClient = void 0;\nconst json_rpc_1 = require(\"@cosmjs/json-rpc\");\nconst socket_1 = require(\"@cosmjs/socket\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst rpcclient_1 = require(\"./rpcclient\");\nfunction defaultErrorHandler(error) {\n    throw error;\n}\nfunction toJsonRpcResponse(message) {\n    // this should never happen, but I want an alert if it does\n    if (message.type !== \"message\") {\n        throw new Error(`Unexcepted message type on websocket: ${message.type}`);\n    }\n    const jsonRpcEvent = json_rpc_1.parseJsonRpcResponse(JSON.parse(message.data));\n    return jsonRpcEvent;\n}\nclass RpcEventProducer {\n    constructor(request, socket) {\n        this.running = false;\n        this.subscriptions = [];\n        this.request = request;\n        this.socket = socket;\n    }\n    /**\n     * Implementation of Producer.start\n     */\n    start(listener) {\n        if (this.running) {\n            throw Error(\"Already started. Please stop first before restarting.\");\n        }\n        this.running = true;\n        this.connectToClient(listener);\n        this.socket.queueRequest(JSON.stringify(this.request));\n    }\n    /**\n     * Implementation of Producer.stop\n     *\n     * Called by the stream when the stream's last listener stopped listening\n     * or when the producer completed.\n     */\n    stop() {\n        this.running = false;\n        // Tell the server we are done in order to save resources. We cannot wait for the result.\n        // This may fail when socket connection is not open, thus ignore errors in queueRequest\n        const endRequest = Object.assign(Object.assign({}, this.request), { method: \"unsubscribe\" });\n        try {\n            this.socket.queueRequest(JSON.stringify(endRequest));\n        }\n        catch (error) {\n            if (error instanceof Error && error.message.match(/socket has disconnected/i)) {\n                // ignore\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    connectToClient(listener) {\n        const responseStream = this.socket.events.map(toJsonRpcResponse);\n        // this should unsubscribe itself, so doesn't need to be removed explicitly\n        const idSubscription = responseStream\n            .filter((response) => response.id === this.request.id)\n            .subscribe({\n            next: (response) => {\n                if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n                    this.closeSubscriptions();\n                    listener.error(JSON.stringify(response.error));\n                }\n                idSubscription.unsubscribe();\n            },\n        });\n        // this will fire on a response (success or error)\n        // Tendermint adds an \"#event\" suffix for events that follow a previous subscription\n        // https://github.com/tendermint/tendermint/blob/v0.23.0/rpc/core/events.go#L107\n        const idEventSubscription = responseStream\n            .filter((response) => response.id === this.request.id)\n            .subscribe({\n            next: (response) => {\n                if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n                    this.closeSubscriptions();\n                    listener.error(JSON.stringify(response.error));\n                }\n                else {\n                    listener.next(response.result);\n                }\n            },\n        });\n        // this will fire in case the websocket disconnects cleanly\n        const nonResponseSubscription = responseStream.subscribe({\n            error: (error) => {\n                this.closeSubscriptions();\n                listener.error(error);\n            },\n            complete: () => {\n                this.closeSubscriptions();\n                listener.complete();\n            },\n        });\n        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);\n    }\n    closeSubscriptions() {\n        for (const subscription of this.subscriptions) {\n            subscription.unsubscribe();\n        }\n        // clear unused subscriptions\n        this.subscriptions = [];\n    }\n}\nclass WebsocketClient {\n    constructor(baseUrl = \"ws://localhost:46657\", onError = defaultErrorHandler) {\n        // Lazily create streams and use the same stream when listening to the same query twice.\n        //\n        // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this\n        // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!\n        this.subscriptionStreams = new Map();\n        // accept host.name:port and assume ws protocol\n        // make sure we don't end up with ...//websocket\n        const path = baseUrl.endsWith(\"/\") ? \"websocket\" : \"/websocket\";\n        const cleanBaseUrl = rpcclient_1.hasProtocol(baseUrl) ? baseUrl : \"ws://\" + baseUrl;\n        this.url = cleanBaseUrl + path;\n        this.socket = new socket_1.ReconnectingSocket(this.url);\n        const errorSubscription = this.socket.events.subscribe({\n            error: (error) => {\n                onError(error);\n                errorSubscription.unsubscribe();\n            },\n        });\n        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);\n        this.socket.connect();\n    }\n    async execute(request) {\n        const pendingResponse = this.responseForRequestId(request.id);\n        this.socket.queueRequest(JSON.stringify(request));\n        const response = await pendingResponse;\n        if (json_rpc_1.isJsonRpcErrorResponse(response)) {\n            throw new Error(JSON.stringify(response.error));\n        }\n        return response;\n    }\n    listen(request) {\n        if (request.method !== \"subscribe\") {\n            throw new Error(`Request method must be \"subscribe\" to start event listening`);\n        }\n        const query = request.params.query;\n        if (typeof query !== \"string\") {\n            throw new Error(\"request.params.query must be a string\");\n        }\n        if (!this.subscriptionStreams.has(query)) {\n            const producer = new RpcEventProducer(request, this.socket);\n            const stream = xstream_1.Stream.create(producer);\n            this.subscriptionStreams.set(query, stream);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.subscriptionStreams.get(query).filter((response) => response.query !== undefined);\n    }\n    /**\n     * Resolves as soon as websocket is connected. execute() queues requests automatically,\n     * so this should be required for testing purposes only.\n     */\n    async connected() {\n        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);\n    }\n    disconnect() {\n        this.socket.disconnect();\n    }\n    async responseForRequestId(id) {\n        return stream_1.firstEvent(this.jsonRpcResponseStream.filter((r) => r.id === id));\n    }\n}\nexports.WebsocketClient = WebsocketClient;\n//# sourceMappingURL=websocketclient.js.map"]},"metadata":{},"sourceType":"script"}