{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nconst ops_1 = require(\"./ops\");\n\nconst specs_1 = require(\"./specs\");\n\nexports.iavlSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 4,\n    maxPrefixLength: 12,\n    childSize: 33,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n};\nexports.tendermintSpec = {\n  leafSpec: {\n    prefix: Uint8Array.from([0]),\n    hash: codecimpl_1.ics23.HashOp.SHA256,\n    prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n    prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n    length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n  },\n  innerSpec: {\n    childOrder: [0, 1],\n    minPrefixLength: 1,\n    maxPrefixLength: 1,\n    childSize: 32,\n    hash: codecimpl_1.ics23.HashOp.SHA256\n  }\n}; // verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\n\nfunction verifyExistence(proof, spec, root, key, value) {\n  ensureSpec(proof, spec);\n  const calc = calculateExistenceRoot(proof);\n  specs_1.ensureBytesEqual(calc, root);\n  specs_1.ensureBytesEqual(key, proof.key);\n  specs_1.ensureBytesEqual(value, proof.value);\n}\n\nexports.verifyExistence = verifyExistence; // Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\n\nfunction verifyNonExistence(proof, spec, root, key) {\n  let leftKey;\n  let rightKey;\n\n  if (proof.left) {\n    verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n    leftKey = proof.left.key;\n  }\n\n  if (proof.right) {\n    verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n    rightKey = proof.right.key;\n  }\n\n  if (!leftKey && !rightKey) {\n    throw new Error(\"neither left nor right proof defined\");\n  }\n\n  if (!!leftKey) {\n    specs_1.ensureBytesBefore(leftKey, key);\n  }\n\n  if (!!rightKey) {\n    specs_1.ensureBytesBefore(key, rightKey);\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"no inner spec\");\n  }\n\n  if (!leftKey) {\n    ensureLeftMost(spec.innerSpec, proof.right.path);\n  } else if (!rightKey) {\n    ensureRightMost(spec.innerSpec, proof.left.path);\n  } else {\n    ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n  }\n\n  return;\n}\n\nexports.verifyNonExistence = verifyNonExistence; // Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\n\nfunction calculateExistenceRoot(proof) {\n  if (!proof.key || !proof.value) {\n    throw new Error(\"Existence proof needs key and value set\");\n  }\n\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  const path = proof.path || [];\n  let res = ops_1.applyLeaf(proof.leaf, proof.key, proof.value);\n\n  for (const inner of path) {\n    res = ops_1.applyInner(inner, res);\n  }\n\n  return res;\n}\n\nexports.calculateExistenceRoot = calculateExistenceRoot; // ensureSpec throws an Error if proof doesn't fulfill spec\n\nfunction ensureSpec(proof, spec) {\n  if (!proof.leaf) {\n    throw new Error(\"Existence proof must start with a leaf operation\");\n  }\n\n  if (!spec.leafSpec) {\n    throw new Error(\"Spec must include leafSpec\");\n  }\n\n  if (!spec.innerSpec) {\n    throw new Error(\"Spec must include innerSpec\");\n  }\n\n  specs_1.ensureLeaf(proof.leaf, spec.leafSpec);\n  const path = proof.path || [];\n\n  if (spec.minDepth && path.length < spec.minDepth) {\n    throw new Error(`Too few inner nodes ${path.length}`);\n  }\n\n  if (spec.maxDepth && path.length > spec.maxDepth) {\n    throw new Error(`Too many inner nodes ${path.length}`);\n  }\n\n  for (const inner of path) {\n    specs_1.ensureInner(inner, spec.leafSpec.prefix, spec.innerSpec);\n  }\n}\n\nexports.ensureSpec = ensureSpec;\n\nfunction ensureLeftMost(spec, path) {\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, 0); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureRightMost(spec, path) {\n  const len = spec.childOrder.length - 1;\n  const {\n    minPrefix,\n    maxPrefix,\n    suffix\n  } = getPadding(spec, len); // ensure every step has a prefix and suffix defined to be leftmost\n\n  for (const step of path) {\n    if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n      throw new Error(\"Step not leftmost\");\n    }\n  }\n}\n\nfunction ensureLeftNeighbor(spec, left, right) {\n  // tslint:disable:readonly-array\n  const mutleft = [...left];\n  const mutright = [...right];\n  let topleft = mutleft.pop();\n  let topright = mutright.pop();\n\n  while (specs_1.bytesEqual(topleft.prefix, topright.prefix) && specs_1.bytesEqual(topleft.suffix, topright.suffix)) {\n    topleft = mutleft.pop();\n    topright = mutright.pop();\n  } // now topleft and topright are the first divergent nodes\n  // make sure they are left and right of each other\n\n\n  if (!isLeftStep(spec, topleft, topright)) {\n    throw new Error(`Not left neightbor at first divergent step`);\n  } // make sure the paths are left and right most possibilities respectively\n\n\n  ensureRightMost(spec, mutleft);\n  ensureLeftMost(spec, mutright);\n}\n\nexports.ensureLeftNeighbor = ensureLeftNeighbor; // isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\n\nfunction isLeftStep(spec, left, right) {\n  const leftidx = orderFromPadding(spec, left);\n  const rightidx = orderFromPadding(spec, right);\n  return rightidx === leftidx + 1;\n}\n\nfunction orderFromPadding(spec, inner) {\n  for (let branch = 0; branch < spec.childOrder.length; branch++) {\n    const {\n      minPrefix,\n      maxPrefix,\n      suffix\n    } = getPadding(spec, branch);\n\n    if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n      return branch;\n    }\n  }\n\n  throw new Error(`Cannot find any valid spacing for this node`);\n}\n\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n  if ((op.prefix || []).length < minPrefix) {\n    return false;\n  }\n\n  if ((op.prefix || []).length > maxPrefix) {\n    return false;\n  }\n\n  return (op.suffix || []).length === suffix;\n}\n\nfunction getPadding(spec, branch) {\n  const idx = getPosition(spec.childOrder, branch); // count how many children are in the prefix\n\n  const prefix = idx * spec.childSize;\n  const minPrefix = prefix + spec.minPrefixLength;\n  const maxPrefix = prefix + spec.maxPrefixLength; // count how many children are in the suffix\n\n  const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n  return {\n    minPrefix,\n    maxPrefix,\n    suffix\n  };\n}\n\nfunction getPosition(order, branch) {\n  if (branch < 0 || branch >= order.length) {\n    throw new Error(`Invalid branch: ${branch}`);\n  }\n\n  return order.findIndex(val => val === branch);\n}","map":{"version":3,"sources":["../src/proofs.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst ops_1 = require(\"./ops\");\nconst specs_1 = require(\"./specs\");\nexports.iavlSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 4,\n        maxPrefixLength: 12,\n        childSize: 33,\n        hash: codecimpl_1.ics23.HashOp.SHA256\n    }\n};\nexports.tendermintSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        childSize: 32,\n        hash: codecimpl_1.ics23.HashOp.SHA256\n    }\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n    ensureSpec(proof, spec);\n    const calc = calculateExistenceRoot(proof);\n    specs_1.ensureBytesEqual(calc, root);\n    specs_1.ensureBytesEqual(key, proof.key);\n    specs_1.ensureBytesEqual(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n    let leftKey;\n    let rightKey;\n    if (proof.left) {\n        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n        leftKey = proof.left.key;\n    }\n    if (proof.right) {\n        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n        rightKey = proof.right.key;\n    }\n    if (!leftKey && !rightKey) {\n        throw new Error(\"neither left nor right proof defined\");\n    }\n    if (!!leftKey) {\n        specs_1.ensureBytesBefore(leftKey, key);\n    }\n    if (!!rightKey) {\n        specs_1.ensureBytesBefore(key, rightKey);\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"no inner spec\");\n    }\n    if (!leftKey) {\n        ensureLeftMost(spec.innerSpec, proof.right.path);\n    }\n    else if (!rightKey) {\n        ensureRightMost(spec.innerSpec, proof.left.path);\n    }\n    else {\n        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n    }\n    return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n    if (!proof.key || !proof.value) {\n        throw new Error(\"Existence proof needs key and value set\");\n    }\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    const path = proof.path || [];\n    let res = ops_1.applyLeaf(proof.leaf, proof.key, proof.value);\n    for (const inner of path) {\n        res = ops_1.applyInner(inner, res);\n    }\n    return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    if (!spec.leafSpec) {\n        throw new Error(\"Spec must include leafSpec\");\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"Spec must include innerSpec\");\n    }\n    specs_1.ensureLeaf(proof.leaf, spec.leafSpec);\n    const path = proof.path || [];\n    if (spec.minDepth && path.length < spec.minDepth) {\n        throw new Error(`Too few inner nodes ${path.length}`);\n    }\n    if (spec.maxDepth && path.length > spec.maxDepth) {\n        throw new Error(`Too many inner nodes ${path.length}`);\n    }\n    for (const inner of path) {\n        specs_1.ensureInner(inner, spec.leafSpec.prefix, spec.innerSpec);\n    }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureRightMost(spec, path) {\n    const len = spec.childOrder.length - 1;\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n    // tslint:disable:readonly-array\n    const mutleft = [...left];\n    const mutright = [...right];\n    let topleft = mutleft.pop();\n    let topright = mutright.pop();\n    while (specs_1.bytesEqual(topleft.prefix, topright.prefix) &&\n        specs_1.bytesEqual(topleft.suffix, topright.suffix)) {\n        topleft = mutleft.pop();\n        topright = mutright.pop();\n    }\n    // now topleft and topright are the first divergent nodes\n    // make sure they are left and right of each other\n    if (!isLeftStep(spec, topleft, topright)) {\n        throw new Error(`Not left neightbor at first divergent step`);\n    }\n    // make sure the paths are left and right most possibilities respectively\n    ensureRightMost(spec, mutleft);\n    ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n    const leftidx = orderFromPadding(spec, left);\n    const rightidx = orderFromPadding(spec, right);\n    return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n    for (let branch = 0; branch < spec.childOrder.length; branch++) {\n        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);\n        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n            return branch;\n        }\n    }\n    throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n    if ((op.prefix || []).length < minPrefix) {\n        return false;\n    }\n    if ((op.prefix || []).length > maxPrefix) {\n        return false;\n    }\n    return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n    const idx = getPosition(spec.childOrder, branch);\n    // count how many children are in the prefix\n    const prefix = idx * spec.childSize;\n    const minPrefix = prefix + spec.minPrefixLength;\n    const maxPrefix = prefix + spec.maxPrefixLength;\n    // count how many children are in the suffix\n    const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n    return { minPrefix, maxPrefix, suffix };\n}\nfunction getPosition(order, branch) {\n    if (branch < 0 || branch >= order.length) {\n        throw new Error(`Invalid branch: ${branch}`);\n    }\n    return order.findIndex(val => val === branch);\n}\n//# sourceMappingURL=proofs.js.map"]},"metadata":{},"sourceType":"script"}