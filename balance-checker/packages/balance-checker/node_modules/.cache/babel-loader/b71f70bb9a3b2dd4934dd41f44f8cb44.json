{"ast":null,"code":"import React__default, { useState, useContext, createElement, createContext, useEffect } from 'react';\nimport { SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';\nimport { Bip39, Random } from '@cosmjs/crypto';\nimport { QueryClient, setupStakingExtension, setupDistributionExtension, defaultGasLimits, GasPrice, makeCosmoshubPath } from '@cosmjs/stargate';\nimport { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';\nimport { LedgerSigner } from '@cosmjs/ledger-amino';\nimport { Tendermint34Client } from '@cosmjs/tendermint-rpc';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport { FaucetClient } from '@cosmjs/faucet-client';\nimport { Switch, Redirect } from 'react-router-dom';\nimport { Decimal } from '@cosmjs/math';\n\nfunction getAppConfig(configs) {\n  var network = process.env.REACT_APP_NETWORK;\n  if (!network) return configs.local;\n  var config = configs[network];\n\n  if (!config) {\n    throw new Error(\"No configuration found for network \" + network);\n  }\n\n  return config;\n}\n\nfunction configKeplr(config) {\n  return {\n    chainId: config.chainId,\n    chainName: config.chainName,\n    rpc: config.rpcUrl,\n    rest: config.httpUrl,\n    bech32Config: {\n      bech32PrefixAccAddr: \"\" + config.addressPrefix,\n      bech32PrefixAccPub: config.addressPrefix + \"pub\",\n      bech32PrefixValAddr: config.addressPrefix + \"valoper\",\n      bech32PrefixValPub: config.addressPrefix + \"valoperpub\",\n      bech32PrefixConsAddr: config.addressPrefix + \"valcons\",\n      bech32PrefixConsPub: config.addressPrefix + \"valconspub\"\n    },\n    currencies: [{\n      coinDenom: config.coinMap[config.feeToken].denom,\n      coinMinimalDenom: config.feeToken,\n      coinDecimals: config.coinMap[config.feeToken].fractionalDigits\n    }, {\n      coinDenom: config.coinMap[config.stakingToken].denom,\n      coinMinimalDenom: config.stakingToken,\n      coinDecimals: config.coinMap[config.stakingToken].fractionalDigits\n    }],\n    feeCurrencies: [{\n      coinDenom: config.coinMap[config.feeToken].denom,\n      coinMinimalDenom: config.feeToken,\n      coinDecimals: config.coinMap[config.feeToken].fractionalDigits\n    }],\n    stakeCurrency: {\n      coinDenom: config.coinMap[config.stakingToken].denom,\n      coinMinimalDenom: config.stakingToken,\n      coinDecimals: config.coinMap[config.stakingToken].fractionalDigits\n    },\n    gasPriceStep: {\n      low: config.gasPrice / 2,\n      average: config.gasPrice,\n      high: config.gasPrice * 2\n    },\n    bip44: {\n      coinType: 118\n    },\n    coinType: 118\n  };\n}\n\nvar defaultContext = {\n  contracts: [],\n  addContract: function addContract() {\n    return;\n  }\n};\nvar ContractsContext = /*#__PURE__*/React__default.createContext(defaultContext);\n\nvar useContracts = function useContracts() {\n  return React__default.useContext(ContractsContext);\n};\n\nfunction ContractsProvider(_ref) {\n  var children = _ref.children;\n\n  var _useState = useState(defaultContext.contracts),\n      contracts = _useState[0],\n      setContracts = _useState[1];\n\n  function addContract(newContract) {\n    setContracts(function (contracts) {\n      var notPresent = !contracts.find(function (contract) {\n        return contract.contractAddress === newContract.contractAddress;\n      });\n      if (notPresent) return [].concat(contracts, [newContract]);\n      return contracts;\n    });\n  }\n\n  var value = {\n    contracts: contracts,\n    addContract: addContract\n  };\n  return React__default.createElement(ContractsContext.Provider, {\n    value: value\n  }, children);\n}\n\nvar CW20 = function CW20(client) {\n  var use = function use(contractAddress) {\n    var balance = function balance(address) {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          balance: {\n            address: address\n          }\n        })).then(function (result) {\n          return result.balance;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var allowance = function allowance(owner, spender) {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          allowance: {\n            owner: owner,\n            spender: spender\n          }\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var allAllowances = function allAllowances(owner, startAfter, limit) {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          all_allowances: {\n            owner: owner,\n            start_after: startAfter,\n            limit: limit\n          }\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var allAccounts = function allAccounts(startAfter, limit) {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          all_accounts: {\n            start_after: startAfter,\n            limit: limit\n          }\n        })).then(function (accounts) {\n          return accounts.accounts;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var tokenInfo = function tokenInfo() {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          token_info: {}\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var investment = function investment() {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          investment: {}\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var claims = function claims(address) {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          claims: {\n            address: address\n          }\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var minter = function minter() {\n      try {\n        return Promise.resolve(client.queryContractSmart(contractAddress, {\n          minter: {}\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }; // mints tokens, returns transactionHash\n\n\n    var mint = function mint(sender, recipient, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          mint: {\n            recipient: recipient,\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }; // transfers tokens, returns transactionHash\n\n\n    var transfer = function transfer(sender, recipient, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          transfer: {\n            recipient: recipient,\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }; // burns tokens, returns transactionHash\n\n\n    var burn = function burn(sender, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          burn: {\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var increaseAllowance = function increaseAllowance(sender, spender, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          increase_allowance: {\n            spender: spender,\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var decreaseAllowance = function decreaseAllowance(sender, spender, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          decrease_allowance: {\n            spender: spender,\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var transferFrom = function transferFrom(sender, owner, recipient, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          transfer_from: {\n            owner: owner,\n            recipient: recipient,\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var bond = function bond(sender, coin) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          bond: {}\n        }, undefined, [coin])).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var unbond = function unbond(sender, amount) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          unbond: {\n            amount: amount\n          }\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    var claim = function claim(sender) {\n      try {\n        return Promise.resolve(client.execute(sender, contractAddress, {\n          claim: {}\n        })).then(function (result) {\n          return result.transactionHash;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n\n    return {\n      contractAddress: contractAddress,\n      balance: balance,\n      allowance: allowance,\n      allAllowances: allAllowances,\n      allAccounts: allAccounts,\n      tokenInfo: tokenInfo,\n      investment: investment,\n      claims: claims,\n      minter: minter,\n      mint: mint,\n      transfer: transfer,\n      burn: burn,\n      increaseAllowance: increaseAllowance,\n      decreaseAllowance: decreaseAllowance,\n      transferFrom: transferFrom,\n      bond: bond,\n      unbond: unbond,\n      claim: claim\n    };\n  };\n\n  return {\n    use: use\n  };\n};\n\nvar defaultContext$1 = {\n  setError: function setError() {\n    return;\n  },\n  clearError: function clearError() {\n    return;\n  }\n};\nvar ErrorContext = /*#__PURE__*/createContext(defaultContext$1);\n\nvar useError = function useError() {\n  return useContext(ErrorContext);\n};\n\nfunction ErrorProvider(_ref) {\n  var children = _ref.children;\n\n  var _React$useState = useState(),\n      error = _React$useState[0],\n      setError = _React$useState[1];\n\n  var context = {\n    error: error,\n    setError: setError,\n    clearError: function clearError() {\n      setError(undefined);\n    }\n  };\n  return createElement(ErrorContext.Provider, {\n    value: context\n  }, children);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n} // it is up to the app to store this somewhere\n\n\nvar createStakingClient = function createStakingClient(apiUrl) {\n  try {\n    return Promise.resolve(Tendermint34Client.connect(apiUrl)).then(function (tmClient) {\n      return QueryClient.withExtensions(tmClient, setupStakingExtension, setupDistributionExtension);\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}; // this creates a new connection to a server at URL,\n// using a signing keyring generated from the given mnemonic\n\n\nvar createClient = function createClient(config, signer) {\n  try {\n    var gasLimits = _extends({}, defaultGasLimits, {\n      upload: 1500000,\n      init: 600000,\n      exec: 400000,\n      migrate: 600000,\n      send: 80000,\n      changeAdmin: 80000\n    });\n\n    return Promise.resolve(SigningCosmWasmClient.connectWithSigner(config.rpcUrl, signer, {\n      prefix: config.addressPrefix,\n      gasPrice: GasPrice.fromString(\"\" + config.gasPrice + config.feeToken),\n      gasLimits: gasLimits\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar loadKeplrWallet = function loadKeplrWallet(chainId) {\n  try {\n    var _signer$signAmino;\n\n    var anyWindow = window;\n\n    if (!anyWindow.getOfflineSigner) {\n      throw new Error(\"Keplr extension is not available\");\n    }\n\n    var signer = anyWindow.getOfflineSigner(chainId);\n    signer.signAmino = (_signer$signAmino = signer.signAmino) !== null && _signer$signAmino !== void 0 ? _signer$signAmino : signer.sign;\n    return Promise.resolve(signer);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar loadLedgerWallet = function loadLedgerWallet(_chainId, addressPrefix) {\n  try {\n    var interactiveTimeout = 120000;\n    return Promise.resolve(TransportWebUSB.create(interactiveTimeout, interactiveTimeout)).then(function (ledgerTransport) {\n      return new LedgerSigner(ledgerTransport, {\n        hdPaths: [makeCosmoshubPath(0)],\n        prefix: addressPrefix\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar loadOrCreateWallet = function loadOrCreateWallet(_chainId, addressPrefix) {\n  try {\n    var mnemonic = loadOrCreateMnemonic();\n    var hdPath = makeCosmoshubPath(0);\n    return Promise.resolve(DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n      hdPaths: [hdPath],\n      prefix: addressPrefix\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction generateMnemonic() {\n  return Bip39.encode(Random.getBytes(16)).toString();\n} // some code that will only work in a browser...\n\n\nfunction loadOrCreateMnemonic() {\n  var key = \"burner-wallet\";\n  var loaded = localStorage.getItem(key);\n\n  if (loaded) {\n    return loaded;\n  }\n\n  var generated = generateMnemonic();\n  localStorage.setItem(key, generated);\n  return generated;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nvar _Pact = /*#__PURE__*/function () {\n  function _Pact() {}\n\n  _Pact.prototype.then = function (onFulfilled, onRejected) {\n    var result = new _Pact();\n    var state = this.s;\n\n    if (state) {\n      var callback = state & 1 ? onFulfilled : onRejected;\n\n      if (callback) {\n        try {\n          _settle(result, 1, callback(this.v));\n        } catch (e) {\n          _settle(result, 2, e);\n        }\n\n        return result;\n      } else {\n        return this;\n      }\n    }\n\n    this.o = function (_this) {\n      try {\n        var value = _this.v;\n\n        if (_this.s & 1) {\n          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n        } else if (onRejected) {\n          _settle(result, 1, onRejected(value));\n        } else {\n          _settle(result, 2, value);\n        }\n      } catch (e) {\n        _settle(result, 2, e);\n      }\n    };\n\n    return result;\n  };\n\n  return _Pact;\n}(); // Settles a pact synchronously\n\n\nfunction _settle(pact, state, value) {\n  if (!pact.s) {\n    if (value instanceof _Pact) {\n      if (value.s) {\n        if (state & 1) {\n          state = value.s;\n        }\n\n        value = value.v;\n      } else {\n        value.o = _settle.bind(null, pact, state);\n        return;\n      }\n    }\n\n    if (value && value.then) {\n      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n      return;\n    }\n\n    pact.s = state;\n    pact.v = value;\n    var observer = pact.o;\n\n    if (observer) {\n      observer(pact);\n    }\n  }\n}\n\nfunction _isSettledPact(thenable) {\n  return thenable instanceof _Pact && thenable.s & 1;\n} // Converts argument to a function that always returns a Promise\n\n\nfunction _forTo(array, body, check) {\n  var i = -1,\n      pact,\n      reject;\n\n  function _cycle(result) {\n    try {\n      while (++i < array.length && (!check || !check())) {\n        result = body(i);\n\n        if (result && result.then) {\n          if (_isSettledPact(result)) {\n            result = result.v;\n          } else {\n            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n            return;\n          }\n        }\n      }\n\n      if (pact) {\n        _settle(pact, 1, result);\n      } else {\n        pact = result;\n      }\n    } catch (e) {\n      _settle(pact || (pact = new _Pact()), 2, e);\n    }\n  }\n\n  _cycle();\n\n  return pact;\n} // Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\n\n\nfunction _forIn(target, body, check) {\n  var keys = [];\n\n  for (var key in target) {\n    keys.push(key);\n  }\n\n  return _forTo(keys, function (i) {\n    return body(keys[i]);\n  }, check);\n} // Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol(\"Symbol.iterator\")) : \"@@iterator\"; // Asynchronously iterate through an object's values\n\n\nvar _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n} // Asynchronously await a promise and pass the result to a finally continuation\n\n\nfunction throwNotInitialized() {\n  throw new Error(\"Not yet initialized\");\n}\n\nvar defaultContext$2 = {\n  initialized: false,\n  init: throwNotInitialized,\n  clear: throwNotInitialized,\n  config: {},\n  changeConfig: throwNotInitialized,\n  address: \"\",\n  balance: [],\n  refreshBalance: throwNotInitialized,\n  hitFaucet: throwNotInitialized,\n  getSigner: throwNotInitialized,\n  changeSigner: throwNotInitialized,\n  getClient: throwNotInitialized,\n  getStakingClient: throwNotInitialized\n};\nvar CosmWasmContext = /*#__PURE__*/createContext(defaultContext$2);\n\nvar useSdk = function useSdk() {\n  return useContext(CosmWasmContext);\n};\n\nfunction SdkProvider(_ref) {\n  // Get feeToken balance from faucet\n  var hitFaucet = function hitFaucet(address) {\n    try {\n      if (!config.faucetUrl || !config.feeToken) return Promise.resolve();\n\n      var _temp6 = _catch(function () {\n        var faucet = new FaucetClient(config.faucetUrl);\n        return Promise.resolve(faucet.credit(address, config.feeToken)).then(function () {});\n      }, function (error) {\n        setError(error.message);\n        console.error(error);\n      });\n\n      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }; // Get balance for each coin specified in config.coinMap\n\n\n  var refreshBalance = function refreshBalance(address, balance) {\n    try {\n      if (!client) return Promise.resolve();\n      balance.length = 0;\n\n      var _temp8 = _forIn(config.coinMap, function (denom) {\n        return Promise.resolve(client.getBalance(address, denom)).then(function (coin) {\n          if (coin) balance.push(coin);\n        });\n      });\n\n      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  var configProp = _ref.config,\n      children = _ref.children;\n\n  var _useError = useError(),\n      setError = _useError.setError;\n\n  var _useState = useState(configProp),\n      config = _useState[0],\n      setConfig = _useState[1];\n\n  var _useState2 = useState(),\n      signer = _useState2[0],\n      setSigner = _useState2[1];\n\n  var _useState3 = useState(),\n      client = _useState3[0],\n      setClient = _useState3[1];\n\n  var contextWithInit = _extends({}, defaultContext$2, {\n    init: setSigner\n  });\n\n  var _useState4 = useState(contextWithInit),\n      value = _useState4[0],\n      setValue = _useState4[1];\n\n  function clear() {\n    setValue(_extends({}, contextWithInit));\n    setClient(undefined);\n    setSigner(undefined);\n    setConfig(configProp);\n  }\n\n  function changeConfig(updates) {\n    setConfig(function (config) {\n      return _extends({}, config, updates);\n    });\n  }\n\n  useEffect(function () {\n    if (!signer) return;\n\n    (function updateClient() {\n      try {\n        var _temp2 = _catch(function () {\n          return Promise.resolve(createClient(config, signer)).then(function (client) {\n            setClient(client);\n          });\n        }, function (error) {\n          setError(error.message);\n        });\n\n        return _temp2 && _temp2.then ? _temp2.then(function () {}) : void 0;\n      } catch (e) {\n        Promise.reject(e);\n      }\n    })();\n  }, [signer, config]);\n  useEffect(function () {\n    if (!signer || !client) return;\n    var balance = [];\n\n    (function updateValue() {\n      try {\n        return Promise.resolve(signer.getAccounts()).then(function (_signer$getAccounts) {\n          var address = _signer$getAccounts[0].address;\n          return Promise.resolve(refreshBalance(address, balance)).then(function () {\n            function _temp4() {\n              return Promise.resolve(refreshBalance(address, balance)).then(function () {\n                return Promise.resolve(createStakingClient(config.rpcUrl)).then(function (stakingClient) {\n                  setValue({\n                    initialized: true,\n                    init: function init() {},\n                    clear: clear,\n                    config: config,\n                    changeConfig: changeConfig,\n                    address: address,\n                    balance: balance,\n                    refreshBalance: refreshBalance.bind(null, address, balance),\n                    hitFaucet: hitFaucet.bind(null, address),\n                    getSigner: function getSigner() {\n                      return signer;\n                    },\n                    changeSigner: setSigner,\n                    getClient: function getClient() {\n                      return client;\n                    },\n                    getStakingClient: function getStakingClient() {\n                      return stakingClient;\n                    }\n                  });\n                });\n              });\n            }\n\n            var _temp3 = function () {\n              if (!balance.find(function (coin) {\n                return coin.denom === config.feeToken;\n              })) {\n                return Promise.resolve(hitFaucet(address)).then(function () {});\n              }\n            }();\n\n            return _temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3);\n          });\n        });\n      } catch (e) {\n        Promise.reject(e);\n      }\n    })();\n  }, [client]);\n  return createElement(CosmWasmContext.Provider, {\n    value: value\n  }, children);\n}\n\nfunction ProtectedSwitch(_ref) {\n  var authPath = _ref.authPath,\n      children = _ref.children,\n      location = _ref.location;\n\n  var _useSdk = useSdk(),\n      initialized = _useSdk.initialized;\n\n  return initialized ? React__default.createElement(Switch, {\n    location: location\n  }, children) : React__default.createElement(Redirect, {\n    to: {\n      pathname: authPath,\n      state: location ? {\n        redirectPathname: location.pathname,\n        redirectState: location.state\n      } : undefined\n    }\n  });\n}\n\nvar thinSpace = \"\\u202F\";\n\nfunction printableCoin(coin) {\n  if (!coin) {\n    return \"0\";\n  }\n\n  if (coin.denom.startsWith(\"u\")) {\n    var ticker = coin.denom.slice(1).toUpperCase();\n    return Decimal.fromAtomics(coin.amount, 6).toString() + thinSpace + ticker;\n  } else {\n    return coin.amount + thinSpace + coin.denom;\n  }\n}\n\nfunction printableBalance(balance) {\n  if (!balance || balance.length === 0) return \"–\";\n  return balance.map(printableCoin).join(\", \");\n}\n\nfunction nativeCoinToDisplay(coin, coinMap) {\n  if (!coinMap) return coin;\n  var coinToDisplay = coinMap[coin.denom];\n  if (!coinToDisplay) return coin;\n  var amountToDisplay = Decimal.fromAtomics(coin.amount, coinToDisplay.fractionalDigits).toString();\n  return {\n    denom: coinToDisplay.denom,\n    amount: amountToDisplay\n  };\n} // display amount is eg \"12.0346\", return is in native tokens\n// with 6 fractional digits, this would be eg. \"12034600\"\n\n\nfunction displayAmountToNative(amountToDisplay, coinMap, nativeDenom) {\n  var _coinMap$nativeDenom;\n\n  var fractionalDigits = (_coinMap$nativeDenom = coinMap[nativeDenom]) === null || _coinMap$nativeDenom === void 0 ? void 0 : _coinMap$nativeDenom.fractionalDigits;\n\n  if (fractionalDigits) {\n    // use https://github.com/CosmWasm/cosmjs/blob/v0.22.2/packages/math/src/decimal.ts\n    var decimalAmount = Decimal.fromUserInput(amountToDisplay, fractionalDigits);\n    return decimalAmount.atomics;\n  }\n\n  return amountToDisplay;\n} // Get string error from operation stack trace. Matches last line but removes last \"message index\" part\n\n\nfunction getErrorFromStackTrace(stackTrace) {\n  var stringStackTrace = (stackTrace || \"\").toString();\n  var match = stringStackTrace.match(/.*\\s*$/g)[0];\n  var error = match.substring(0, match.lastIndexOf(\";\"));\n  return error || stringStackTrace;\n}\n\nexport { CW20, ContractsProvider, ErrorProvider, ProtectedSwitch, SdkProvider, configKeplr, createClient, createStakingClient, displayAmountToNative, generateMnemonic, getAppConfig, getErrorFromStackTrace, loadKeplrWallet, loadLedgerWallet, loadOrCreateMnemonic, loadOrCreateWallet, nativeCoinToDisplay, printableBalance, printableCoin, useContracts, useError, useSdk };","map":{"version":3,"sources":["../src/config.ts","../src/service/contracts.tsx","../src/service/cw20.tsx","../src/service/error.tsx","../src/service/sdk.ts","../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/service/wallet.tsx","../src/service/ProtectedSwitch.tsx","../src/utils/currency.ts","../src/utils/errors.ts"],"names":["getAppConfig","configs","network","process","config","configKeplr","chainId","chainName","rpc","rest","bech32Config","bech32PrefixAccAddr","bech32PrefixAccPub","bech32PrefixValAddr","bech32PrefixValPub","bech32PrefixConsAddr","bech32PrefixConsPub","currencies","coinDenom","coinMinimalDenom","coinDecimals","fractionalDigits","feeCurrencies","stakeCurrency","gasPriceStep","low","average","high","bip44","coinType","defaultContext","contracts","addContract","ContractsContext","React","useContracts","ContractsProvider","children","setContracts","useState","notPresent","contract","newContract","value","CW20","use","balance","result","address","allowance","owner","spender","allAllowances","all_allowances","start_after","limit","allAccounts","accounts","all_accounts","tokenInfo","token_info","investment","claims","minter","mint","recipient","amount","transfer","burn","increaseAllowance","increase_allowance","decreaseAllowance","decrease_allowance","transferFrom","transfer_from","bond","unbond","claim","contractAddress","setError","clearError","ErrorContext","useError","ErrorProvider","error","context","generateMnemonic","Bip39","Random","loadOrCreateMnemonic","key","loaded","localStorage","generated","loadOrCreateWallet","mnemonic","hdPath","makeCosmoshubPath","hdPaths","prefix","addressPrefix","loadLedgerWallet","interactiveTimeout","ledgerTransport","TransportWebUSB","loadKeplrWallet","anyWindow","signer","Promise","createClient","gasLimits","upload","init","exec","migrate","send","changeAdmin","gasPrice","GasPrice","createStakingClient","tmClient","Tendermint34Client","QueryClient","_Pact","state","callback","_settle","_this","onFulfilled","onRejected","pact","observer","thenable","i","array","check","body","_isSettledPact","reject","_cycle","keys","_forTo","_iteratorSymbol","Symbol","_asyncIteratorSymbol","recover","initialized","clear","changeConfig","refreshBalance","hitFaucet","getSigner","changeSigner","getClient","getStakingClient","throwNotInitialized","CosmWasmContext","useSdk","SdkProvider","configProp","setConfig","setSigner","client","setClient","contextWithInit","setValue","denom","coinMap","faucet","console","useEffect","coin","stakingClient","ProtectedSwitch","authPath","location","to","pathname","redirectPathname","redirectState","undefined","thinSpace","printableCoin","ticker","Decimal","printableBalance","nativeCoinToDisplay","coinToDisplay","amountToDisplay","displayAmountToNative","nativeDenom","decimalAmount","getErrorFromStackTrace","stackTrace","stringStackTrace","match"],"mappings":"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","sourcesContent":["import { CoinMap } from \"./utils\";\n\nexport interface KeplrCoin {\n  readonly coinDenom: string;\n  readonly coinMinimalDenom: string;\n  readonly coinDecimals: number;\n}\n\nexport interface KeplrConfig {\n  readonly chainId: string;\n  readonly chainName: string;\n  readonly rpc: string;\n  readonly rest: string;\n  readonly bech32Config: {\n    readonly bech32PrefixAccAddr: string;\n    readonly bech32PrefixAccPub: string;\n    readonly bech32PrefixValAddr: string;\n    readonly bech32PrefixValPub: string;\n    readonly bech32PrefixConsAddr: string;\n    readonly bech32PrefixConsPub: string;\n  };\n  readonly currencies: readonly KeplrCoin[];\n  readonly feeCurrencies: readonly KeplrCoin[];\n  readonly stakeCurrency: KeplrCoin;\n  readonly gasPriceStep: {\n    readonly low: number;\n    readonly average: number;\n    readonly high: number;\n  };\n  readonly bip44: { readonly coinType: number };\n  readonly coinType: number;\n}\n\nexport interface AppConfig {\n  readonly chainId: string;\n  readonly chainName: string;\n  readonly addressPrefix: string;\n  readonly rpcUrl: string;\n  readonly httpUrl: string;\n  readonly faucetUrl: string;\n  readonly feeToken: string;\n  readonly stakingToken: string;\n  readonly coinMap: CoinMap;\n  readonly gasPrice: number;\n  readonly codeId?: number;\n}\n\nexport interface NetworkConfigs {\n  readonly local: AppConfig;\n  readonly [key: string]: AppConfig;\n}\n\nexport function getAppConfig(configs: NetworkConfigs): AppConfig {\n  const network = process.env.REACT_APP_NETWORK;\n  if (!network) return configs.local;\n\n  const config = configs[network];\n  if (!config) {\n    throw new Error(`No configuration found for network ${network}`);\n  }\n\n  return config;\n}\n\nexport function configKeplr(config: AppConfig): KeplrConfig {\n  return {\n    chainId: config.chainId,\n    chainName: config.chainName,\n    rpc: config.rpcUrl,\n    rest: config.httpUrl,\n    bech32Config: {\n      bech32PrefixAccAddr: `${config.addressPrefix}`,\n      bech32PrefixAccPub: `${config.addressPrefix}pub`,\n      bech32PrefixValAddr: `${config.addressPrefix}valoper`,\n      bech32PrefixValPub: `${config.addressPrefix}valoperpub`,\n      bech32PrefixConsAddr: `${config.addressPrefix}valcons`,\n      bech32PrefixConsPub: `${config.addressPrefix}valconspub`,\n    },\n    currencies: [\n      {\n        coinDenom: config.coinMap[config.feeToken].denom,\n        coinMinimalDenom: config.feeToken,\n        coinDecimals: config.coinMap[config.feeToken].fractionalDigits,\n      },\n      {\n        coinDenom: config.coinMap[config.stakingToken].denom,\n        coinMinimalDenom: config.stakingToken,\n        coinDecimals: config.coinMap[config.stakingToken].fractionalDigits,\n      },\n    ],\n    feeCurrencies: [\n      {\n        coinDenom: config.coinMap[config.feeToken].denom,\n        coinMinimalDenom: config.feeToken,\n        coinDecimals: config.coinMap[config.feeToken].fractionalDigits,\n      },\n    ],\n    stakeCurrency: {\n      coinDenom: config.coinMap[config.stakingToken].denom,\n      coinMinimalDenom: config.stakingToken,\n      coinDecimals: config.coinMap[config.stakingToken].fractionalDigits,\n    },\n    gasPriceStep: {\n      low: config.gasPrice / 2,\n      average: config.gasPrice,\n      high: config.gasPrice * 2,\n    },\n    bip44: { coinType: 118 },\n    coinType: 118,\n  };\n}\n","import React, { useState } from \"react\";\nimport { CW20Instance } from \"./cw20\";\n\ninterface ContractsContextType {\n  contracts: CW20Instance[];\n  readonly addContract: (newContract: CW20Instance) => void;\n}\n\nconst defaultContext: ContractsContextType = {\n  contracts: [],\n  addContract: function () {\n    return;\n  },\n};\n\nconst ContractsContext = React.createContext<ContractsContextType>(defaultContext);\n\nexport const useContracts = (): ContractsContextType => React.useContext(ContractsContext);\n\nexport function ContractsProvider({ children }: React.HTMLAttributes<HTMLOrSVGElement>): JSX.Element {\n  const [contracts, setContracts] = useState<CW20Instance[]>(defaultContext.contracts);\n\n  function addContract(newContract: CW20Instance) {\n    setContracts((contracts) => {\n      const notPresent = !contracts.find(\n        (contract) => contract.contractAddress === newContract.contractAddress,\n      );\n\n      if (notPresent) return [...contracts, newContract];\n      return contracts;\n    });\n  }\n\n  const value: ContractsContextType = { contracts, addContract };\n\n  return <ContractsContext.Provider value={value}>{children}</ContractsContext.Provider>;\n}\n","import { SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nimport { Coin } from \"@cosmjs/stargate\";\n\nexport type Expiration =\n  | { readonly at_height: number }\n  | { readonly at_time: number }\n  | { readonly never: unknown };\n\nexport interface AllowanceResponse {\n  readonly allowance: string; // integer as string\n  readonly expires: Expiration;\n}\n\nexport interface AllowanceInfo {\n  readonly allowance: string; // integer as string\n  readonly spender: string; // bech32 address\n  readonly expires: Expiration;\n}\n\nexport interface AllAllowancesResponse {\n  readonly allowances: readonly AllowanceInfo[];\n}\n\nexport interface TokenInfo {\n  readonly name: string;\n  readonly symbol: string;\n  readonly decimals: number;\n  readonly total_supply: string;\n}\n\nexport interface Investment {\n  readonly exit_tax: string;\n  readonly min_withdrawal: string;\n  readonly nominal_value: string;\n  readonly owner: string;\n  readonly staked_tokens: Coin;\n  readonly token_supply: string;\n  readonly validator: string;\n}\n\nexport interface Claim {\n  readonly amount: string;\n  readonly release_at: { readonly at_time: number };\n}\n\nexport interface Claims {\n  readonly claims: readonly Claim[];\n}\n\nexport interface AllAccountsResponse {\n  // list of bech32 address that have a balance\n  readonly accounts: readonly string[];\n}\n\nexport interface CW20Instance {\n  readonly contractAddress: string;\n\n  // queries\n  balance: (address: string) => Promise<string>;\n  allowance: (owner: string, spender: string) => Promise<AllowanceResponse>;\n  allAllowances: (owner: string, startAfter?: string, limit?: number) => Promise<AllAllowancesResponse>;\n  allAccounts: (startAfter?: string, limit?: number) => Promise<readonly string[]>;\n  tokenInfo: () => Promise<TokenInfo>;\n  investment: () => Promise<Investment>;\n  claims: (address: string) => Promise<Claims>;\n  minter: (sender: string) => Promise<any>;\n\n  // actions\n  mint: (sender: string, recipient: string, amount: string) => Promise<string>;\n  transfer: (sender: string, recipient: string, amount: string) => Promise<string>;\n  burn: (sender: string, amount: string) => Promise<string>;\n  increaseAllowance: (sender: string, recipient: string, amount: string) => Promise<string>;\n  decreaseAllowance: (sender: string, recipient: string, amount: string) => Promise<string>;\n  transferFrom: (sender: string, owner: string, recipient: string, amount: string) => Promise<string>;\n  bond: (sender: string, coin: Coin) => Promise<string>;\n  unbond: (sender: string, amount: string) => Promise<string>;\n  claim: (sender: string) => Promise<string>;\n}\n\nexport interface CW20Contract {\n  use: (contractAddress: string) => CW20Instance;\n}\n\nexport const CW20 = (client: SigningCosmWasmClient): CW20Contract => {\n  const use = (contractAddress: string): CW20Instance => {\n    const balance = async (address: string): Promise<string> => {\n      const result = await client.queryContractSmart(contractAddress, { balance: { address } });\n      return result.balance;\n    };\n\n    const allowance = async (owner: string, spender: string): Promise<AllowanceResponse> => {\n      return client.queryContractSmart(contractAddress, { allowance: { owner, spender } });\n    };\n\n    const allAllowances = async (\n      owner: string,\n      startAfter?: string,\n      limit?: number,\n    ): Promise<AllAllowancesResponse> => {\n      return client.queryContractSmart(contractAddress, {\n        all_allowances: { owner, start_after: startAfter, limit },\n      });\n    };\n\n    const allAccounts = async (startAfter?: string, limit?: number): Promise<readonly string[]> => {\n      const accounts: AllAccountsResponse = await client.queryContractSmart(contractAddress, {\n        all_accounts: { start_after: startAfter, limit },\n      });\n      return accounts.accounts;\n    };\n\n    const tokenInfo = async (): Promise<TokenInfo> => {\n      return client.queryContractSmart(contractAddress, { token_info: {} });\n    };\n\n    const investment = async (): Promise<Investment> => {\n      return client.queryContractSmart(contractAddress, { investment: {} });\n    };\n\n    const claims = async (address: string): Promise<Claims> => {\n      return client.queryContractSmart(contractAddress, { claims: { address } });\n    };\n\n    const minter = async (): Promise<any> => {\n      return client.queryContractSmart(contractAddress, { minter: {} });\n    };\n\n    // mints tokens, returns transactionHash\n    const mint = async (sender: string, recipient: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { mint: { recipient, amount } });\n      return result.transactionHash;\n    };\n\n    // transfers tokens, returns transactionHash\n    const transfer = async (sender: string, recipient: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { transfer: { recipient, amount } });\n      return result.transactionHash;\n    };\n\n    // burns tokens, returns transactionHash\n    const burn = async (sender: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { burn: { amount } });\n      return result.transactionHash;\n    };\n\n    const increaseAllowance = async (sender: string, spender: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, {\n        increase_allowance: { spender, amount },\n      });\n      return result.transactionHash;\n    };\n\n    const decreaseAllowance = async (sender: string, spender: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, {\n        decrease_allowance: { spender, amount },\n      });\n      return result.transactionHash;\n    };\n\n    const transferFrom = async (\n      sender: string,\n      owner: string,\n      recipient: string,\n      amount: string,\n    ): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, {\n        transfer_from: { owner, recipient, amount },\n      });\n      return result.transactionHash;\n    };\n\n    const bond = async (sender: string, coin: Coin): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { bond: {} }, undefined, [coin]);\n      return result.transactionHash;\n    };\n\n    const unbond = async (sender: string, amount: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { unbond: { amount } });\n      return result.transactionHash;\n    };\n\n    const claim = async (sender: string): Promise<string> => {\n      const result = await client.execute(sender, contractAddress, { claim: {} });\n      return result.transactionHash;\n    };\n\n    return {\n      contractAddress,\n      balance,\n      allowance,\n      allAllowances,\n      allAccounts,\n      tokenInfo,\n      investment,\n      claims,\n      minter,\n      mint,\n      transfer,\n      burn,\n      increaseAllowance,\n      decreaseAllowance,\n      transferFrom,\n      bond,\n      unbond,\n      claim,\n    };\n  };\n  return { use };\n};\n","import * as React from \"react\";\n\ninterface ErrorContextType {\n  readonly error?: string;\n  readonly setError: (error: string) => void;\n  readonly clearError: () => void;\n}\n\nconst defaultContext: ErrorContextType = {\n  setError: () => {\n    return;\n  },\n  clearError: () => {\n    return;\n  },\n};\n\nconst ErrorContext = React.createContext<ErrorContextType>(defaultContext);\n\nexport const useError = (): ErrorContextType => React.useContext(ErrorContext);\n\nexport function ErrorProvider({ children }: React.HTMLAttributes<HTMLOrSVGElement>): JSX.Element {\n  const [error, setError] = React.useState<string>();\n\n  const context: ErrorContextType = {\n    error: error,\n    setError: setError,\n    clearError: () => {\n      setError(undefined);\n    },\n  };\n\n  return <ErrorContext.Provider value={context}>{children}</ErrorContext.Provider>;\n}\n","import { CosmWasmFeeTable } from \"@cosmjs/cosmwasm-stargate\";\nimport { SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nimport { Bip39, Random } from \"@cosmjs/crypto\";\nimport { defaultGasLimits as defaultStargateGasLimits, GasLimits, GasPrice, makeCosmoshubPath, } from \"@cosmjs/stargate\";\nimport { DirectSecp256k1HdWallet, OfflineSigner } from \"@cosmjs/proto-signing\";\nimport { LedgerSigner } from \"@cosmjs/ledger-amino\";\nimport {\n  DistributionExtension,\n  QueryClient,\n  setupDistributionExtension,\n  setupStakingExtension,\n  StakingExtension,\n} from \"@cosmjs/stargate\";\nimport { Tendermint34Client } from \"@cosmjs/tendermint-rpc\";\nimport TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\nimport { AppConfig } from \"../config\";\n\n// generateMnemonic will give you a fresh mnemonic\n// it is up to the app to store this somewhere\nexport function generateMnemonic(): string {\n  return Bip39.encode(Random.getBytes(16)).toString();\n}\n\n// some code that will only work in a browser...\nexport function loadOrCreateMnemonic(): string {\n  const key = \"burner-wallet\";\n  const loaded = localStorage.getItem(key);\n  if (loaded) {\n    return loaded;\n  }\n  const generated = generateMnemonic();\n  localStorage.setItem(key, generated);\n  return generated;\n}\n\nexport type WalletLoader = (chainId: string, addressPrefix?: string) => Promise<OfflineSigner>;\n\nexport async function loadOrCreateWallet(_chainId: string, addressPrefix?: string): Promise<OfflineSigner> {\n  const mnemonic = loadOrCreateMnemonic();\n  const hdPath = makeCosmoshubPath(0);\n  const wallet = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n    hdPaths: [hdPath],\n    prefix: addressPrefix\n  });\n  return wallet;\n}\n\nexport async function loadLedgerWallet(_chainId: string, addressPrefix?: string): Promise<OfflineSigner> {\n  const interactiveTimeout = 120_000;\n  const ledgerTransport = await TransportWebUSB.create(interactiveTimeout, interactiveTimeout);\n\n  return new LedgerSigner(ledgerTransport, { hdPaths: [makeCosmoshubPath(0)], prefix: addressPrefix });\n}\n\nexport async function loadKeplrWallet(chainId: string): Promise<OfflineSigner> {\n  const anyWindow: any = window;\n  if (!anyWindow.getOfflineSigner) {\n    throw new Error(\"Keplr extension is not available\");\n  }\n\n  const signer = anyWindow.getOfflineSigner(chainId);\n  signer.signAmino = signer.signAmino ?? signer.sign;\n\n  return Promise.resolve(signer);\n}\n\n// this creates a new connection to a server at URL,\n// using a signing keyring generated from the given mnemonic\nexport async function createClient(config: AppConfig, signer: OfflineSigner): Promise<SigningCosmWasmClient> {\n  const gasLimits: GasLimits<CosmWasmFeeTable> = {\n    ...defaultStargateGasLimits,\n    upload: 1500000,\n    init: 600000,\n    exec: 400000,\n    migrate: 600000,\n    send: 80000,\n    changeAdmin: 80000,\n  };\n\n  return SigningCosmWasmClient.connectWithSigner(config.rpcUrl, signer, {\n    prefix: config.addressPrefix,\n    gasPrice: GasPrice.fromString(`${config.gasPrice}${config.feeToken}`),\n    gasLimits: gasLimits,\n  });\n}\n\nexport async function createStakingClient(\n  apiUrl: string,\n): Promise<QueryClient & StakingExtension & DistributionExtension> {\n  const tmClient = await Tendermint34Client.connect(apiUrl);\n  return QueryClient.withExtensions(tmClient, setupStakingExtension, setupDistributionExtension);\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { SigningCosmWasmClient } from \"@cosmjs/cosmwasm-stargate\";\nimport { FaucetClient } from \"@cosmjs/faucet-client\";\nimport { Coin } from \"@cosmjs/stargate\";\nimport { OfflineSigner } from \"@cosmjs/proto-signing\";\nimport { QueryClient, StakingExtension, DistributionExtension } from \"@cosmjs/stargate\";\nimport * as React from \"react\";\nimport { useEffect, useState } from \"react\";\nimport { AppConfig } from \"../config\";\nimport { useError } from \"./error\";\nimport { createClient, createStakingClient } from \"./sdk\";\n\ninterface CosmWasmContextType {\n  readonly initialized: boolean;\n  readonly init: (signer: OfflineSigner) => void;\n  readonly clear: () => void;\n  readonly config: Partial<AppConfig>;\n  readonly changeConfig: (updates: Partial<AppConfig>) => void;\n  readonly address: string;\n  readonly balance: readonly Coin[];\n  readonly refreshBalance: () => Promise<void>;\n  readonly hitFaucet: () => Promise<void>;\n  readonly getSigner: () => OfflineSigner;\n  readonly changeSigner: (newSigner: OfflineSigner) => void;\n  readonly getClient: () => SigningCosmWasmClient;\n  readonly getStakingClient: () => QueryClient & StakingExtension & DistributionExtension;\n}\n\nfunction throwNotInitialized(): any {\n  throw new Error(\"Not yet initialized\");\n}\n\nconst defaultContext: CosmWasmContextType = {\n  initialized: false,\n  init: throwNotInitialized,\n  clear: throwNotInitialized,\n  config: {},\n  changeConfig: throwNotInitialized,\n  address: \"\",\n  balance: [],\n  refreshBalance: throwNotInitialized,\n  hitFaucet: throwNotInitialized,\n  getSigner: throwNotInitialized,\n  changeSigner: throwNotInitialized,\n  getClient: throwNotInitialized,\n  getStakingClient: throwNotInitialized,\n};\n\nconst CosmWasmContext = React.createContext<CosmWasmContextType>(defaultContext);\n\nexport const useSdk = (): CosmWasmContextType => React.useContext(CosmWasmContext);\n\ninterface SdkProviderProps extends React.HTMLAttributes<HTMLOrSVGElement> {\n  readonly config: AppConfig;\n}\n\nexport function SdkProvider({ config: configProp, children }: SdkProviderProps): JSX.Element {\n  const { setError } = useError();\n\n  const [config, setConfig] = useState(configProp);\n  const [signer, setSigner] = useState<OfflineSigner>();\n  const [client, setClient] = useState<SigningCosmWasmClient>();\n\n  const contextWithInit = { ...defaultContext, init: setSigner };\n  const [value, setValue] = useState<CosmWasmContextType>(contextWithInit);\n\n  function clear(): void {\n    setValue({ ...contextWithInit });\n    setClient(undefined);\n    setSigner(undefined);\n    setConfig(configProp);\n  }\n\n  function changeConfig(updates: Partial<AppConfig>): void {\n    setConfig((config) => ({ ...config, ...updates }));\n  }\n\n  // Get balance for each coin specified in config.coinMap\n  async function refreshBalance(address: string, balance: Coin[]): Promise<void> {\n    if (!client) return;\n\n    balance.length = 0;\n    for (const denom in config.coinMap) {\n      const coin = await client.getBalance(address, denom);\n      if (coin) balance.push(coin);\n    }\n  }\n\n  // Get feeToken balance from faucet\n  async function hitFaucet(address: string): Promise<void> {\n    if (!config.faucetUrl || !config.feeToken) return;\n\n    try {\n      const faucet = new FaucetClient(config.faucetUrl);\n      await faucet.credit(address, config.feeToken);\n    } catch (error) {\n      setError(error.message);\n      console.error(error);\n    }\n  }\n\n  useEffect(() => {\n    if (!signer) return;\n\n    (async function updateClient(): Promise<void> {\n      try {\n        const client = await createClient(config, signer);\n        setClient(client);\n      } catch (error) {\n        setError(error.message);\n      }\n    })();\n  }, [signer, config]);\n\n  useEffect(() => {\n    if (!signer || !client) return;\n\n    const balance: Coin[] = [];\n\n    (async function updateValue(): Promise<void> {\n      const address = (await signer.getAccounts())[0].address;\n\n      await refreshBalance(address, balance);\n      if (!balance.find((coin) => coin.denom === config.feeToken)) {\n        await hitFaucet(address);\n      }\n      await refreshBalance(address, balance);\n\n      const stakingClient = await createStakingClient(config.rpcUrl);\n\n      setValue({\n        initialized: true,\n        init: () => {},\n        clear,\n        config,\n        changeConfig,\n        address,\n        balance,\n        refreshBalance: refreshBalance.bind(null, address, balance),\n        hitFaucet: hitFaucet.bind(null, address),\n        getSigner: () => signer,\n        changeSigner: setSigner,\n        getClient: () => client,\n        getStakingClient: () => stakingClient,\n      });\n    })();\n  }, [client]);\n\n  return <CosmWasmContext.Provider value={value}>{children}</CosmWasmContext.Provider>;\n}\n","import React from \"react\";\nimport { Redirect, Switch, SwitchProps } from \"react-router-dom\";\nimport { useSdk } from \"./wallet\";\n\nexport interface RedirectLocation {\n  readonly redirectPathname: string;\n  readonly redirectState: any;\n}\n\ninterface ProtectedSwitchProps extends SwitchProps {\n  readonly authPath: string;\n}\n\nexport function ProtectedSwitch({ authPath, children, location }: ProtectedSwitchProps): JSX.Element {\n  const { initialized } = useSdk();\n\n  return initialized ? (\n    <Switch location={location}>{children}</Switch>\n  ) : (\n    <Redirect\n      to={{\n        pathname: authPath,\n        state: location ? { redirectPathname: location.pathname, redirectState: location.state } : undefined,\n      }}\n    />\n  );\n}\n","import { Coin } from \"@cosmjs/stargate\";\nimport { Decimal } from \"@cosmjs/math\";\n\n// NARROW NO-BREAK SPACE (U+202F)\nconst thinSpace = \"\\u202F\";\n\nexport function printableCoin(coin?: Coin): string {\n  if (!coin) {\n    return \"0\";\n  }\n  if (coin.denom.startsWith(\"u\")) {\n    const ticker = coin.denom.slice(1).toUpperCase();\n    return Decimal.fromAtomics(coin.amount, 6).toString() + thinSpace + ticker;\n  } else {\n    return coin.amount + thinSpace + coin.denom;\n  }\n}\n\nexport function printableBalance(balance?: readonly Coin[]): string {\n  if (!balance || balance.length === 0) return \"–\";\n  return balance.map(printableCoin).join(\", \");\n}\n\nexport interface MappedCoin {\n  readonly denom: string;\n  readonly fractionalDigits: number;\n}\n\nexport interface CoinMap {\n  readonly [key: string]: MappedCoin;\n}\n\nexport function nativeCoinToDisplay(coin: Coin, coinMap: CoinMap): Coin {\n  if (!coinMap) return coin;\n\n  const coinToDisplay = coinMap[coin.denom];\n  if (!coinToDisplay) return coin;\n\n  const amountToDisplay = Decimal.fromAtomics(coin.amount, coinToDisplay.fractionalDigits).toString();\n\n  return { denom: coinToDisplay.denom, amount: amountToDisplay };\n}\n\n// display amount is eg \"12.0346\", return is in native tokens\n// with 6 fractional digits, this would be eg. \"12034600\"\nexport function displayAmountToNative(\n  amountToDisplay: string,\n  coinMap: CoinMap,\n  nativeDenom: string,\n): string {\n  const fractionalDigits = coinMap[nativeDenom]?.fractionalDigits;\n  if (fractionalDigits) {\n    // use https://github.com/CosmWasm/cosmjs/blob/v0.22.2/packages/math/src/decimal.ts\n    const decimalAmount = Decimal.fromUserInput(amountToDisplay, fractionalDigits);\n    return decimalAmount.atomics;\n  }\n\n  return amountToDisplay;\n}\n","// Get string error from operation stack trace. Matches last line but removes last \"message index\" part\nexport function getErrorFromStackTrace(stackTrace: any): string {\n  const stringStackTrace = (stackTrace || \"\").toString();\n  const match = stringStackTrace.match(/.*\\s*$/g)[0];\n  const error = match.substring(0, match.lastIndexOf(\";\"));\n\n  return error || stringStackTrace;\n}\n"]},"metadata":{},"sourceType":"module"}