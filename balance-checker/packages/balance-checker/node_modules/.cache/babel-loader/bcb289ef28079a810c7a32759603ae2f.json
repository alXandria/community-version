{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst build_1 = require(\"@cosmjs/utils/build\");\n\nconst signing_1 = require(\"./signing\");\n\nconst wallet_1 = require(\"./wallet\");\n\nconst serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nconst basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!build_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  const root = JSON.parse(serialization);\n  if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [amino_1.makeCosmoshubPath(0)],\n  prefix: \"cosmos\"\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\n\nclass DirectSecp256k1HdWallet {\n  constructor(mnemonic, options) {\n    var _a, _b;\n\n    const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n    const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(hdPath => ({\n      hdPath: hdPath,\n      prefix: prefix\n    }));\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async fromMnemonic(mnemonic, options = {}) {\n    const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n    const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n    return new DirectSecp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n      seed: seed\n    }));\n  }\n  /**\n   * Generates a new wallet with a BIP39 mnemonic of the given length.\n   *\n   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  static async generate(length = 12, options = {}) {\n    const entropyLength = 4 * Math.floor(11 * length / 33);\n    const entropy = crypto_1.Random.getBytes(entropyLength);\n    const mnemonic = crypto_1.Bip39.encode(entropy);\n    return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  static async deserialize(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n    switch (root.type) {\n      case serializationTypeV1:\n        return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n  /**\n   * Restores a wallet from an encrypted serialization.\n   *\n   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n   */\n\n\n  static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const untypedRoot = root;\n\n    switch (untypedRoot.type) {\n      case serializationTypeV1:\n        {\n          const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n          const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n          const {\n            mnemonic,\n            accounts\n          } = decryptedDocument;\n          build_1.assert(typeof mnemonic === \"string\");\n          if (!Array.isArray(accounts)) throw new Error(\"Property 'accounts' is not an array\");\n\n          if (!accounts.every(account => isDerivationJson(account))) {\n            throw new Error(\"Account is not in the correct format.\");\n          }\n\n          const firstPrefix = accounts[0].prefix;\n\n          if (!accounts.every(({\n            prefix\n          }) => prefix === firstPrefix)) {\n            throw new Error(\"Accounts do not all have the same prefix\");\n          }\n\n          const hdPaths = accounts.map(({\n            hdPath\n          }) => crypto_1.stringToPath(hdPath));\n          return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n            hdPaths: hdPaths,\n            prefix: firstPrefix\n          });\n        }\n\n      default:\n        throw new Error(\"Unsupported serialization type\");\n    }\n  }\n\n  static async deserializeTypeV1(serialization, password) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n    const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n    return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n  }\n\n  get mnemonic() {\n    return this.secret.toString();\n  }\n\n  async getAccounts() {\n    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n    return accountsWithPrivkeys.map(({\n      algo,\n      pubkey,\n      address\n    }) => ({\n      algo: algo,\n      pubkey: pubkey,\n      address: address\n    }));\n  }\n\n  async signDirect(signerAddress, signDoc) {\n    const accounts = await this.getAccountsWithPrivkeys();\n    const account = accounts.find(({\n      address\n    }) => address === signerAddress);\n\n    if (account === undefined) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const {\n      privkey,\n      pubkey\n    } = account;\n    const signBytes = signing_1.makeSignBytes(signDoc);\n    const hashedMessage = crypto_1.sha256(signBytes);\n    const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n    const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n    const stdSignature = amino_1.encodeSecp256k1Signature(pubkey, signatureBytes);\n    return {\n      signed: signDoc,\n      signature: stdSignature\n    };\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * @param password The user provided password used to generate an encryption key via a KDF.\n   *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n   */\n\n\n  async serialize(password) {\n    const kdfConfiguration = basicPasswordHashingOptions;\n    const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n  }\n  /**\n   * Generates an encrypted serialization of this wallet.\n   *\n   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n   *\n   * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n   * is not the case, the wallet cannot be restored with the original password.\n   */\n\n\n  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n    const dataToEncrypt = {\n      mnemonic: this.mnemonic,\n      accounts: this.accounts.map(({\n        hdPath,\n        prefix\n      }) => ({\n        hdPath: crypto_1.pathToString(hdPath),\n        prefix: prefix\n      }))\n    };\n    const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n    const encryptionConfiguration = {\n      algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n    };\n    const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n    const out = {\n      type: serializationTypeV1,\n      kdf: kdfConfiguration,\n      encryption: encryptionConfiguration,\n      data: encoding_1.toBase64(encryptedData)\n    };\n    return JSON.stringify(out);\n  }\n\n  async getKeyPair(hdPath) {\n    const {\n      privkey\n    } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n    const {\n      pubkey\n    } = await crypto_1.Secp256k1.makeKeypair(privkey);\n    return {\n      privkey: privkey,\n      pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n    };\n  }\n\n  async getAccountsWithPrivkeys() {\n    return Promise.all(this.accounts.map(async ({\n      hdPath,\n      prefix\n    }) => {\n      const {\n        privkey,\n        pubkey\n      } = await this.getKeyPair(hdPath);\n      const address = encoding_1.Bech32.encode(prefix, amino_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n      return {\n        algo: \"secp256k1\",\n        privkey: privkey,\n        pubkey: pubkey,\n        address: address\n      };\n    }));\n  }\n\n}\n\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;","map":{"version":3,"sources":["../src/directsecp256k1hdwallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst build_1 = require(\"@cosmjs/utils/build\");\nconst signing_1 = require(\"./signing\");\nconst wallet_1 = require(\"./wallet\");\nconst serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\nconst basicPasswordHashingOptions = {\n    algorithm: \"argon2id\",\n    params: {\n        outputLength: 32,\n        opsLimit: 24,\n        memLimitKib: 12 * 1024,\n    },\n};\nfunction isDerivationJson(thing) {\n    if (!build_1.isNonNullObject(thing))\n        return false;\n    if (typeof thing.hdPath !== \"string\")\n        return false;\n    if (typeof thing.prefix !== \"string\")\n        return false;\n    return true;\n}\nfunction extractKdfConfigurationV1(doc) {\n    return doc.kdf;\n}\nfunction extractKdfConfiguration(serialization) {\n    const root = JSON.parse(serialization);\n    if (!build_1.isNonNullObject(root))\n        throw new Error(\"Root document is not an object.\");\n    switch (root.type) {\n        case serializationTypeV1:\n            return extractKdfConfigurationV1(root);\n        default:\n            throw new Error(\"Unsupported serialization type\");\n    }\n}\nexports.extractKdfConfiguration = extractKdfConfiguration;\nconst defaultOptions = {\n    bip39Password: \"\",\n    hdPaths: [amino_1.makeCosmoshubPath(0)],\n    prefix: \"cosmos\",\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\nclass DirectSecp256k1HdWallet {\n    constructor(mnemonic, options) {\n        var _a, _b;\n        const prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n        const hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n        this.secret = mnemonic;\n        this.seed = options.seed;\n        this.accounts = hdPaths.map((hdPath) => ({\n            hdPath: hdPath,\n            prefix: prefix,\n        }));\n    }\n    /**\n     * Restores a wallet from the given BIP39 mnemonic.\n     *\n     * @param mnemonic Any valid English mnemonic.\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async fromMnemonic(mnemonic, options = {}) {\n        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n        return new DirectSecp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), { seed: seed }));\n    }\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n    static async generate(length = 12, options = {}) {\n        const entropyLength = 4 * Math.floor((11 * length) / 33);\n        const entropy = crypto_1.Random.getBytes(entropyLength);\n        const mnemonic = crypto_1.Bip39.encode(entropy);\n        return DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    static async deserialize(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!build_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        switch (root.type) {\n            case serializationTypeV1:\n                return DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n    static async deserializeWithEncryptionKey(serialization, encryptionKey) {\n        const root = JSON.parse(serialization);\n        if (!build_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        const untypedRoot = root;\n        switch (untypedRoot.type) {\n            case serializationTypeV1: {\n                const decryptedBytes = await wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n                const decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n                const { mnemonic, accounts } = decryptedDocument;\n                build_1.assert(typeof mnemonic === \"string\");\n                if (!Array.isArray(accounts))\n                    throw new Error(\"Property 'accounts' is not an array\");\n                if (!accounts.every((account) => isDerivationJson(account))) {\n                    throw new Error(\"Account is not in the correct format.\");\n                }\n                const firstPrefix = accounts[0].prefix;\n                if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {\n                    throw new Error(\"Accounts do not all have the same prefix\");\n                }\n                const hdPaths = accounts.map(({ hdPath }) => crypto_1.stringToPath(hdPath));\n                return DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n                    hdPaths: hdPaths,\n                    prefix: firstPrefix,\n                });\n            }\n            default:\n                throw new Error(\"Unsupported serialization type\");\n        }\n    }\n    static async deserializeTypeV1(serialization, password) {\n        const root = JSON.parse(serialization);\n        if (!build_1.isNonNullObject(root))\n            throw new Error(\"Root document is not an object.\");\n        const encryptionKey = await wallet_1.executeKdf(password, root.kdf);\n        return DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);\n    }\n    get mnemonic() {\n        return this.secret.toString();\n    }\n    async getAccounts() {\n        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();\n        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({\n            algo: algo,\n            pubkey: pubkey,\n            address: address,\n        }));\n    }\n    async signDirect(signerAddress, signDoc) {\n        const accounts = await this.getAccountsWithPrivkeys();\n        const account = accounts.find(({ address }) => address === signerAddress);\n        if (account === undefined) {\n            throw new Error(`Address ${signerAddress} not found in wallet`);\n        }\n        const { privkey, pubkey } = account;\n        const signBytes = signing_1.makeSignBytes(signDoc);\n        const hashedMessage = crypto_1.sha256(signBytes);\n        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);\n        const stdSignature = amino_1.encodeSecp256k1Signature(pubkey, signatureBytes);\n        return {\n            signed: signDoc,\n            signature: stdSignature,\n        };\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n    async serialize(password) {\n        const kdfConfiguration = basicPasswordHashingOptions;\n        const encryptionKey = await wallet_1.executeKdf(password, kdfConfiguration);\n        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);\n    }\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n    async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {\n        const dataToEncrypt = {\n            mnemonic: this.mnemonic,\n            accounts: this.accounts.map(({ hdPath, prefix }) => ({\n                hdPath: crypto_1.pathToString(hdPath),\n                prefix: prefix,\n            })),\n        };\n        const dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n        const encryptionConfiguration = {\n            algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf,\n        };\n        const encryptedData = await wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n        const out = {\n            type: serializationTypeV1,\n            kdf: kdfConfiguration,\n            encryption: encryptionConfiguration,\n            data: encoding_1.toBase64(encryptedData),\n        };\n        return JSON.stringify(out);\n    }\n    async getKeyPair(hdPath) {\n        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);\n        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);\n        return {\n            privkey: privkey,\n            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey),\n        };\n    }\n    async getAccountsWithPrivkeys() {\n        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {\n            const { privkey, pubkey } = await this.getKeyPair(hdPath);\n            const address = encoding_1.Bech32.encode(prefix, amino_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n            return {\n                algo: \"secp256k1\",\n                privkey: privkey,\n                pubkey: pubkey,\n                address: address,\n            };\n        }));\n    }\n}\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;\n//# sourceMappingURL=directsecp256k1hdwallet.js.map"]},"metadata":{},"sourceType":"script"}