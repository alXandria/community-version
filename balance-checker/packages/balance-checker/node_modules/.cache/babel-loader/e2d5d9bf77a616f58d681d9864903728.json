{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = void 0;\n\nconst xstream_1 = require(\"xstream\");\n/**\n * An implementation of concat that buffers all source stream events\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * -a--b-c--d-|\n * --------X---------Y---------Z-\n *           concat\n * --1--2---3---4-abcdXY-------Z-\n * ```\n *\n * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves\n * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.\n *\n */\n\n\nfunction concat(...streams) {\n  const subscriptions = new Array();\n  const queues = new Array(); // one queue per stream\n\n  const completedStreams = new Set();\n  let activeStreamIndex = 0;\n\n  function reset() {\n    while (subscriptions.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const subscription = subscriptions.shift();\n      subscription.unsubscribe();\n    }\n\n    queues.length = 0;\n    completedStreams.clear();\n    activeStreamIndex = 0;\n  }\n\n  const producer = {\n    start: listener => {\n      streams.forEach(_ => queues.push([]));\n\n      function emitAllQueuesEvents(streamIndex) {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const element = queues[streamIndex].shift();\n\n          if (element === undefined) {\n            return;\n          }\n\n          listener.next(element);\n        }\n      }\n\n      function isDone() {\n        return activeStreamIndex >= streams.length;\n      }\n\n      if (isDone()) {\n        listener.complete();\n        return;\n      }\n\n      streams.forEach((stream, index) => {\n        subscriptions.push(stream.subscribe({\n          next: value => {\n            if (index === activeStreamIndex) {\n              listener.next(value);\n            } else {\n              queues[index].push(value);\n            }\n          },\n          complete: () => {\n            completedStreams.add(index);\n\n            while (completedStreams.has(activeStreamIndex)) {\n              // this stream completed: emit all and move on\n              emitAllQueuesEvents(activeStreamIndex);\n              activeStreamIndex++;\n            }\n\n            if (isDone()) {\n              listener.complete();\n            } else {\n              // now active stream can have some events queued but did not yet complete\n              emitAllQueuesEvents(activeStreamIndex);\n            }\n          },\n          error: error => {\n            listener.error(error);\n            reset();\n          }\n        }));\n      });\n    },\n    stop: () => {\n      reset();\n    }\n  };\n  return xstream_1.Stream.create(producer);\n}\n\nexports.concat = concat;","map":{"version":3,"sources":["../src/concat.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;AAiBA,SAAgB,MAAhB,CAA0B,GAAG,OAA7B,EAAsD;AACpD,QAAM,aAAa,GAAG,IAAI,KAAJ,EAAtB;AACA,QAAM,MAAM,GAAG,IAAI,KAAJ,EAAf,CAFoD,CAEnB;;AACjC,QAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB;AACA,MAAI,iBAAiB,GAAG,CAAxB;;AAEA,WAAS,KAAT,GAAc;AACZ,WAAO,aAAa,CAAC,MAAd,GAAuB,CAA9B,EAAiC;AAC/B;AACA,YAAM,YAAY,GAAG,aAAa,CAAC,KAAd,EAArB;AACA,MAAA,YAAY,CAAC,WAAb;AACD;;AAED,IAAA,MAAM,CAAC,MAAP,GAAgB,CAAhB;AACA,IAAA,gBAAgB,CAAC,KAAjB;AACA,IAAA,iBAAiB,GAAG,CAApB;AACD;;AAED,QAAM,QAAQ,GAAgB;AAC5B,IAAA,KAAK,EAAG,QAAD,IAAa;AAClB,MAAA,OAAO,CAAC,OAAR,CAAiB,CAAD,IAAO,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAvB;;AAEA,eAAS,mBAAT,CAA6B,WAA7B,EAAgD;AAC9C;AACA,eAAO,IAAP,EAAa;AACX,gBAAM,OAAO,GAAG,MAAM,CAAC,WAAD,CAAN,CAAoB,KAApB,EAAhB;;AACA,cAAI,OAAO,KAAK,SAAhB,EAA2B;AACzB;AACD;;AACD,UAAA,QAAQ,CAAC,IAAT,CAAc,OAAd;AACD;AACF;;AAED,eAAS,MAAT,GAAe;AACb,eAAO,iBAAiB,IAAI,OAAO,CAAC,MAApC;AACD;;AAED,UAAI,MAAM,EAAV,EAAc;AACZ,QAAA,QAAQ,CAAC,QAAT;AACA;AACD;;AAED,MAAA,OAAO,CAAC,OAAR,CAAgB,CAAC,MAAD,EAAS,KAAT,KAAkB;AAChC,QAAA,aAAa,CAAC,IAAd,CACE,MAAM,CAAC,SAAP,CAAiB;AACf,UAAA,IAAI,EAAG,KAAD,IAAU;AACd,gBAAI,KAAK,KAAK,iBAAd,EAAiC;AAC/B,cAAA,QAAQ,CAAC,IAAT,CAAc,KAAd;AACD,aAFD,MAEO;AACL,cAAA,MAAM,CAAC,KAAD,CAAN,CAAc,IAAd,CAAmB,KAAnB;AACD;AACF,WAPc;AAQf,UAAA,QAAQ,EAAE,MAAK;AACb,YAAA,gBAAgB,CAAC,GAAjB,CAAqB,KAArB;;AAEA,mBAAO,gBAAgB,CAAC,GAAjB,CAAqB,iBAArB,CAAP,EAAgD;AAC9C;AACA,cAAA,mBAAmB,CAAC,iBAAD,CAAnB;AACA,cAAA,iBAAiB;AAClB;;AAED,gBAAI,MAAM,EAAV,EAAc;AACZ,cAAA,QAAQ,CAAC,QAAT;AACD,aAFD,MAEO;AACL;AACA,cAAA,mBAAmB,CAAC,iBAAD,CAAnB;AACD;AACF,WAvBc;AAwBf,UAAA,KAAK,EAAG,KAAD,IAAU;AACf,YAAA,QAAQ,CAAC,KAAT,CAAe,KAAf;AACA,YAAA,KAAK;AACN;AA3Bc,SAAjB,CADF;AA+BD,OAhCD;AAiCD,KAzD2B;AA0D5B,IAAA,IAAI,EAAE,MAAK;AACT,MAAA,KAAK;AACN;AA5D2B,GAA9B;AA+DA,SAAO,SAAA,CAAA,MAAA,CAAO,MAAP,CAAc,QAAd,CAAP;AACD;;AAlFD,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concat = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * An implementation of concat that buffers all source stream events\n *\n * Marble diagram:\n *\n * ```text\n * --1--2---3---4-|\n * -a--b-c--d-|\n * --------X---------Y---------Z-\n *           concat\n * --1--2---3---4-abcdXY-------Z-\n * ```\n *\n * This is inspired by RxJS's concat as documented at http://rxmarbles.com/#concat and behaves\n * differently than xstream's concat as discussed in https://github.com/staltz/xstream/issues/170.\n *\n */\nfunction concat(...streams) {\n    const subscriptions = new Array();\n    const queues = new Array(); // one queue per stream\n    const completedStreams = new Set();\n    let activeStreamIndex = 0;\n    function reset() {\n        while (subscriptions.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const subscription = subscriptions.shift();\n            subscription.unsubscribe();\n        }\n        queues.length = 0;\n        completedStreams.clear();\n        activeStreamIndex = 0;\n    }\n    const producer = {\n        start: (listener) => {\n            streams.forEach((_) => queues.push([]));\n            function emitAllQueuesEvents(streamIndex) {\n                // eslint-disable-next-line no-constant-condition\n                while (true) {\n                    const element = queues[streamIndex].shift();\n                    if (element === undefined) {\n                        return;\n                    }\n                    listener.next(element);\n                }\n            }\n            function isDone() {\n                return activeStreamIndex >= streams.length;\n            }\n            if (isDone()) {\n                listener.complete();\n                return;\n            }\n            streams.forEach((stream, index) => {\n                subscriptions.push(stream.subscribe({\n                    next: (value) => {\n                        if (index === activeStreamIndex) {\n                            listener.next(value);\n                        }\n                        else {\n                            queues[index].push(value);\n                        }\n                    },\n                    complete: () => {\n                        completedStreams.add(index);\n                        while (completedStreams.has(activeStreamIndex)) {\n                            // this stream completed: emit all and move on\n                            emitAllQueuesEvents(activeStreamIndex);\n                            activeStreamIndex++;\n                        }\n                        if (isDone()) {\n                            listener.complete();\n                        }\n                        else {\n                            // now active stream can have some events queued but did not yet complete\n                            emitAllQueuesEvents(activeStreamIndex);\n                        }\n                    },\n                    error: (error) => {\n                        listener.error(error);\n                        reset();\n                    },\n                }));\n            });\n        },\n        stop: () => {\n            reset();\n        },\n    };\n    return xstream_1.Stream.create(producer);\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map"]},"metadata":{},"sourceType":"script"}