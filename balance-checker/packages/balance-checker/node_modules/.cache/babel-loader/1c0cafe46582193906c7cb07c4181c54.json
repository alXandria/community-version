{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LedgerSigner = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst launchpadledger_1 = require(\"./launchpadledger\");\n\nclass LedgerSigner {\n  constructor(transport, options = {}) {\n    this.hdPaths = options.hdPaths || [amino_1.makeCosmoshubPath(0)];\n    this.ledger = new launchpadledger_1.LaunchpadLedger(transport, options);\n  }\n\n  async getAccounts() {\n    if (!this.accounts) {\n      const pubkeys = await this.ledger.getPubkeys();\n      this.accounts = await Promise.all(pubkeys.map(async pubkey => ({\n        algo: \"secp256k1\",\n        address: await this.ledger.getCosmosAddress(pubkey),\n        pubkey: pubkey\n      })));\n    }\n\n    return this.accounts;\n  }\n\n  async signAmino(signerAddress, signDoc) {\n    const accounts = this.accounts || (await this.getAccounts());\n    const accountIndex = accounts.findIndex(account => account.address === signerAddress);\n\n    if (accountIndex === -1) {\n      throw new Error(`Address ${signerAddress} not found in wallet`);\n    }\n\n    const message = amino_1.serializeSignDoc(signDoc);\n    const accountForAddress = accounts[accountIndex];\n    const hdPath = this.hdPaths[accountIndex];\n    const signature = await this.ledger.sign(message, hdPath);\n    return {\n      signed: signDoc,\n      signature: amino_1.encodeSecp256k1Signature(accountForAddress.pubkey, signature)\n    };\n  }\n\n}\n\nexports.LedgerSigner = LedgerSigner;","map":{"version":3,"sources":["../src/ledgersigner.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAYA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,MAAa,YAAb,CAAyB;AAKvB,EAAA,WAAA,CAAmB,SAAnB,EAAyC,OAAA,GAAkC,EAA3E,EAA6E;AAC3E,SAAK,OAAL,GAAe,OAAO,CAAC,OAAR,IAAmB,CAAC,OAAA,CAAA,iBAAA,CAAkB,CAAlB,CAAD,CAAlC;AACA,SAAK,MAAL,GAAc,IAAI,iBAAA,CAAA,eAAJ,CAAoB,SAApB,EAA+B,OAA/B,CAAd;AACD;;AAEM,QAAM,WAAN,GAAiB;AACtB,QAAI,CAAC,KAAK,QAAV,EAAoB;AAClB,YAAM,OAAO,GAAG,MAAM,KAAK,MAAL,CAAY,UAAZ,EAAtB;AACA,WAAK,QAAL,GAAgB,MAAM,OAAO,CAAC,GAAR,CACpB,OAAO,CAAC,GAAR,CAAY,MAAO,MAAP,KAAmB;AAC7B,QAAA,IAAI,EAAE,WADuB;AAE7B,QAAA,OAAO,EAAE,MAAM,KAAK,MAAL,CAAY,gBAAZ,CAA6B,MAA7B,CAFc;AAG7B,QAAA,MAAM,EAAE;AAHqB,OAAnB,CAAZ,CADoB,CAAtB;AAOD;;AAED,WAAO,KAAK,QAAZ;AACD;;AAEM,QAAM,SAAN,CAAgB,aAAhB,EAAuC,OAAvC,EAA0D;AAC/D,UAAM,QAAQ,GAAG,KAAK,QAAL,KAAkB,MAAM,KAAK,WAAL,EAAxB,CAAjB;AACA,UAAM,YAAY,GAAG,QAAQ,CAAC,SAAT,CAAoB,OAAD,IAAa,OAAO,CAAC,OAAR,KAAoB,aAApD,CAArB;;AAEA,QAAI,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACvB,YAAM,IAAI,KAAJ,CAAU,WAAW,aAAa,sBAAlC,CAAN;AACD;;AAED,UAAM,OAAO,GAAG,OAAA,CAAA,gBAAA,CAAiB,OAAjB,CAAhB;AACA,UAAM,iBAAiB,GAAG,QAAQ,CAAC,YAAD,CAAlC;AACA,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,YAAb,CAAf;AACA,UAAM,SAAS,GAAG,MAAM,KAAK,MAAL,CAAY,IAAZ,CAAiB,OAAjB,EAA0B,MAA1B,CAAxB;AACA,WAAO;AACL,MAAA,MAAM,EAAE,OADH;AAEL,MAAA,SAAS,EAAE,OAAA,CAAA,wBAAA,CAAyB,iBAAiB,CAAC,MAA3C,EAAmD,SAAnD;AAFN,KAAP;AAID;;AAzCsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LedgerSigner = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst launchpadledger_1 = require(\"./launchpadledger\");\nclass LedgerSigner {\n    constructor(transport, options = {}) {\n        this.hdPaths = options.hdPaths || [amino_1.makeCosmoshubPath(0)];\n        this.ledger = new launchpadledger_1.LaunchpadLedger(transport, options);\n    }\n    async getAccounts() {\n        if (!this.accounts) {\n            const pubkeys = await this.ledger.getPubkeys();\n            this.accounts = await Promise.all(pubkeys.map(async (pubkey) => ({\n                algo: \"secp256k1\",\n                address: await this.ledger.getCosmosAddress(pubkey),\n                pubkey: pubkey,\n            })));\n        }\n        return this.accounts;\n    }\n    async signAmino(signerAddress, signDoc) {\n        const accounts = this.accounts || (await this.getAccounts());\n        const accountIndex = accounts.findIndex((account) => account.address === signerAddress);\n        if (accountIndex === -1) {\n            throw new Error(`Address ${signerAddress} not found in wallet`);\n        }\n        const message = amino_1.serializeSignDoc(signDoc);\n        const accountForAddress = accounts[accountIndex];\n        const hdPath = this.hdPaths[accountIndex];\n        const signature = await this.ledger.sign(message, hdPath);\n        return {\n            signed: signDoc,\n            signature: amino_1.encodeSecp256k1Signature(accountForAddress.pubkey, signature),\n        };\n    }\n}\nexports.LedgerSigner = LedgerSigner;\n//# sourceMappingURL=ledgersigner.js.map"]},"metadata":{},"sourceType":"script"}