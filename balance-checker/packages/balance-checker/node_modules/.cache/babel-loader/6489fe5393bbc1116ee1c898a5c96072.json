{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashBlock = exports.hashTx = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encodings_1 = require(\"./encodings\"); // hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\n\n\nfunction hashTx(tx) {\n  return crypto_1.sha256(tx);\n}\n\nexports.hashTx = hashTx;\n\nfunction getSplitPoint(n) {\n  if (n < 1) throw new Error(\"Cannot split an empty tree\");\n  const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));\n  return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\n\nfunction hashLeaf(leaf) {\n  const hash = new crypto_1.Sha256(Uint8Array.from([0]));\n  hash.update(leaf);\n  return hash.digest();\n}\n\nfunction hashInner(left, right) {\n  const hash = new crypto_1.Sha256(Uint8Array.from([1]));\n  hash.update(left);\n  hash.update(right);\n  return hash.digest();\n} // See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\n\n\nfunction hashTree(hashes) {\n  switch (hashes.length) {\n    case 0:\n      throw new Error(\"Cannot hash empty tree\");\n\n    case 1:\n      return hashLeaf(hashes[0]);\n\n    default:\n      {\n        const slicePoint = getSplitPoint(hashes.length);\n        const left = hashTree(hashes.slice(0, slicePoint));\n        const right = hashTree(hashes.slice(slicePoint));\n        return hashInner(left, right);\n      }\n  }\n}\n\nfunction hashBlock(header) {\n  const encodedFields = [encodings_1.encodeVersion(header.version), encodings_1.encodeString(header.chainId), encodings_1.encodeInt(header.height), encodings_1.encodeTime(header.time), encodings_1.encodeBlockId(header.lastBlockId), encodings_1.encodeBytes(header.lastCommitHash), encodings_1.encodeBytes(header.dataHash), encodings_1.encodeBytes(header.validatorsHash), encodings_1.encodeBytes(header.nextValidatorsHash), encodings_1.encodeBytes(header.consensusHash), encodings_1.encodeBytes(header.appHash), encodings_1.encodeBytes(header.lastResultsHash), encodings_1.encodeBytes(header.evidenceHash), encodings_1.encodeBytes(header.proposerAddress)];\n  return hashTree(encodedFields);\n}\n\nexports.hashBlock = hashBlock;","map":{"version":3,"sources":["../../src/tendermint34/hasher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashBlock = exports.hashTx = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encodings_1 = require(\"./encodings\");\n// hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\nfunction hashTx(tx) {\n    return crypto_1.sha256(tx);\n}\nexports.hashTx = hashTx;\nfunction getSplitPoint(n) {\n    if (n < 1)\n        throw new Error(\"Cannot split an empty tree\");\n    const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));\n    return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\nfunction hashLeaf(leaf) {\n    const hash = new crypto_1.Sha256(Uint8Array.from([0]));\n    hash.update(leaf);\n    return hash.digest();\n}\nfunction hashInner(left, right) {\n    const hash = new crypto_1.Sha256(Uint8Array.from([1]));\n    hash.update(left);\n    hash.update(right);\n    return hash.digest();\n}\n// See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\nfunction hashTree(hashes) {\n    switch (hashes.length) {\n        case 0:\n            throw new Error(\"Cannot hash empty tree\");\n        case 1:\n            return hashLeaf(hashes[0]);\n        default: {\n            const slicePoint = getSplitPoint(hashes.length);\n            const left = hashTree(hashes.slice(0, slicePoint));\n            const right = hashTree(hashes.slice(slicePoint));\n            return hashInner(left, right);\n        }\n    }\n}\nfunction hashBlock(header) {\n    const encodedFields = [\n        encodings_1.encodeVersion(header.version),\n        encodings_1.encodeString(header.chainId),\n        encodings_1.encodeInt(header.height),\n        encodings_1.encodeTime(header.time),\n        encodings_1.encodeBlockId(header.lastBlockId),\n        encodings_1.encodeBytes(header.lastCommitHash),\n        encodings_1.encodeBytes(header.dataHash),\n        encodings_1.encodeBytes(header.validatorsHash),\n        encodings_1.encodeBytes(header.nextValidatorsHash),\n        encodings_1.encodeBytes(header.consensusHash),\n        encodings_1.encodeBytes(header.appHash),\n        encodings_1.encodeBytes(header.lastResultsHash),\n        encodings_1.encodeBytes(header.evidenceHash),\n        encodings_1.encodeBytes(header.proposerAddress),\n    ];\n    return hashTree(encodedFields);\n}\nexports.hashBlock = hashBlock;\n//# sourceMappingURL=hasher.js.map"]},"metadata":{},"sourceType":"script"}