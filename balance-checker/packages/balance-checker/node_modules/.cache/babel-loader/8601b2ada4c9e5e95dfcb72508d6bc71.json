{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 32) {\n    throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n  }\n\n  return crypto_1.sha256(pubkeyData).slice(0, 20);\n}\n\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\n\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n  if (pubkeyData.length !== 33) {\n    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n  }\n\n  return crypto_1.ripemd160(crypto_1.sha256(pubkeyData));\n}\n\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress; // For secp256k1 this assumes we already have a compressed pubkey.\n\nfunction pubkeyToRawAddress(type, data) {\n  switch (type) {\n    case \"ed25519\":\n      return rawEd25519PubkeyToRawAddress(data);\n\n    case \"secp256k1\":\n      return rawSecp256k1PubkeyToRawAddress(data);\n\n    default:\n      // Keep this case here to guard against new types being added but not handled\n      throw new Error(`Pubkey type ${type} not supported`);\n  }\n}\n\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\n\nfunction pubkeyToAddress(type, data) {\n  return encoding_1.toHex(pubkeyToRawAddress(type, data)).toUpperCase();\n}\n\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"sources":["../src/addresses.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAEA,SAAgB,4BAAhB,CAA6C,UAA7C,EAAmE;AACjE,MAAI,UAAU,CAAC,MAAX,KAAsB,EAA1B,EAA8B;AAC5B,UAAM,IAAI,KAAJ,CAAU,kCAAkC,UAAU,CAAC,MAAM,EAA7D,CAAN;AACD;;AACD,SAAO,QAAA,CAAA,MAAA,CAAO,UAAP,EAAmB,KAAnB,CAAyB,CAAzB,EAA4B,EAA5B,CAAP;AACD;;AALD,OAAA,CAAA,4BAAA,GAAA,4BAAA;;AAOA,SAAgB,8BAAhB,CAA+C,UAA/C,EAAqE;AACnE,MAAI,UAAU,CAAC,MAAX,KAAsB,EAA1B,EAA8B;AAC5B,UAAM,IAAI,KAAJ,CAAU,iDAAiD,UAAU,CAAC,MAAM,EAA5E,CAAN;AACD;;AACD,SAAO,QAAA,CAAA,SAAA,CAAU,QAAA,CAAA,MAAA,CAAO,UAAP,CAAV,CAAP;AACD;;AALD,OAAA,CAAA,8BAAA,GAAA,8BAAA,C,CAOA;;AACA,SAAgB,kBAAhB,CAAmC,IAAnC,EAAkE,IAAlE,EAAkF;AAChF,UAAQ,IAAR;AACE,SAAK,SAAL;AACE,aAAO,4BAA4B,CAAC,IAAD,CAAnC;;AACF,SAAK,WAAL;AACE,aAAO,8BAA8B,CAAC,IAAD,CAArC;;AACF;AACE;AACA,YAAM,IAAI,KAAJ,CAAU,eAAe,IAAI,gBAA7B,CAAN;AAPJ;AASD;;AAVD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAYA,SAAgB,eAAhB,CAAgC,IAAhC,EAA+D,IAA/D,EAA+E;AAC7E,SAAO,UAAA,CAAA,KAAA,CAAM,kBAAkB,CAAC,IAAD,EAAO,IAAP,CAAxB,EAAsC,WAAtC,EAAP;AACD;;AAFD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nfunction rawEd25519PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 32) {\n        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);\n    }\n    return crypto_1.sha256(pubkeyData).slice(0, 20);\n}\nexports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;\nfunction rawSecp256k1PubkeyToRawAddress(pubkeyData) {\n    if (pubkeyData.length !== 33) {\n        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);\n    }\n    return crypto_1.ripemd160(crypto_1.sha256(pubkeyData));\n}\nexports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;\n// For secp256k1 this assumes we already have a compressed pubkey.\nfunction pubkeyToRawAddress(type, data) {\n    switch (type) {\n        case \"ed25519\":\n            return rawEd25519PubkeyToRawAddress(data);\n        case \"secp256k1\":\n            return rawSecp256k1PubkeyToRawAddress(data);\n        default:\n            // Keep this case here to guard against new types being added but not handled\n            throw new Error(`Pubkey type ${type} not supported`);\n    }\n}\nexports.pubkeyToRawAddress = pubkeyToRawAddress;\nfunction pubkeyToAddress(type, data) {\n    return encoding_1.toHex(pubkeyToRawAddress(type, data)).toUpperCase();\n}\nexports.pubkeyToAddress = pubkeyToAddress;\n//# sourceMappingURL=addresses.js.map"]},"metadata":{},"sourceType":"script"}