{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction toHex(data) {\n  let out = \"\";\n\n  for (const byte of data) {\n    out += (\"0\" + byte.toString(16)).slice(-2);\n  }\n\n  return out;\n}\n\nexports.toHex = toHex;\n\nfunction fromHex(hexstring) {\n  if (hexstring.length % 2 !== 0) {\n    throw new Error(\"hex string length must be a multiple of 2\");\n  } // tslint:disable-next-line:readonly-array\n\n\n  const listOfInts = [];\n\n  for (let i = 0; i < hexstring.length; i += 2) {\n    const hexByteAsString = hexstring.substr(i, 2);\n\n    if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n      throw new Error(\"hex string contains invalid characters\");\n    }\n\n    listOfInts.push(parseInt(hexByteAsString, 16));\n  }\n\n  return new Uint8Array(listOfInts);\n}\n\nexports.fromHex = fromHex;\n\nfunction toAscii(input) {\n  const toNums = str => str.split(\"\").map(x => {\n    const charCode = x.charCodeAt(0); // 0x00–0x1F control characters\n    // 0x20–0x7E printable characters\n    // 0x7F delete character\n    // 0x80–0xFF out of 7 bit ascii range\n\n    if (charCode < 0x20 || charCode > 0x7e) {\n      throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n    }\n\n    return charCode;\n  });\n\n  return Uint8Array.from(toNums(input));\n}\n\nexports.toAscii = toAscii;\n\nfunction fromAscii(data) {\n  const fromNums = listOfNumbers => listOfNumbers.map(x => {\n    // 0x00–0x1F control characters\n    // 0x20–0x7E printable characters\n    // 0x7F delete character\n    // 0x80–0xFF out of 7 bit ascii range\n    if (x < 0x20 || x > 0x7e) {\n      throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n    }\n\n    return String.fromCharCode(x);\n  });\n\n  return fromNums(Array.from(data)).join(\"\");\n}\n\nexports.fromAscii = fromAscii;","map":{"version":3,"sources":["../src/helpers.ts"],"names":[],"mappings":";;;;;;AAAA,SAAgB,KAAhB,CAAsB,IAAtB,EAAsC;AACpC,MAAI,GAAG,GAAW,EAAlB;;AACA,OAAK,MAAM,IAAX,IAAmB,IAAnB,EAAyB;AACvB,IAAA,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,QAAL,CAAc,EAAd,CAAP,EAA0B,KAA1B,CAAgC,CAAC,CAAjC,CAAP;AACD;;AACD,SAAO,GAAP;AACD;;AAND,OAAA,CAAA,KAAA,GAAA,KAAA;;AAQA,SAAgB,OAAhB,CAAwB,SAAxB,EAAyC;AACvC,MAAI,SAAS,CAAC,MAAV,GAAmB,CAAnB,KAAyB,CAA7B,EAAgC;AAC9B,UAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACD,GAHsC,CAKvC;;;AACA,QAAM,UAAU,GAAa,EAA7B;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EAA8C;AAC5C,UAAM,eAAe,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB,CAAxB;;AACA,QAAI,CAAC,eAAe,CAAC,KAAhB,CAAsB,cAAtB,CAAL,EAA4C;AAC1C,YAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,IAAA,UAAU,CAAC,IAAX,CAAgB,QAAQ,CAAC,eAAD,EAAkB,EAAlB,CAAxB;AACD;;AACD,SAAO,IAAI,UAAJ,CAAe,UAAf,CAAP;AACD;;AAfD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAiBA,SAAgB,OAAhB,CAAwB,KAAxB,EAAqC;AACnC,QAAM,MAAM,GAAI,GAAD,IACb,GAAG,CAAC,KAAJ,CAAU,EAAV,EAAc,GAAd,CAAmB,CAAD,IAAc;AAC9B,UAAM,QAAQ,GAAG,CAAC,CAAC,UAAF,CAAa,CAAb,CAAjB,CAD8B,CAE9B;AACA;AACA;AACA;;AACA,QAAI,QAAQ,GAAG,IAAX,IAAmB,QAAQ,GAAG,IAAlC,EAAwC;AACtC,YAAM,IAAI,KAAJ,CACJ,mEACE,QAFE,CAAN;AAID;;AACD,WAAO,QAAP;AACD,GAbD,CADF;;AAeA,SAAO,UAAU,CAAC,IAAX,CAAgB,MAAM,CAAC,KAAD,CAAtB,CAAP;AACD;;AAjBD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAmBA,SAAgB,SAAhB,CAA0B,IAA1B,EAA0C;AACxC,QAAM,QAAQ,GAAI,aAAD,IACf,aAAa,CAAC,GAAd,CAAmB,CAAD,IAAsB;AACtC;AACA;AACA;AACA;AACA,QAAI,CAAC,GAAG,IAAJ,IAAY,CAAC,GAAG,IAApB,EAA0B;AACxB,YAAM,IAAI,KAAJ,CACJ,mEAAmE,CAD/D,CAAN;AAGD;;AACD,WAAO,MAAM,CAAC,YAAP,CAAoB,CAApB,CAAP;AACD,GAXD,CADF;;AAcA,SAAO,QAAQ,CAAC,KAAK,CAAC,IAAN,CAAW,IAAX,CAAD,CAAR,CAA2B,IAA3B,CAAgC,EAAhC,CAAP;AACD;;AAhBD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toHex(data) {\n    let out = \"\";\n    for (const byte of data) {\n        out += (\"0\" + byte.toString(16)).slice(-2);\n    }\n    return out;\n}\nexports.toHex = toHex;\nfunction fromHex(hexstring) {\n    if (hexstring.length % 2 !== 0) {\n        throw new Error(\"hex string length must be a multiple of 2\");\n    }\n    // tslint:disable-next-line:readonly-array\n    const listOfInts = [];\n    for (let i = 0; i < hexstring.length; i += 2) {\n        const hexByteAsString = hexstring.substr(i, 2);\n        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n            throw new Error(\"hex string contains invalid characters\");\n        }\n        listOfInts.push(parseInt(hexByteAsString, 16));\n    }\n    return new Uint8Array(listOfInts);\n}\nexports.fromHex = fromHex;\nfunction toAscii(input) {\n    const toNums = (str) => str.split(\"\").map((x) => {\n        const charCode = x.charCodeAt(0);\n        // 0x00–0x1F control characters\n        // 0x20–0x7E printable characters\n        // 0x7F delete character\n        // 0x80–0xFF out of 7 bit ascii range\n        if (charCode < 0x20 || charCode > 0x7e) {\n            throw new Error(\"Cannot encode character that is out of printable ASCII range: \" +\n                charCode);\n        }\n        return charCode;\n    });\n    return Uint8Array.from(toNums(input));\n}\nexports.toAscii = toAscii;\nfunction fromAscii(data) {\n    const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {\n        // 0x00–0x1F control characters\n        // 0x20–0x7E printable characters\n        // 0x7F delete character\n        // 0x80–0xFF out of 7 bit ascii range\n        if (x < 0x20 || x > 0x7e) {\n            throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n        }\n        return String.fromCharCode(x);\n    });\n    return fromNums(Array.from(data)).join(\"\");\n}\nexports.fromAscii = fromAscii;\n//# sourceMappingURL=helpers.js.map"]},"metadata":{},"sourceType":"script"}