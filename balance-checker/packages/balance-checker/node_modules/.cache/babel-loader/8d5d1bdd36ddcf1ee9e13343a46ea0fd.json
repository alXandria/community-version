{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst long_1 = __importDefault(require(\"long\"));\n/**\n * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.\n * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.\n * The result is typically 20 bytes long but not restricted to that.\n */\n\n\nfunction toAccAddress(address) {\n  return encoding_1.Bech32.decode(address).data;\n}\n\nexports.toAccAddress = toAccAddress;\n\nfunction createPagination(paginationKey) {\n  return paginationKey ? {\n    key: paginationKey,\n    offset: long_1.default.fromNumber(0, true),\n    limit: long_1.default.fromNumber(0, true),\n    countTotal: false\n  } : undefined;\n}\n\nexports.createPagination = createPagination;\n\nfunction createProtobufRpcClient(base) {\n  return {\n    request: (service, method, data) => {\n      const path = `/${service}/${method}`;\n      return base.queryUnverified(path, data);\n    }\n  };\n}\n\nexports.createProtobufRpcClient = createProtobufRpcClient;","map":{"version":3,"sources":["../../src/queries/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,MAAA,CAAA,CAAA;AAKA;;;;;;;AAKA,SAAgB,YAAhB,CAA6B,OAA7B,EAA4C;AAC1C,SAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,OAAd,EAAuB,IAA9B;AACD;;AAFD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAIA,SAAgB,gBAAhB,CAAiC,aAAjC,EAA2D;AACzD,SAAO,aAAa,GAChB;AACE,IAAA,GAAG,EAAE,aADP;AAEE,IAAA,MAAM,EAAE,MAAA,CAAA,OAAA,CAAK,UAAL,CAAgB,CAAhB,EAAmB,IAAnB,CAFV;AAGE,IAAA,KAAK,EAAE,MAAA,CAAA,OAAA,CAAK,UAAL,CAAgB,CAAhB,EAAmB,IAAnB,CAHT;AAIE,IAAA,UAAU,EAAE;AAJd,GADgB,GAOhB,SAPJ;AAQD;;AATD,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAeA,SAAgB,uBAAhB,CAAwC,IAAxC,EAAyD;AACvD,SAAO;AACL,IAAA,OAAO,EAAE,CAAC,OAAD,EAAkB,MAAlB,EAAkC,IAAlC,KAA2E;AAClF,YAAM,IAAI,GAAG,IAAI,OAAO,IAAI,MAAM,EAAlC;AACA,aAAO,IAAI,CAAC,eAAL,CAAqB,IAArB,EAA2B,IAA3B,CAAP;AACD;AAJI,GAAP;AAMD;;AAPD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst long_1 = __importDefault(require(\"long\"));\n/**\n * Takes a bech32 encoded address and returns the data part. The prefix is ignored and discarded.\n * This is called AccAddress in Cosmos SDK, which is basically an alias for raw binary data.\n * The result is typically 20 bytes long but not restricted to that.\n */\nfunction toAccAddress(address) {\n    return encoding_1.Bech32.decode(address).data;\n}\nexports.toAccAddress = toAccAddress;\nfunction createPagination(paginationKey) {\n    return paginationKey\n        ? {\n            key: paginationKey,\n            offset: long_1.default.fromNumber(0, true),\n            limit: long_1.default.fromNumber(0, true),\n            countTotal: false,\n        }\n        : undefined;\n}\nexports.createPagination = createPagination;\nfunction createProtobufRpcClient(base) {\n    return {\n        request: (service, method, data) => {\n            const path = `/${service}/${method}`;\n            return base.queryUnverified(path, data);\n        },\n    };\n}\nexports.createProtobufRpcClient = createProtobufRpcClient;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}