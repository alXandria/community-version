{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DateTime = exports.toSeconds = exports.fromSeconds = exports.toRfc3339WithNanoseconds = exports.fromRfc3339WithNanoseconds = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nfunction fromRfc3339WithNanoseconds(dateTimeString) {\n  const out = encoding_1.fromRfc3339(dateTimeString);\n  const nanosecondsMatch = dateTimeString.match(/\\.(\\d+)Z$/);\n  const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : \"\";\n  out.nanoseconds = parseInt(nanoseconds.padEnd(6, \"0\"), 10);\n  return out;\n}\n\nexports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;\n\nfunction toRfc3339WithNanoseconds(dateTime) {\n  var _a, _b;\n\n  const millisecondIso = dateTime.toISOString();\n  const nanoseconds = (_b = (_a = dateTime.nanoseconds) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\";\n  return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, \"0\")}Z`;\n}\n\nexports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;\n\nfunction fromSeconds(seconds, nanos = 0) {\n  const checkedNanos = new math_1.Uint32(nanos).toNumber();\n\n  if (checkedNanos > 999999999) {\n    throw new Error(\"Nano seconds must not exceed 999999999\");\n  }\n\n  const out = new Date(seconds * 1000 + Math.floor(checkedNanos / 1000000));\n  out.nanoseconds = checkedNanos % 1000000;\n  return out;\n}\n\nexports.fromSeconds = fromSeconds;\n/**\n * Calculates the UNIX timestamp in seconds as well as the nanoseconds after the given second.\n *\n * This is useful when dealing with external systems like the protobuf type\n * [.google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp)\n * or any other system that does not use millisecond precision.\n */\n\nfunction toSeconds(date) {\n  var _a;\n\n  return {\n    seconds: Math.floor(date.getTime() / 1000),\n    nanos: date.getTime() % 1000 * 1000000 + ((_a = date.nanoseconds) !== null && _a !== void 0 ? _a : 0)\n  };\n}\n\nexports.toSeconds = toSeconds;\n/** @deprecated Use fromRfc3339WithNanoseconds/toRfc3339WithNanoseconds instead */\n\nclass DateTime {\n  /** @deprecated Use fromRfc3339WithNanoseconds instead */\n  static decode(dateTimeString) {\n    return fromRfc3339WithNanoseconds(dateTimeString);\n  }\n  /** @deprecated Use toRfc3339WithNanoseconds instead */\n\n\n  static encode(dateTime) {\n    return toRfc3339WithNanoseconds(dateTime);\n  }\n\n}\n\nexports.DateTime = DateTime;","map":{"version":3,"sources":["../src/dates.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAaA,SAAgB,0BAAhB,CAA2C,cAA3C,EAAiE;AAC/D,QAAM,GAAG,GAAwB,UAAA,CAAA,WAAA,CAAY,cAAZ,CAAjC;AACA,QAAM,gBAAgB,GAAG,cAAc,CAAC,KAAf,CAAqB,WAArB,CAAzB;AACA,QAAM,WAAW,GAAG,gBAAgB,GAAG,gBAAgB,CAAC,CAAD,CAAhB,CAAoB,KAApB,CAA0B,CAA1B,CAAH,GAAkC,EAAtE;AACA,EAAA,GAAG,CAAC,WAAJ,GAAkB,QAAQ,CAAC,WAAW,CAAC,MAAZ,CAAmB,CAAnB,EAAsB,GAAtB,CAAD,EAA6B,EAA7B,CAA1B;AACA,SAAO,GAAP;AACD;;AAND,OAAA,CAAA,0BAAA,GAAA,0BAAA;;AAQA,SAAgB,wBAAhB,CAAyC,QAAzC,EAA8E;;;AAC5E,QAAM,cAAc,GAAG,QAAQ,CAAC,WAAT,EAAvB;AACA,QAAM,WAAW,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAG,QAAQ,CAAC,WAAZ,MAAuB,IAAvB,IAAuB,EAAA,KAAA,KAAA,CAAvB,GAAuB,KAAA,CAAvB,GAAuB,EAAA,CAAE,QAAF,EAAvB,MAAiC,IAAjC,IAAiC,EAAA,KAAA,KAAA,CAAjC,GAAiC,EAAjC,GAAuC,EAAxD;AACA,SAAO,GAAG,cAAc,CAAC,KAAf,CAAqB,CAArB,EAAwB,CAAC,CAAzB,CAA2B,GAAG,WAAW,CAAC,QAAZ,CAAqB,CAArB,EAAwB,GAAxB,CAA4B,GAApE;AACD;;AAJD,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAMA,SAAgB,WAAhB,CAA4B,OAA5B,EAA6C,KAAK,GAAG,CAArD,EAAsD;AACpD,QAAM,YAAY,GAAG,IAAI,MAAA,CAAA,MAAJ,CAAW,KAAX,EAAkB,QAAlB,EAArB;;AACA,MAAI,YAAY,GAAG,SAAnB,EAAgC;AAC9B,UAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,QAAM,GAAG,GAAwB,IAAI,IAAJ,CAAS,OAAO,GAAG,IAAV,GAAiB,IAAI,CAAC,KAAL,CAAW,YAAY,GAAG,OAA1B,CAA1B,CAAjC;AACA,EAAA,GAAG,CAAC,WAAJ,GAAkB,YAAY,GAAG,OAAjC;AACA,SAAO,GAAP;AACD;;AARD,OAAA,CAAA,WAAA,GAAA,WAAA;AAUA;;;;;;;;AAOA,SAAgB,SAAhB,CAA0B,IAA1B,EAA2D;;;AACzD,SAAO;AACL,IAAA,OAAO,EAAE,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,OAAL,KAAiB,IAA5B,CADJ;AAEL,IAAA,KAAK,EAAG,IAAI,CAAC,OAAL,KAAiB,IAAlB,GAA0B,OAA1B,IAAoC,CAAA,EAAA,GAAC,IAAI,CAAC,WAAN,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,CAAzD;AAFF,GAAP;AAID;;AALD,OAAA,CAAA,SAAA,GAAA,SAAA;AAOA;;AACA,MAAa,QAAb,CAAqB;AACnB;AACO,SAAO,MAAP,CAAc,cAAd,EAAoC;AACzC,WAAO,0BAA0B,CAAC,cAAD,CAAjC;AACD;AAED;;;AACO,SAAO,MAAP,CAAc,QAAd,EAAmD;AACxD,WAAO,wBAAwB,CAAC,QAAD,CAA/B;AACD;;AATkB;;AAArB,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DateTime = exports.toSeconds = exports.fromSeconds = exports.toRfc3339WithNanoseconds = exports.fromRfc3339WithNanoseconds = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nfunction fromRfc3339WithNanoseconds(dateTimeString) {\n    const out = encoding_1.fromRfc3339(dateTimeString);\n    const nanosecondsMatch = dateTimeString.match(/\\.(\\d+)Z$/);\n    const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : \"\";\n    out.nanoseconds = parseInt(nanoseconds.padEnd(6, \"0\"), 10);\n    return out;\n}\nexports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;\nfunction toRfc3339WithNanoseconds(dateTime) {\n    var _a, _b;\n    const millisecondIso = dateTime.toISOString();\n    const nanoseconds = (_b = (_a = dateTime.nanoseconds) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\";\n    return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, \"0\")}Z`;\n}\nexports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;\nfunction fromSeconds(seconds, nanos = 0) {\n    const checkedNanos = new math_1.Uint32(nanos).toNumber();\n    if (checkedNanos > 999999999) {\n        throw new Error(\"Nano seconds must not exceed 999999999\");\n    }\n    const out = new Date(seconds * 1000 + Math.floor(checkedNanos / 1000000));\n    out.nanoseconds = checkedNanos % 1000000;\n    return out;\n}\nexports.fromSeconds = fromSeconds;\n/**\n * Calculates the UNIX timestamp in seconds as well as the nanoseconds after the given second.\n *\n * This is useful when dealing with external systems like the protobuf type\n * [.google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp)\n * or any other system that does not use millisecond precision.\n */\nfunction toSeconds(date) {\n    var _a;\n    return {\n        seconds: Math.floor(date.getTime() / 1000),\n        nanos: (date.getTime() % 1000) * 1000000 + ((_a = date.nanoseconds) !== null && _a !== void 0 ? _a : 0),\n    };\n}\nexports.toSeconds = toSeconds;\n/** @deprecated Use fromRfc3339WithNanoseconds/toRfc3339WithNanoseconds instead */\nclass DateTime {\n    /** @deprecated Use fromRfc3339WithNanoseconds instead */\n    static decode(dateTimeString) {\n        return fromRfc3339WithNanoseconds(dateTimeString);\n    }\n    /** @deprecated Use toRfc3339WithNanoseconds instead */\n    static encode(dateTime) {\n        return toRfc3339WithNanoseconds(dateTime);\n    }\n}\nexports.DateTime = DateTime;\n//# sourceMappingURL=dates.js.map"]},"metadata":{},"sourceType":"script"}