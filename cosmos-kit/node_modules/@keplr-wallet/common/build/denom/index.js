"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenomHelper = void 0;
const buffer_1 = require("buffer/");
const crypto_1 = require("@keplr-wallet/crypto");
class DenomHelper {
    constructor(_denom) {
        this._denom = _denom;
        // Remember that the coin's actual denom should start with "type:contractAddress:denom" if it is for the token based on contract.
        const split = this.denom.split(/(\w+):(\w+):(.+)/).filter(Boolean);
        if (split.length !== 1 && split.length !== 3) {
            throw new Error(`Invalid denom: ${this.denom}`);
        }
        this._type = split.length === 3 ? split[0] : "";
        this._contractAddress = split.length === 3 ? split[1] : "";
    }
    static ibcDenom(paths, coinMinimalDenom) {
        const prefixes = [];
        for (const path of paths) {
            prefixes.push(`${path.portId}/${path.channelId}`);
        }
        const prefix = prefixes.join("/");
        const denom = `${prefix}/${coinMinimalDenom}`;
        return ("ibc/" +
            buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom)))
                .toString("hex")
                .toUpperCase());
    }
    get denom() {
        return this._denom;
    }
    get type() {
        return this._type || "native";
    }
    get contractAddress() {
        return this._contractAddress;
    }
}
exports.DenomHelper = DenomHelper;
//# sourceMappingURL=index.js.map