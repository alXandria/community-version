"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionService = void 0;
const router_1 = require("@keplr-wallet/router");
const types_1 = require("./types");
const cosmos_1 = require("@keplr-wallet/cosmos");
class PermissionService {
    constructor(kvStore, privilegedOrigins) {
        this.kvStore = kvStore;
        this.permissionMap = {};
        this.privilegedOrigins = new Map();
        this.onChainRemoved = (chainId) => {
            this.removeAllPermissions(chainId);
        };
        for (const origin of privilegedOrigins) {
            this.privilegedOrigins.set(origin, true);
        }
        this.restore();
    }
    init(interactionService, chainsService, keyRingService) {
        this.interactionService = interactionService;
        this.chainsService = chainsService;
        this.keyRingService = keyRingService;
        this.chainsService.addChainRemovedHandler(this.onChainRemoved);
    }
    checkOrGrantBasicAccessPermission(env, chainIds, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            // Try to unlock the key ring before checking or granting the basic permission.
            yield this.keyRingService.enable(env);
            if (typeof chainIds === "string") {
                chainIds = [chainIds];
            }
            const ungrantedChainIds = [];
            for (const chainId of chainIds) {
                if (!this.hasPermisson(chainId, types_1.getBasicAccessPermissionType(), origin)) {
                    ungrantedChainIds.push(chainId);
                }
            }
            if (ungrantedChainIds.length > 0) {
                yield this.grantBasicAccessPermission(env, ungrantedChainIds, [origin]);
            }
            yield this.checkBasicAccessPermission(env, chainIds, origin);
        });
    }
    grantPermission(env, url, chainIds, type, origins) {
        return __awaiter(this, void 0, void 0, function* () {
            if (env.isInternalMsg) {
                return;
            }
            const permissionData = {
                chainIds,
                type,
                origins,
            };
            yield this.interactionService.waitApprove(env, url, types_1.INTERACTION_TYPE_PERMISSION, permissionData);
            yield this.addPermission(chainIds, type, origins);
        });
    }
    grantBasicAccessPermission(env, chainIds, origins) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const chainId of chainIds) {
                // Make sure that the chain info is registered.
                yield this.chainsService.getChainInfo(chainId);
            }
            yield this.grantPermission(env, "/access", chainIds, types_1.getBasicAccessPermissionType(), origins);
        });
    }
    checkPermission(env, chainId, type, origin) {
        if (env.isInternalMsg) {
            return;
        }
        if (!this.hasPermisson(chainId, type, origin)) {
            throw new router_1.KeplrError("permission", 130, `${origin} is not permitted`);
        }
    }
    checkBasicAccessPermission(env, chainIds, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const chainId of chainIds) {
                // Make sure that the chain info is registered.
                yield this.chainsService.getChainInfo(chainId);
                this.checkPermission(env, chainId, types_1.getBasicAccessPermissionType(), origin);
            }
        });
    }
    hasPermisson(chainId, type, origin) {
        // Privileged origin can pass the any permission.
        if (this.privilegedOrigins.get(origin)) {
            return true;
        }
        const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];
        if (!permissionsInChain) {
            return false;
        }
        const innerMap = permissionsInChain[type];
        return !(!innerMap || !innerMap[origin]);
    }
    getPermissionOrigins(chainId, type) {
        const origins = [];
        const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];
        if (!permissionsInChain) {
            return [];
        }
        const innerMap = permissionsInChain[type];
        if (!innerMap) {
            return [];
        }
        for (const origin of Object.keys(innerMap)) {
            if (innerMap[origin]) {
                origins.push(origin);
            }
        }
        return origins;
    }
    getOriginPermittedChains(origin, type) {
        var _a;
        const chains = [];
        for (const chain of Object.keys(this.permissionMap)) {
            const permissionInChain = this.permissionMap[chain];
            const originMap = (_a = (permissionInChain ? permissionInChain[type] : undefined)) !== null && _a !== void 0 ? _a : {};
            for (const _origin of Object.keys(originMap)) {
                if (_origin === origin && originMap[_origin]) {
                    chains.push(chain);
                }
            }
        }
        return chains;
    }
    addPermission(chainIds, type, origins) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const chainId of chainIds) {
                let permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];
                if (!permissionsInChain) {
                    permissionsInChain = {};
                    this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier] = permissionsInChain;
                }
                let innerMap = permissionsInChain[type];
                if (!innerMap) {
                    innerMap = {};
                    permissionsInChain[type] = innerMap;
                }
                for (const origin of origins) {
                    innerMap[origin] = true;
                }
            }
            yield this.save();
        });
    }
    removePermission(chainId, type, origins) {
        return __awaiter(this, void 0, void 0, function* () {
            const permissionsInChain = this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier];
            if (!permissionsInChain) {
                return;
            }
            const innerMap = permissionsInChain[type];
            if (!innerMap) {
                return;
            }
            for (const origin of origins) {
                delete innerMap[origin];
            }
            yield this.save();
        });
    }
    removeAllPermissions(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.permissionMap[cosmos_1.ChainIdHelper.parse(chainId).identifier] = undefined;
            yield this.save();
        });
    }
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            const map = yield this.kvStore.get("permissionMap");
            if (map) {
                this.permissionMap = map;
            }
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set("permissionMap", this.permissionMap);
        });
    }
}
exports.PermissionService = PermissionService;
//# sourceMappingURL=service.js.map