"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ledger = exports.LedgerInitError = exports.LedgerWebHIDIniter = exports.LedgerWebUSBIniter = exports.LedgerInitErrorOn = void 0;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const CosmosApp = require("ledger-cosmos-js").default;
const hw_transport_webhid_1 = __importDefault(require("@ledgerhq/hw-transport-webhid"));
const hw_transport_webusb_1 = __importDefault(require("@ledgerhq/hw-transport-webusb"));
const secp256k1_1 = require("secp256k1");
const router_1 = require("@keplr-wallet/router");
var LedgerInitErrorOn;
(function (LedgerInitErrorOn) {
    LedgerInitErrorOn[LedgerInitErrorOn["Transport"] = 0] = "Transport";
    LedgerInitErrorOn[LedgerInitErrorOn["App"] = 1] = "App";
    LedgerInitErrorOn[LedgerInitErrorOn["Unknown"] = 2] = "Unknown";
})(LedgerInitErrorOn = exports.LedgerInitErrorOn || (exports.LedgerInitErrorOn = {}));
const LedgerWebUSBIniter = () => __awaiter(void 0, void 0, void 0, function* () {
    return yield hw_transport_webusb_1.default.create();
});
exports.LedgerWebUSBIniter = LedgerWebUSBIniter;
const LedgerWebHIDIniter = () => __awaiter(void 0, void 0, void 0, function* () {
    return yield hw_transport_webhid_1.default.create();
});
exports.LedgerWebHIDIniter = LedgerWebHIDIniter;
class LedgerInitError extends Error {
    constructor(errorOn, message) {
        super(message);
        this.errorOn = errorOn;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, LedgerInitError.prototype);
    }
}
exports.LedgerInitError = LedgerInitError;
class Ledger {
    constructor(cosmosApp) {
        this.cosmosApp = cosmosApp;
    }
    static init(transportIniter, initArgs = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = yield transportIniter(...initArgs);
            try {
                const cosmosApp = new CosmosApp(transport);
                const ledger = new Ledger(cosmosApp);
                const versionResponse = yield ledger.getVersion();
                // In this case, device is on screen saver.
                // However, it is almost same as that the device is not unlocked to user-side.
                // So, handle this case as initializing failed in `Transport`.
                if (versionResponse.deviceLocked) {
                    throw new router_1.KeplrError("ledger", 102, "Device is on screen saver");
                }
                return ledger;
            }
            catch (e) {
                if (transport) {
                    yield transport.close();
                }
                if (e.message === "Device is on screen saver") {
                    throw new LedgerInitError(LedgerInitErrorOn.Transport, e.message);
                }
                throw new LedgerInitError(LedgerInitErrorOn.App, e.message);
            }
        });
    }
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cosmosApp) {
                throw new router_1.KeplrError("ledger", 100, "Cosmos App not initialized");
            }
            const result = yield this.cosmosApp.getVersion();
            if (result.error_message !== "No errors") {
                throw new Error(result.error_message);
            }
            return {
                deviceLocked: result.device_locked,
                major: result.major,
                minor: result.minor,
                patch: result.patch,
                targetId: result.target_id,
                testMode: result.test_mode,
            };
        });
    }
    getPublicKey(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cosmosApp) {
                throw new router_1.KeplrError("ledger", 100, "Cosmos App not initialized");
            }
            const result = yield this.cosmosApp.publicKey(path);
            if (result.error_message !== "No errors") {
                throw new Error(result.error_message);
            }
            return result.compressed_pk;
        });
    }
    sign(path, message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cosmosApp) {
                throw new router_1.KeplrError("ledger", 100, "Cosmos App not initialized");
            }
            const result = yield this.cosmosApp.sign(path, message);
            if (result.error_message !== "No errors") {
                throw new Error(result.error_message);
            }
            // Parse a DER ECDSA signature
            return secp256k1_1.signatureImport(result.signature);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.cosmosApp.transport.close();
        });
    }
    static isWebHIDSupported() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield hw_transport_webhid_1.default.isSupported();
        });
    }
}
exports.Ledger = Ledger;
//# sourceMappingURL=ledger.js.map