"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerService = void 0;
const ledger_1 = require("./ledger");
const delay_1 = __importDefault(require("delay"));
const router_1 = require("@keplr-wallet/router");
const buffer_1 = require("buffer/");
class LedgerService {
    constructor(kvStore, options) {
        var _a;
        this.kvStore = kvStore;
        this.options = {
            defaultMode: options.defaultMode || "webusb",
            transportIniters: (_a = options.transportIniters) !== null && _a !== void 0 ? _a : {},
        };
        if (!this.options.transportIniters["webusb"]) {
            this.options.transportIniters["webusb"] = ledger_1.LedgerWebUSBIniter;
        }
        if (!this.options.transportIniters["webhid"]) {
            this.options.transportIniters["webhid"] = ledger_1.LedgerWebHIDIniter;
        }
    }
    init(interactionService) {
        this.interactionService = interactionService;
    }
    getPublicKey(env, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.useLedger(env, (ledger, retryCount) => __awaiter(this, void 0, void 0, function* () {
                try {
                    // Cosmos App on Ledger doesn't support the coin type other than 118.
                    return yield ledger.getPublicKey([
                        44,
                        118,
                        bip44HDPath.account,
                        bip44HDPath.change,
                        bip44HDPath.addressIndex,
                    ]);
                }
                finally {
                    // Notify UI Ledger pubkey derivation succeeded only when Ledger initialization is tried again.
                    if (retryCount > 0) {
                        this.interactionService.dispatchEvent(router_1.APP_PORT, "ledger-init", {
                            event: "get-pubkey",
                            success: true,
                        });
                    }
                }
            }));
        });
    }
    sign(env, bip44HDPath, expectedPubKey, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.useLedger(env, (ledger, retryCount) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const pubKey = yield ledger.getPublicKey([
                        44,
                        118,
                        bip44HDPath.account,
                        bip44HDPath.change,
                        bip44HDPath.addressIndex,
                    ]);
                    if (buffer_1.Buffer.from(expectedPubKey).toString("hex") !==
                        buffer_1.Buffer.from(pubKey).toString("hex")) {
                        throw new router_1.KeplrError("ledger", 110, "Unmatched public key");
                    }
                    // Cosmos App on Ledger doesn't support the coin type other than 118.
                    const signature = yield ledger.sign([
                        44,
                        118,
                        bip44HDPath.account,
                        bip44HDPath.change,
                        bip44HDPath.addressIndex,
                    ], message);
                    // Notify UI Ledger signing succeeded only when Ledger initialization is tried again.
                    if (retryCount > 0) {
                        this.interactionService.dispatchEvent(router_1.APP_PORT, "ledger-init", {
                            event: "sign",
                            success: true,
                        });
                    }
                    return signature;
                }
                catch (e) {
                    // Notify UI Ledger signing failed only when Ledger initialization is tried again.
                    if (retryCount > 0) {
                        this.interactionService.dispatchEvent(router_1.APP_PORT, "ledger-init", {
                            event: "sign",
                            success: false,
                        });
                    }
                    throw e;
                }
            }));
        });
    }
    useLedger(env, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            let ledger;
            try {
                ledger = yield this.initLedger(env);
                return yield fn(ledger.ledger, ledger.retryCount);
            }
            finally {
                if (ledger) {
                    yield ledger.ledger.close();
                }
            }
        });
    }
    initLedger(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.previousInitAborter) {
                this.previousInitAborter(new Error("New ledger request occurred before the ledger was initialized"));
            }
            const aborter = (() => {
                let _reject;
                return {
                    wait: () => {
                        return new Promise((_, reject) => {
                            _reject = reject;
                        });
                    },
                    abort: (e) => {
                        if (_reject) {
                            _reject(e);
                        }
                    },
                };
            })();
            // This ensures that the ledger connection is not executed concurrently.
            // Without this, the prior signing request can be delivered to the ledger and possibly make a user take a mistake.
            this.previousInitAborter = aborter.abort;
            let retryCount = 0;
            let initArgs = [];
            while (true) {
                const mode = yield this.getMode();
                try {
                    const transportIniter = this.options.transportIniters[mode];
                    if (!transportIniter) {
                        throw new router_1.KeplrError("ledger", 112, `Unknown mode: ${mode}`);
                    }
                    const ledger = yield ledger_1.Ledger.init(transportIniter, initArgs);
                    this.previousInitAborter = undefined;
                    return {
                        ledger,
                        retryCount,
                    };
                }
                catch (e) {
                    console.log(e);
                    const timeoutAbortController = new AbortController();
                    try {
                        const promises = [
                            (() => __awaiter(this, void 0, void 0, function* () {
                                const response = (yield this.interactionService.waitApprove(env, "/ledger-grant", "ledger-init", {
                                    event: "init-failed",
                                    mode,
                                }, {
                                    forceOpenWindow: true,
                                    channel: "ledger",
                                }));
                                if (response === null || response === void 0 ? void 0 : response.abort) {
                                    throw new router_1.KeplrError("ledger", 120, "Ledger init aborted");
                                }
                                if (response === null || response === void 0 ? void 0 : response.initArgs) {
                                    initArgs = response.initArgs;
                                }
                            }))(),
                        ];
                        promises.push((() => __awaiter(this, void 0, void 0, function* () {
                            let timeoutAborted = false;
                            // If ledger is not inited in 5 minutes, abort it.
                            try {
                                yield delay_1.default(5 * 60 * 1000, {
                                    signal: timeoutAbortController.signal,
                                });
                            }
                            catch (e) {
                                if (e.name === "AbortError") {
                                    timeoutAborted = true;
                                }
                                else {
                                    throw e;
                                }
                            }
                            if (!timeoutAborted) {
                                this.interactionService.dispatchEvent(router_1.APP_PORT, "ledger-init", {
                                    event: "init-aborted",
                                    mode,
                                });
                                throw new router_1.KeplrError("ledger", 121, "Ledger init timeout");
                            }
                        }))());
                        promises.push(aborter.wait());
                        // Check that the Ledger Popup is opened only if the environment is extension.
                        if (typeof browser !== "undefined") {
                            promises.push(this.testLedgerGrantUIOpened());
                        }
                        yield Promise.race(promises);
                    }
                    finally {
                        timeoutAbortController.abort();
                    }
                }
                retryCount++;
            }
        });
    }
    // Test that the exntesion's granting ledger page is opened.
    testLedgerGrantUIOpened() {
        return __awaiter(this, void 0, void 0, function* () {
            yield delay_1.default(1000);
            while (true) {
                const views = browser.extension.getViews();
                let find = false;
                for (const view of views) {
                    if (view.location.href.includes(browser.runtime.getURL("popup.html#/ledger-grant"))) {
                        find = true;
                        break;
                    }
                }
                if (!find) {
                    throw new router_1.KeplrError("ledger", 120, "Ledger init aborted");
                }
                yield delay_1.default(1000);
            }
        });
    }
    /**
     * Mode means that which transport should be used.
     * "webusb" and "webhid" are used in the extension environment (web).
     * Alternatively, custom mode can be supported by delivering the custom transport initer on the constructor.
     * Maybe, the "ble" (bluetooth) mode would be supported in the mobile environment (only with Ledger Nano X).
     */
    getMode() {
        return __awaiter(this, void 0, void 0, function* () {
            // Backward compatibilty for the extension.
            if (yield this.getWebHIDFlag()) {
                return "webhid";
            }
            return this.options.defaultMode;
        });
    }
    getWebHIDFlag() {
        return __awaiter(this, void 0, void 0, function* () {
            const webHIDFlag = yield this.kvStore.get("webhid");
            return !!webHIDFlag;
        });
    }
    setWebHIDFlag(flag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set("webhid", flag);
        });
    }
}
exports.LedgerService = LedgerService;
//# sourceMappingURL=service.js.map