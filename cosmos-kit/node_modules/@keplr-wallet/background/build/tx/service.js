"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundTxService = void 0;
const axios_1 = __importDefault(require("axios"));
const cosmos_1 = require("@keplr-wallet/cosmos");
const buffer_1 = require("buffer/");
class BackgroundTxService {
    constructor(notification) {
        this.notification = notification;
    }
    init(chainsService, permissionService) {
        this.chainsService = chainsService;
        this.permissionService = permissionService;
    }
    sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const restInstance = axios_1.default.create(Object.assign({
                baseURL: chainInfo.rest,
            }, chainInfo.restConfig));
            this.notification.create({
                iconRelativeUrl: "assets/logo-256.png",
                title: "Tx is pending...",
                message: "Wait a second",
            });
            const isProtoTx = buffer_1.Buffer.isBuffer(tx) || tx instanceof Uint8Array;
            const params = isProtoTx
                ? {
                    tx_bytes: buffer_1.Buffer.from(tx).toString("base64"),
                    mode: (() => {
                        switch (mode) {
                            case "async":
                                return "BROADCAST_MODE_ASYNC";
                            case "block":
                                return "BROADCAST_MODE_BLOCK";
                            case "sync":
                                return "BROADCAST_MODE_SYNC";
                            default:
                                return "BROADCAST_MODE_UNSPECIFIED";
                        }
                    })(),
                }
                : {
                    tx,
                    mode: mode,
                };
            try {
                const result = yield restInstance.post(isProtoTx ? "/cosmos/tx/v1beta1/txs" : "/txs", params);
                const txResponse = isProtoTx ? result.data["tx_response"] : result.data;
                if (txResponse.code != null && txResponse.code !== 0) {
                    throw new Error(txResponse["raw_log"]);
                }
                const txHash = buffer_1.Buffer.from(txResponse.txhash, "hex");
                const txTracer = new cosmos_1.TendermintTxTracer(chainInfo.rpc, "/websocket");
                txTracer.traceTx(txHash).then((tx) => {
                    txTracer.close();
                    BackgroundTxService.processTxResultNotification(this.notification, tx);
                });
                return txHash;
            }
            catch (e) {
                console.log(e);
                BackgroundTxService.processTxErrorNotification(this.notification, e);
                throw e;
            }
        });
    }
    static processTxResultNotification(notification, result) {
        var _a;
        try {
            if (result.mode === "commit") {
                if (result.checkTx.code !== undefined && result.checkTx.code !== 0) {
                    throw new Error(result.checkTx.log);
                }
                if (result.deliverTx.code !== undefined &&
                    result.deliverTx.code !== 0) {
                    throw new Error(result.deliverTx.log);
                }
            }
            else {
                if (result.code != null && result.code !== 0) {
                    // XXX: Hack of the support of the stargate.
                    const log = (_a = result.log) !== null && _a !== void 0 ? _a : result["raw_log"];
                    throw new Error(log);
                }
            }
            notification.create({
                iconRelativeUrl: "assets/logo-256.png",
                title: "Tx succeeds",
                // TODO: Let users know the tx id?
                message: "Congratulations!",
            });
        }
        catch (e) {
            BackgroundTxService.processTxErrorNotification(notification, e);
        }
    }
    static processTxErrorNotification(notification, e) {
        console.log(e);
        let message = e.message;
        // Tendermint rpc error.
        const regResult = /code:\s*(-?\d+),\s*message:\s*(.+),\sdata:\s(.+)/g.exec(e.message);
        if (regResult && regResult.length === 4) {
            // If error is from tendermint
            message = regResult[3];
        }
        try {
            // Cosmos-sdk error in ante handler
            const sdkErr = JSON.parse(e.message);
            if (sdkErr === null || sdkErr === void 0 ? void 0 : sdkErr.message) {
                message = sdkErr.message;
            }
        }
        catch (_a) {
            // noop
        }
        try {
            // Cosmos-sdk error in processing message
            const abciMessageLogs = JSON.parse(e.message);
            if (abciMessageLogs && abciMessageLogs.length > 0) {
                for (const abciMessageLog of abciMessageLogs) {
                    if (!abciMessageLog.success) {
                        const sdkErr = JSON.parse(abciMessageLog.log);
                        if (sdkErr === null || sdkErr === void 0 ? void 0 : sdkErr.message) {
                            message = sdkErr.message;
                            break;
                        }
                    }
                }
            }
        }
        catch (_b) {
            // noop
        }
        notification.create({
            iconRelativeUrl: "assets/logo-256.png",
            title: "Tx failed",
            message,
        });
    }
}
exports.BackgroundTxService = BackgroundTxService;
//# sourceMappingURL=service.js.map