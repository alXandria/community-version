"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensService = void 0;
const router_1 = require("@keplr-wallet/router");
const chains_1 = require("../chains");
const cosmos_1 = require("@keplr-wallet/cosmos");
const keyring_1 = require("../keyring");
const buffer_1 = require("buffer/");
const messages_1 = require("./messages");
const types_1 = require("./types");
class TokensService {
    constructor(kvStore) {
        this.kvStore = kvStore;
        this.onChainRemoved = (chainId) => {
            this.clearTokens(chainId);
        };
    }
    init(interactionService, permissionService, chainsService, keyRingService) {
        this.interactionService = interactionService;
        this.permissionService = permissionService;
        this.chainsService = chainsService;
        this.keyRingService = keyRingService;
        this.chainsService.addChainRemovedHandler(this.onChainRemoved);
    }
    suggestToken(env, chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const find = (yield this.getTokens(chainId)).find((currency) => "contractAddress" in currency &&
                currency.contractAddress === contractAddress);
            // If the same currency is already registered, do nothing.
            if (find) {
                // If the secret20 token,
                // just try to change the viewing key.
                if (viewingKey) {
                    if ("type" in find && find.type === "secret20") {
                        yield this.addToken(chainId, Object.assign(Object.assign({}, find), { viewingKey }));
                    }
                    return;
                }
                return;
            }
            // Validate the contract address.
            cosmos_1.Bech32Address.validate(contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);
            const params = {
                chainId,
                contractAddress,
                viewingKey,
            };
            const appCurrency = yield this.interactionService.waitApprove(env, "/setting/token/add", messages_1.SuggestTokenMsg.type(), params);
            yield this.addToken(chainId, appCurrency);
        });
    }
    addToken(chainId, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            currency = yield TokensService.validateCurrency(chainInfo, currency);
            const chainCurrencies = yield this.getTokens(chainId);
            const isTokenForAccount = "type" in currency && currency.type === "secret20";
            let isCurrencyUpdated = false;
            for (const chainCurrency of chainCurrencies) {
                if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {
                    if (!isTokenForAccount) {
                        // If currency is already registered, do nothing.
                        return;
                    }
                    isCurrencyUpdated = true;
                }
            }
            if (!isTokenForAccount) {
                const currencies = yield this.getTokensFromChain(chainId);
                currencies.push(currency);
                yield this.saveTokensToChain(chainId, currencies);
            }
            else {
                const currencies = yield this.getTokensFromChainAndAccount(chainId);
                if (!isCurrencyUpdated) {
                    currencies.push(currency);
                    yield this.saveTokensToChainAndAccount(chainId, currencies);
                }
                else {
                    const index = currencies.findIndex((cur) => cur.coinMinimalDenom === currency.coinMinimalDenom);
                    if (index >= 0) {
                        currencies[index] = currency;
                        yield this.saveTokensToChainAndAccount(chainId, currencies);
                    }
                }
            }
        });
    }
    removeToken(chainId, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            currency = yield TokensService.validateCurrency(chainInfo, currency);
            const chainCurrencies = yield this.getTokens(chainId);
            const isTokenForAccount = "type" in currency && currency.type === "secret20";
            let isFoundCurrency = false;
            for (const chainCurrency of chainCurrencies) {
                if (currency.coinMinimalDenom === chainCurrency.coinMinimalDenom) {
                    isFoundCurrency = true;
                    break;
                }
            }
            if (!isFoundCurrency) {
                return;
            }
            if (!isTokenForAccount) {
                const currencies = (yield this.getTokensFromChain(chainId)).filter((cur) => cur.coinMinimalDenom !== currency.coinMinimalDenom);
                yield this.saveTokensToChain(chainId, currencies);
            }
            else {
                const currencies = (yield this.getTokensFromChainAndAccount(chainId)).filter((cur) => cur.coinMinimalDenom !== currency.coinMinimalDenom);
                yield this.saveTokensToChainAndAccount(chainId, currencies);
            }
        });
    }
    getTokens(chainId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            const chainCurrencies = (_a = (yield this.kvStore.get(chainIdHelper.identifier))) !== null && _a !== void 0 ? _a : [];
            let keyCurrencies = [];
            if (this.keyRingService.keyRingStatus === keyring_1.KeyRingStatus.UNLOCKED) {
                const currentKey = yield this.keyRingService.getKey(chainId);
                keyCurrencies = (_b = (yield this.kvStore.get(`${chainIdHelper.identifier}-${buffer_1.Buffer.from(currentKey.address).toString("hex")}`))) !== null && _b !== void 0 ? _b : [];
            }
            return chainCurrencies.concat(keyCurrencies);
        });
    }
    clearTokens(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            yield this.kvStore.set(chainIdHelper.identifier, null);
            const reverse = yield this.getTokensToAccountReverse(chainId);
            for (const hexAddress of reverse) {
                yield this.kvStore.set(`${chainIdHelper.identifier}-${hexAddress}`, null);
            }
            yield this.setTokensToAccountReverse(chainId, []);
        });
    }
    getTokensFromChain(chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            return ((_a = (yield this.kvStore.get(chainIdHelper.identifier))) !== null && _a !== void 0 ? _a : []);
        });
    }
    saveTokensToChain(chainId, currencies) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            yield this.kvStore.set(chainIdHelper.identifier, currencies);
        });
    }
    getTokensFromChainAndAccount(chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            const currentKey = yield this.keyRingService.getKey(chainId);
            return ((_a = (yield this.kvStore.get(`${chainIdHelper.identifier}-${buffer_1.Buffer.from(currentKey.address).toString("hex")}`))) !== null && _a !== void 0 ? _a : []);
        });
    }
    saveTokensToChainAndAccount(chainId, currencies) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            const currentKey = yield this.keyRingService.getKey(chainId);
            const hexAddress = buffer_1.Buffer.from(currentKey.address).toString("hex");
            yield this.kvStore.set(`${chainIdHelper.identifier}-${hexAddress}`, currencies);
            yield this.insertTokensToAccountReverse(chainId, hexAddress);
        });
    }
    getTokensToAccountReverse(chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            return ((_a = (yield this.kvStore.get(`${chainIdHelper.identifier}-addresses`))) !== null && _a !== void 0 ? _a : []);
        });
    }
    setTokensToAccountReverse(chainId, addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainIdHelper = cosmos_1.ChainIdHelper.parse(chainId);
            yield this.kvStore.set(`${chainIdHelper.identifier}-addresses`, addresses);
        });
    }
    insertTokensToAccountReverse(chainId, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const reverse = yield this.getTokensToAccountReverse(chainId);
            if (reverse.indexOf(address) < 0) {
                reverse.push(address);
                yield this.setTokensToAccountReverse(chainId, reverse);
            }
        });
    }
    getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokens = yield this.getTokens(chainId);
            for (const currency of tokens) {
                if ("type" in currency && currency.type === "secret20") {
                    if (currency.contractAddress === contractAddress) {
                        return currency.viewingKey;
                    }
                }
            }
            throw new router_1.KeplrError("tokens", 111, "There is no matched secret20");
        });
    }
    checkOrGrantSecret20ViewingKeyPermission(env, chainId, contractAddress, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure that the secret20 was registered.
            yield this.getSecret20ViewingKey(chainId, contractAddress);
            const type = types_1.getSecret20ViewingKeyPermissionType(contractAddress);
            if (!this.permissionService.hasPermisson(chainId, type, origin)) {
                yield this.permissionService.grantPermission(env, "/access/viewing-key", [chainId], type, [origin]);
            }
            this.permissionService.checkPermission(env, chainId, type, origin);
        });
    }
    static validateCurrency(chainInfo, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate the schema.
            if ("type" in currency) {
                switch (currency.type) {
                    case "cw20":
                        currency = yield TokensService.validateCW20Currency(chainInfo, currency);
                        break;
                    case "secret20":
                        currency = yield TokensService.validateSecret20Currency(chainInfo, currency);
                        break;
                    default:
                        throw new router_1.KeplrError("tokens", 110, "Unknown type of currency");
                }
            }
            else {
                currency = yield chains_1.CurrencySchema.validateAsync(currency);
            }
            return currency;
        });
    }
    static validateCW20Currency(chainInfo, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate the schema.
            currency = yield chains_1.CW20CurrencySchema.validateAsync(currency);
            // Validate the contract address.
            cosmos_1.Bech32Address.validate(currency.contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);
            return currency;
        });
    }
    static validateSecret20Currency(chainInfo, currency) {
        return __awaiter(this, void 0, void 0, function* () {
            // Validate the schema.
            currency = yield chains_1.Secret20CurrencySchema.validateAsync(currency);
            // Validate the contract address.
            cosmos_1.Bech32Address.validate(currency.contractAddress, chainInfo.bech32Config.bech32PrefixAccAddr);
            return currency;
        });
    }
}
exports.TokensService = TokensService;
//# sourceMappingURL=service.js.map