"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const joi_1 = __importDefault(require("joi"));
const AppCurrencySchemaTest = joi_1.default.array().items(types_1.CurrencySchema, types_1.CW20CurrencySchema);
/* eslint-disable @typescript-eslint/ban-ts-comment */
describe("Test chain info schema", () => {
    it("test currency schema", () => __awaiter(void 0, void 0, void 0, function* () {
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 18,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
                coinImageUrl: "http://test.com/test.jpg",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
                coinImageUrl: "",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error if coin image url is empty string");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
                coinImageUrl: "test",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error if coin image url is not url");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                // coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin denom is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                coinDenom: "TEST",
                // coinMinimalDenom: "utest",
                coinDecimals: 6,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin minimal denom is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin decimals is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                // @ts-ignore
                coinDecimals: "should number",
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin decimals is not number");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                // @ts-ignore
                coinGeckoId: 45,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coingecko id is not string");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 19,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin decimal is too big");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: -1,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin decimal is negative");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 1.5,
            };
            yield types_1.CurrencySchema.validateAsync(currency);
        }), "Should throw error when coin decimal is not integer");
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let currency = {
                type: "cw20",
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            currency = yield types_1.CW20CurrencySchema.validateAsync(currency);
            if (currency.coinMinimalDenom !==
                "cw20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `type:contract-address:`");
            }
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let currency = {
                type: "cw20",
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "cw20:this should be validated in the keeper:utest",
                coinDecimals: 0,
            };
            currency = yield types_1.CW20CurrencySchema.validateAsync(currency);
            if (currency.coinMinimalDenom !==
                "cw20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `type:contract-address:`");
            }
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                // @ts-ignore
                type: "?",
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.CW20CurrencySchema.validateAsync(currency);
        }), "Should throw error when type is not cw20");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.CW20CurrencySchema.validateAsync(currency);
        }), "Should throw error when type is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                type: "cw20",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.CW20CurrencySchema.validateAsync(currency);
        }), "Should throw error when contract address is missing");
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let currency = {
                type: "secret20",
                contractAddress: "this should be validated in the keeper",
                viewingKey: "Test viewingKey",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            currency = yield types_1.Secret20CurrencySchema.validateAsync(currency);
            if (currency.coinMinimalDenom !==
                "secret20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `type:contract-address:`");
            }
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let currency = {
                type: "secret20",
                contractAddress: "this should be validated in the keeper",
                viewingKey: "Test viewingKey",
                coinDenom: "TEST",
                coinMinimalDenom: "secret20:this should be validated in the keeper:utest",
                coinDecimals: 0,
            };
            currency = yield types_1.Secret20CurrencySchema.validateAsync(currency);
            if (currency.coinMinimalDenom !==
                "secret20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `type:contract-address:`");
            }
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                // @ts-ignore
                type: "?",
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.Secret20CurrencySchema.validateAsync(currency);
        }), "Should throw error when type is not secret20");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.Secret20CurrencySchema.validateAsync(currency);
        }), "Should throw error when type is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                type: "secret20",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield types_1.Secret20CurrencySchema.validateAsync(currency);
        }), "Should throw error when contract address is missing");
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let currency = {
                type: "cw20",
                contractAddress: "this should be validated in the keeper",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            const currencies = yield AppCurrencySchemaTest.validateAsync([currency]);
            if (currencies[0].coinMinimalDenom !==
                "cw20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `cw20:contract-address:`");
            }
            currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
                coinGeckoId: "test",
            };
            yield AppCurrencySchemaTest.validateAsync([currency]);
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            // @ts-ignore
            const currency = {
                type: "cw20",
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 0,
            };
            yield AppCurrencySchemaTest.validateAsync([currency]);
        }), "Should throw error when contract address is missing");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const currency = {
                coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 1.5,
            };
            yield AppCurrencySchemaTest.validateAsync([currency]);
        }), "Should throw error when coin decimal is not integer");
    }));
    it("test bech32 config schema", () => __awaiter(void 0, void 0, void 0, function* () {
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const bech32Config = {
                bech32PrefixAccAddr: "test",
                bech32PrefixAccPub: "test",
                bech32PrefixValAddr: "test",
                bech32PrefixValPub: "test",
                bech32PrefixConsAddr: "test",
                bech32PrefixConsPub: "test",
            };
            yield types_1.Bech32ConfigSchema.validateAsync(bech32Config);
        }));
        const validateNullField = (field) => __awaiter(void 0, void 0, void 0, function* () {
            const bech32Config = {
                bech32PrefixAccAddr: "test",
                bech32PrefixAccPub: "test",
                bech32PrefixValAddr: "test",
                bech32PrefixValPub: "test",
                bech32PrefixConsAddr: "test",
                bech32PrefixConsPub: "test",
            };
            // @ts-ignore
            bech32Config[field] = undefined;
            yield types_1.Bech32ConfigSchema.validateAsync(bech32Config);
        });
        const validateNonStringField = (field) => __awaiter(void 0, void 0, void 0, function* () {
            const bech32Config = {
                bech32PrefixAccAddr: "test",
                bech32PrefixAccPub: "test",
                bech32PrefixValAddr: "test",
                bech32PrefixValPub: "test",
                bech32PrefixConsAddr: "test",
                bech32PrefixConsPub: "test",
            };
            // @ts-ignore
            bech32Config[field] = 123;
            yield types_1.Bech32ConfigSchema.validateAsync(bech32Config);
        });
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixAccAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixAccPub");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixValAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixValPub");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixConsAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNullField("bech32PrefixConsPub");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixAccAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixAccPub");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixValAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixValPub");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixConsAddr");
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            yield validateNonStringField("bech32PrefixConsPub");
        }));
    }));
    it("test chain info schema", () => __awaiter(void 0, void 0, void 0, function* () {
        const generatePlainChainInfo = () => {
            return {
                rpc: "http://test.com",
                rest: "http://test.com",
                chainId: "test-1",
                chainName: "Test",
                stakeCurrency: {
                    coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
                bip44: {
                    coinType: 118,
                },
                bech32Config: {
                    bech32PrefixAccAddr: "test",
                    bech32PrefixAccPub: "test",
                    bech32PrefixValAddr: "test",
                    bech32PrefixValPub: "test",
                    bech32PrefixConsAddr: "test",
                    bech32PrefixConsPub: "test",
                },
                currencies: [
                    {
                        coinDenom: "TEST",
                        coinMinimalDenom: "utest",
                        coinDecimals: 6,
                    },
                ],
                feeCurrencies: [
                    {
                        coinDenom: "TEST",
                        coinMinimalDenom: "utest",
                        coinDecimals: 6,
                    },
                ],
            };
        };
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const plainChainInfo = generatePlainChainInfo();
            const chainInfoWithUnknownField = Object.assign(Object.assign({}, plainChainInfo), { unknownField: "unknown" });
            // Should not reject the chain info with unknown field
            const validated = yield types_1.ChainInfoSchema.validateAsync(chainInfoWithUnknownField, {
                stripUnknown: true,
            });
            // But, after being validated, the unknown field should be stripped.
            assert_1.default.strictEqual(validated["unknownField"], undefined);
        }));
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            let chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["currencies"] = [
                {
                    coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
                {
                    type: "cw20",
                    contractAddress: "this should be validated in the keeper",
                    coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
            ];
            chainInfo = yield types_1.ChainInfoSchema.validateAsync(chainInfo);
            if (chainInfo.currencies[0].coinMinimalDenom !== "utest") {
                throw new Error("native currency's actual denom should not be changed");
            }
            if (chainInfo.currencies[1].coinMinimalDenom !==
                "cw20:this should be validated in the keeper:utest") {
                throw new Error("actual denom doens't start with `cw20:contract-address:`");
            }
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["rpc"] = "asd";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when rpc is not uri");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["rpc"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when rpc is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["rest"] = "asd";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when rest is not uri");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["rest"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when rest is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["chainId"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when chain id is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["chainId"] = "";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when chain id is empty string");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["chainName"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when chain name is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["chainName"] = "";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when chain name is empty string");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["stakeCurrency"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when stake currency is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["stakeCurrency"] = "should-throw-error";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when stake currency is non object");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["stakeCurrency"] = {
                // coinDenom: "TEST",
                coinMinimalDenom: "utest",
                coinDecimals: 6,
            };
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when stake currency is invalid");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bip44 is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = {};
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bip44 has no coinType");
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = { coinType: 0 };
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "BIP44 coinType can be 0");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = { coinType: -1 };
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bip44 has negative coinType");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = { coinType: 1.1 };
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bip44 has non integer coinType");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bip44"] = {};
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bip44 is not instance of BIP44");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bech32Config"] = "should-throw-error";
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bech32config is non object");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["bech32Config"] = {
                bech32PrefixAccAddr: "test",
            };
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when bech32Config is invalid");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["currencies"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when currencies is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["currencies"] = [];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when currencies has no item");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["currencies"] = [
                {
                    coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
                {
                    // coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
            ];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when currencies has invalid item");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["feeCurrencies"] = undefined;
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when fee currencies is undefined");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["feeCurrencies"] = [];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when fee currencies has no item");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["feeCurrencies"] = [
                {
                    coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
                {
                    // coinDenom: "TEST",
                    coinMinimalDenom: "utest",
                    coinDecimals: 6,
                },
            ];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when fee currencies has invalid item");
        const stargate = "stargate";
        const cosmwasm = "cosmwasm";
        const secretwasm = "secretwasm";
        yield assert_1.default.doesNotReject(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["features"] = [stargate, cosmwasm];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
            // @ts-ignore
            chainInfo["features"] = [stargate, secretwasm];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }));
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["features"] = ["unknown"];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when the features include the unknown feature");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["features"] = [stargate, stargate];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when the features include the duplicated feature");
        yield assert_1.default.rejects(() => __awaiter(void 0, void 0, void 0, function* () {
            const chainInfo = generatePlainChainInfo();
            // @ts-ignore
            chainInfo["features"] = [cosmwasm, secretwasm];
            yield types_1.ChainInfoSchema.validateAsync(chainInfo);
        }), "Should throw error when the features has cosmwasm and secretwasm at the same time");
    }));
});
//# sourceMappingURL=types.spec.js.map