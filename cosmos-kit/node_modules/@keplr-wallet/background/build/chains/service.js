"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainsService = void 0;
const types_1 = require("./types");
const common_1 = require("@keplr-wallet/common");
const router_1 = require("@keplr-wallet/router");
const messages_1 = require("./messages");
const cosmos_1 = require("@keplr-wallet/cosmos");
class ChainsService {
    constructor(kvStore, embedChainInfos, experimentalOptions = {}) {
        this.kvStore = kvStore;
        this.embedChainInfos = embedChainInfos;
        this.experimentalOptions = experimentalOptions;
        this.onChainRemovedHandlers = [];
        this.getChainInfos = common_1.Debouncer.promise(() => __awaiter(this, void 0, void 0, function* () {
            if (this.cachedChainInfos) {
                return this.cachedChainInfos;
            }
            const chainInfos = this.embedChainInfos.map((chainInfo) => {
                return Object.assign(Object.assign({}, chainInfo), { embeded: true });
            });
            const embedChainInfoIdentifierMap = new Map();
            for (const embedChainInfo of chainInfos) {
                embedChainInfoIdentifierMap.set(cosmos_1.ChainIdHelper.parse(embedChainInfo.chainId).identifier, true);
            }
            const suggestedChainInfos = (yield this.getSuggestedChainInfos())
                .filter((chainInfo) => {
                // Filter the overlaped chain info with the embeded chain infos.
                return !embedChainInfoIdentifierMap.get(cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier);
            })
                .map((chainInfo) => {
                return Object.assign(Object.assign({}, chainInfo), { embeded: false });
            });
            let result = chainInfos.concat(suggestedChainInfos);
            // Set the updated property of the chain.
            result = yield Promise.all(result.map((chainInfo) => __awaiter(this, void 0, void 0, function* () {
                const updated = yield this.chainUpdaterKeeper.putUpdatedPropertyToChainInfo(chainInfo);
                return Object.assign(Object.assign({}, updated), { embeded: chainInfo.embeded });
            })));
            this.cachedChainInfos = result;
            return result;
        }));
        if (experimentalOptions === null || experimentalOptions === void 0 ? void 0 : experimentalOptions.useMemoryKVStoreForSuggestChain) {
            this.kvStoreForSuggestChain = new common_1.MemoryKVStore("suggest-chain");
        }
        else {
            this.kvStoreForSuggestChain = kvStore;
        }
    }
    init(chainUpdaterKeeper, interactionKeeper) {
        this.chainUpdaterKeeper = chainUpdaterKeeper;
        this.interactionKeeper = interactionKeeper;
    }
    clearCachedChainInfos() {
        this.cachedChainInfos = undefined;
    }
    getChainInfo(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = (yield this.getChainInfos()).find((chainInfo) => {
                return (cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier ===
                    cosmos_1.ChainIdHelper.parse(chainId).identifier);
            });
            if (!chainInfo) {
                throw new router_1.KeplrError("chains", 411, `There is no chain info for ${chainId}`);
            }
            return chainInfo;
        });
    }
    getChainCoinType(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.getChainInfo(chainId);
            if (!chainInfo) {
                throw new router_1.KeplrError("chains", 411, `There is no chain info for ${chainId}`);
            }
            return chainInfo.bip44.coinType;
        });
    }
    hasChainInfo(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return ((yield this.getChainInfos()).find((chainInfo) => {
                return (cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier ===
                    cosmos_1.ChainIdHelper.parse(chainId).identifier);
            }) != null);
        });
    }
    suggestChainInfo(env, chainInfo, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            chainInfo = yield types_1.ChainInfoSchema.validateAsync(chainInfo, {
                stripUnknown: true,
            });
            yield this.interactionKeeper.waitApprove(env, "/suggest-chain", messages_1.SuggestChainInfoMsg.type(), Object.assign(Object.assign({}, chainInfo), { origin }));
            yield this.addChainInfo(chainInfo);
        });
    }
    getSuggestedChainInfos() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return ((_a = (yield this.kvStoreForSuggestChain.get("chain-infos"))) !== null && _a !== void 0 ? _a : []);
        });
    }
    addChainInfo(chainInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.hasChainInfo(chainInfo.chainId)) {
                throw new router_1.KeplrError("chains", 121, "Same chain is already registered");
            }
            const savedChainInfos = (_a = (yield this.kvStoreForSuggestChain.get("chain-infos"))) !== null && _a !== void 0 ? _a : [];
            savedChainInfos.push(chainInfo);
            yield this.kvStoreForSuggestChain.set("chain-infos", savedChainInfos);
            this.clearCachedChainInfos();
        });
    }
    removeChainInfo(chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasChainInfo(chainId))) {
                throw new router_1.KeplrError("chains", 120, "Chain is not registered");
            }
            if ((yield this.getChainInfo(chainId)).embeded) {
                throw new router_1.KeplrError("chains", 122, "Can't remove the embedded chain");
            }
            const savedChainInfos = (_a = (yield this.kvStoreForSuggestChain.get("chain-infos"))) !== null && _a !== void 0 ? _a : [];
            const resultChainInfo = savedChainInfos.filter((chainInfo) => {
                return (cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier !==
                    cosmos_1.ChainIdHelper.parse(chainId).identifier);
            });
            yield this.kvStoreForSuggestChain.set("chain-infos", resultChainInfo);
            // Clear the updated chain info.
            yield this.chainUpdaterKeeper.clearUpdatedProperty(chainId);
            for (const chainRemovedHandler of this.onChainRemovedHandlers) {
                chainRemovedHandler(chainId, cosmos_1.ChainIdHelper.parse(chainId).identifier);
            }
            this.clearCachedChainInfos();
        });
    }
    getChainEthereumKeyFeatures(chainId) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.getChainInfo(chainId);
            return {
                address: (_b = (_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("eth-address-gen")) !== null && _b !== void 0 ? _b : false,
                signing: (_d = (_c = chainInfo.features) === null || _c === void 0 ? void 0 : _c.includes("eth-key-sign")) !== null && _d !== void 0 ? _d : false,
            };
        });
    }
    addChainRemovedHandler(handler) {
        this.onChainRemovedHandlers.push(handler);
    }
}
exports.ChainsService = ChainsService;
//# sourceMappingURL=service.js.map