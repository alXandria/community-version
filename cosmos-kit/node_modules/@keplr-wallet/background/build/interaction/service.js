"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionService = void 0;
const router_1 = require("@keplr-wallet/router");
const foreground_1 = require("./foreground");
class InteractionService {
    constructor(eventMsgRequester, rng) {
        this.eventMsgRequester = eventMsgRequester;
        this.rng = rng;
        this.waitingMap = new Map();
        this.resolverMap = new Map();
    }
    init() {
        // noop
    }
    // Dispatch the event to the frontend. Don't wait any interaction.
    // And, don't ensure that the event is delivered successfully, just ignore the any errors.
    dispatchEvent(port, type, data) {
        if (!type) {
            throw new router_1.KeplrError("interaction", 101, "Type should not be empty");
        }
        const msg = new foreground_1.PushEventDataMsg({
            type,
            data,
        });
        this.eventMsgRequester.sendMessage(port, msg).catch((e) => {
            console.log(`Failed to send the event to ${port}: ${e.message}`);
        });
    }
    waitApprove(env, url, type, data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!type) {
                throw new router_1.KeplrError("interaction", 101, "Type should not be empty");
            }
            // TODO: Add timeout?
            const interactionWaitingData = yield this.addDataToMap(type, env.isInternalMsg, data);
            const msg = new foreground_1.PushInteractionDataMsg(interactionWaitingData);
            return yield this.wait(msg.data.id, () => {
                env.requestInteraction(url, msg, options);
            });
        });
    }
    wait(id, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.resolverMap.has(id)) {
                throw new router_1.KeplrError("interaction", 100, "Id is aleady in use");
            }
            return new Promise((resolve, reject) => {
                this.resolverMap.set(id, {
                    onApprove: resolve,
                    onReject: reject,
                });
                fn();
            });
        });
    }
    approve(id, result) {
        if (this.resolverMap.has(id)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.resolverMap.get(id).onApprove(result);
            this.resolverMap.delete(id);
        }
        this.removeDataFromMap(id);
    }
    reject(id) {
        if (this.resolverMap.has(id)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.resolverMap.get(id).onReject(new Error("Request rejected"));
            this.resolverMap.delete(id);
        }
        this.removeDataFromMap(id);
    }
    addDataToMap(type, isInternal, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytes = new Uint8Array(8);
            const id = Array.from(yield this.rng(bytes))
                .map((value) => {
                return value.toString(16);
            })
                .join("");
            const interactionWaitingData = {
                id,
                type,
                isInternal,
                data,
            };
            if (this.waitingMap.has(id)) {
                throw new router_1.KeplrError("interaction", 100, "Id is aleady in use");
            }
            this.waitingMap.set(id, interactionWaitingData);
            return interactionWaitingData;
        });
    }
    removeDataFromMap(id) {
        this.waitingMap.delete(id);
    }
}
exports.InteractionService = InteractionService;
//# sourceMappingURL=service.js.map