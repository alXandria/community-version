"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainUpdaterService = void 0;
const axios_1 = __importDefault(require("axios"));
const cosmos_1 = require("@keplr-wallet/cosmos");
const router_1 = require("@keplr-wallet/router");
class ChainUpdaterService {
    constructor(kvStore) {
        this.kvStore = kvStore;
    }
    init(chainsService) {
        this.chainsService = chainsService;
    }
    putUpdatedPropertyToChainInfo(chainInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const updatedProperty = yield this.getUpdatedChainProperty(chainInfo.chainId);
            const chainId = cosmos_1.ChainIdHelper.parse(chainInfo.chainId);
            const updatedChainId = cosmos_1.ChainIdHelper.parse(updatedProperty.chainId || chainInfo.chainId);
            // If the saved property is lesser than the current chain id, just ignore.
            if (updatedChainId.version < chainId.version) {
                return chainInfo;
            }
            const features = (_a = chainInfo.features) !== null && _a !== void 0 ? _a : [];
            for (const updatedFeature of (_b = updatedProperty.features) !== null && _b !== void 0 ? _b : []) {
                if (!features.includes(updatedFeature)) {
                    features.push(updatedFeature);
                }
            }
            return Object.assign(Object.assign({}, chainInfo), {
                chainId: updatedProperty.chainId || chainInfo.chainId,
                rpc: updatedProperty.rpc || chainInfo.rpc,
                rest: updatedProperty.rest || chainInfo.rest,
                features,
            });
        });
    }
    clearUpdatedProperty(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set(cosmos_1.ChainIdHelper.parse(chainId).identifier, null);
            this.chainsService.clearCachedChainInfos();
        });
    }
    tryUpdateChain(chainId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            // If chain id is not fomatted as {chainID}-{version},
            // there is no way to deal with the updated chain id.
            if (!cosmos_1.ChainIdHelper.hasChainVersion(chainInfo.chainId)) {
                return;
            }
            const updates = yield ChainUpdaterService.checkChainUpdate(chainInfo);
            if (updates.explicit || updates.slient) {
                const currentVersion = cosmos_1.ChainIdHelper.parse(chainInfo.chainId);
                if (updates.chainId) {
                    const fetchedChainId = updates.chainId;
                    const fetchedVersion = cosmos_1.ChainIdHelper.parse(fetchedChainId);
                    if (currentVersion.identifier === fetchedVersion.identifier &&
                        currentVersion.version < fetchedVersion.version) {
                        yield this.saveChainProperty(currentVersion.identifier, {
                            chainId: fetchedChainId,
                        });
                    }
                }
                if (updates.features && updates.features.length > 0) {
                    const savedChainProperty = yield this.getUpdatedChainProperty(chainInfo.chainId);
                    const updateFeatures = (_a = savedChainProperty.features) !== null && _a !== void 0 ? _a : [];
                    for (const feature of updates.features) {
                        if (!updateFeatures.includes(feature)) {
                            updateFeatures.push(feature);
                        }
                    }
                    yield this.saveChainProperty(currentVersion.identifier, {
                        features: updateFeatures,
                    });
                }
            }
        });
    }
    getUpdatedChainProperty(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = cosmos_1.ChainIdHelper.parse(chainId);
            return yield this.loadChainProperty(version.identifier);
        });
    }
    saveChainProperty(identifier, chainInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const saved = yield this.loadChainProperty(identifier);
            yield this.kvStore.set(identifier, Object.assign(Object.assign({}, saved), chainInfo));
            this.chainsService.clearCachedChainInfos();
        });
    }
    loadChainProperty(identifier) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.kvStore.get(identifier);
            if (!chainInfo)
                return {};
            return chainInfo;
        });
    }
    /**
     * Returns wether the chain has been changed.
     * Currently, only check the chain id has been changed.
     * @param chainInfo Chain information.
     */
    static checkChainUpdate(chainInfo) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const chainId = chainInfo.chainId;
            // If chain id is not fomatted as {chainID}-{version},
            // there is no way to deal with the updated chain id.
            if (!cosmos_1.ChainIdHelper.hasChainVersion(chainId)) {
                return {
                    explicit: false,
                    slient: false,
                };
            }
            const instance = axios_1.default.create({
                baseURL: chainInfo.rpc,
            });
            // Get the status to get the chain id.
            const result = yield instance.get("/status");
            const resultChainId = result.data.result.node_info.network;
            const version = cosmos_1.ChainIdHelper.parse(chainId);
            const fetchedVersion = cosmos_1.ChainIdHelper.parse(resultChainId);
            // TODO: Should throw an error?
            if (version.identifier !== fetchedVersion.identifier) {
                return {
                    explicit: false,
                    slient: false,
                };
            }
            const restInstance = axios_1.default.create({
                baseURL: chainInfo.rest,
            });
            let ibcGoUpdates = false;
            try {
                if (!chainInfo.features || !chainInfo.features.includes("ibc-go")) {
                    // If the chain uses the ibc-go module separated from the cosmos-sdk,
                    // we need to check it because the REST API is different.
                    const result = yield restInstance.get("/ibc/apps/transfer/v1/params");
                    if (result.status === 200) {
                        ibcGoUpdates = true;
                    }
                }
            }
            catch (_b) { }
            let ibcTransferUpdate = false;
            try {
                if (!chainInfo.features || !chainInfo.features.includes("ibc-transfer")) {
                    const isIBCGo = ibcGoUpdates ||
                        (chainInfo.features && chainInfo.features.includes("ibc-go"));
                    // If the chain doesn't have the ibc transfer feature,
                    // try to fetch the params of ibc transfer module.
                    // assume that it can support the ibc transfer if the params return true, and try to update the features.
                    const result = yield restInstance.get(isIBCGo
                        ? "/ibc/apps/transfer/v1/params"
                        : "/ibc/applications/transfer/v1beta1/params");
                    if (result.data.params.receive_enabled &&
                        result.data.params.send_enabled) {
                        ibcTransferUpdate = true;
                    }
                }
            }
            catch (_c) { }
            let wasmd24Update = false;
            try {
                if (((_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("cosmwasm")) &&
                    !chainInfo.features.includes("wasmd_0.24+")) {
                    // It is difficult to decide which contract address to test on each chain.
                    // So it simply sends a query that fails unconditionally.
                    // However, if 400 bad request instead of 501 occurs, the url itself exists.
                    // In this case, it is assumed that wasmd 0.24+ version.
                    const result = yield restInstance.get("/cosmwasm/wasm/v1/contract/test/smart/test", {
                        validateStatus: (status) => {
                            return status === 400 || status === 501;
                        },
                    });
                    if (result.status === 400) {
                        wasmd24Update = true;
                    }
                }
            }
            catch (_d) { }
            let querySpendableBalances = false;
            try {
                if (!chainInfo.features ||
                    !chainInfo.features.includes("query:/cosmos/bank/v1beta1/spendable_balances")) {
                    // It is difficult to decide which account to test on each chain.
                    // So it simply sends a query that fails unconditionally.
                    // However, if 400 bad request instead of 501 occurs, the url itself exists.
                    // In this case, it is assumed that we can query /cosmos/bank/v1beta1/spendable_balances/{account}
                    const result = yield restInstance.get("/cosmos/bank/v1beta1/spendable_balances/test", {
                        validateStatus: (status) => {
                            return status === 400 || status === 501;
                        },
                    });
                    if (result.status === 400) {
                        querySpendableBalances = true;
                    }
                }
            }
            catch (_e) { }
            const features = [];
            if (ibcGoUpdates) {
                features.push("ibc-go");
            }
            if (ibcTransferUpdate) {
                features.push("ibc-transfer");
            }
            if (wasmd24Update) {
                features.push("wasmd_0.24+");
            }
            if (querySpendableBalances) {
                features.push("query:/cosmos/bank/v1beta1/spendable_balances");
            }
            return {
                explicit: version.version < fetchedVersion.version,
                slient: features.length > 0,
                chainId: resultChainId,
                features,
            };
        });
    }
    // XXX: It is not conceptually valid that the function to set the rpc/rest endpoint of the chain exists in this service.
    //      However, in order to focus on adding feature rather than making a big change, the refactor is postponed later and the configuration of the rpc/rest endpoint is handled here.
    setChainEndpoints(chainId, rpc, rest) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = {};
            // `saveChainProperty` method merges chain info using spread operator.
            // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.
            // To avoid this problem, the field must not exist. The implementation of the below is critical to its operation.
            if (rpc) {
                chainInfo.rpc = rpc;
            }
            if (rest) {
                chainInfo.rest = rest;
            }
            const version = cosmos_1.ChainIdHelper.parse(chainId);
            yield this.saveChainProperty(version.identifier, chainInfo);
            return yield this.chainsService.getChainInfos();
        });
    }
    resetChainEndpoints(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = cosmos_1.ChainIdHelper.parse(chainId);
            // `saveChainProperty` method merges chain info using spread operator.
            // That is, if the field is undefined, the field is finally saved as undefined and the field is treated as if it were deleted.
            yield this.saveChainProperty(version.identifier, {
                rpc: undefined,
                rest: undefined,
            });
            return yield this.chainsService.getChainInfos();
        });
    }
    static checkEndpointsConnectivity(chainId, rpc, rest, wsObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const rpcInstance = axios_1.default.create({
                baseURL: rpc,
            });
            let resultStatus;
            try {
                // Get the status to get the chain id.
                resultStatus = yield rpcInstance.get("/status");
            }
            catch (e) {
                console.log(e);
                throw new Error("Failed to get response /status from rpc endpoint");
            }
            const version = cosmos_1.ChainIdHelper.parse(chainId);
            const versionFromRPCStatus = cosmos_1.ChainIdHelper.parse(resultStatus.data.result.node_info.network);
            if (versionFromRPCStatus.identifier !== version.identifier) {
                throw new router_1.KeplrError("updater", 8001, `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);
            }
            else if (versionFromRPCStatus.version !== version.version) {
                // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,
                // but it is actually the same chain but the chain version of the node is different.
                // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.
                throw new router_1.KeplrError("updater", 8002, `RPC endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);
            }
            let wsURL = rpc;
            if (wsURL.startsWith("http")) {
                wsURL = wsURL.replace("http", "ws");
            }
            wsURL = wsURL.endsWith("/") ? wsURL + "websocket" : wsURL + "/websocket";
            const wsInstance = wsObject ? new wsObject(wsURL) : new WebSocket(wsURL);
            // Try 15 times at 1 second intervals to test websocket connectivity.
            for (let i = 0; i < 15; i++) {
                // If ws state is not "connecting"
                if (wsInstance.readyState !== 0) {
                    // If ws state is "open", it means that app can connect ws to /websocket rpc
                    if (wsInstance.readyState === 1) {
                        break;
                    }
                    else {
                        // else, handle that as error.
                        throw new Error("Failed to connect websocket to /websocket rpc");
                    }
                }
                yield new Promise((resolve) => setTimeout(resolve, 1000));
            }
            const restInstance = axios_1.default.create({
                baseURL: rest,
            });
            let resultLCDNodeInfo;
            try {
                // Get the node info to get the chain id.
                resultLCDNodeInfo = yield restInstance.get("/cosmos/base/tendermint/v1beta1/node_info");
            }
            catch (e) {
                console.log(e);
                throw new Error("Failed to get response /cosmos/base/tendermint/v1beta1/node_info from lcd endpoint");
            }
            const versionFromLCDNodeInfo = cosmos_1.ChainIdHelper.parse(resultLCDNodeInfo.data.default_node_info.network);
            if (versionFromLCDNodeInfo.identifier !== version.identifier) {
                throw new router_1.KeplrError("updater", 8101, `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);
            }
            else if (versionFromLCDNodeInfo.version !== version.version) {
                // In the form of {chain_identifier}-{chain_version}, if the identifier is the same but the version is different, it is strictly an error,
                // but it is actually the same chain but the chain version of the node is different.
                // In this case, it is possible to treat as a warning and proceed as it is, so this is separated with above error.
                throw new router_1.KeplrError("updater", 8102, `LCD endpoint has different chain id (expected: ${chainId}, actual: ${resultStatus.data.result.node_info.network})`);
            }
        });
    }
}
exports.ChainUpdaterService = ChainUpdaterService;
//# sourceMappingURL=service.js.map