"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretWasmService = void 0;
const secretjs_1 = require("secretjs");
const crypto_1 = require("@keplr-wallet/crypto");
const common_1 = require("@keplr-wallet/common");
const cosmos_1 = require("@keplr-wallet/cosmos");
const router_1 = require("@keplr-wallet/router");
const buffer_1 = require("buffer/");
class SecretWasmService {
    constructor(kvStore) {
        this.kvStore = kvStore;
        this.debouncerMap = new Map();
        this.cacheEnigmaUtils = new Map();
        this.onChainRemoved = () => {
            this.cacheEnigmaUtils = new Map();
        };
    }
    init(chainsService, keyRingService, permissionService) {
        this.chainsService = chainsService;
        this.keyRingService = keyRingService;
        this.permissionService = permissionService;
        this.chainsService.addChainRemovedHandler(this.onChainRemoved);
    }
    getPubkey(env, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const keyRingType = yield this.keyRingService.getKeyRingType();
            if (keyRingType === "none") {
                throw new router_1.KeplrError("secret-wasm", 130, "Key ring is not initialized");
            }
            const seed = yield this.getSeed(env, chainInfo);
            const utils = this.getEnigmaUtils(chainInfo, seed);
            return utils.pubkey;
        });
    }
    getTxEncryptionKey(env, chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const keyRingType = yield this.keyRingService.getKeyRingType();
            if (keyRingType === "none") {
                throw new router_1.KeplrError("secret-wasm", 130, "Key ring is not initialized");
            }
            const seed = yield this.getSeed(env, chainInfo);
            const utils = this.getEnigmaUtils(chainInfo, seed);
            return utils.getTxEncryptionKey(nonce);
        });
    }
    encrypt(env, chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const keyRingType = yield this.keyRingService.getKeyRingType();
            if (keyRingType === "none") {
                throw new router_1.KeplrError("secret-wasm", 130, "Key ring is not initialized");
            }
            // XXX: Keplr should generate the seed deterministically according to the account.
            // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.
            // For now, use the signature of some string to generate the seed.
            // It need to more research.
            const seed = yield this.getSeed(env, chainInfo);
            const utils = this.getEnigmaUtils(chainInfo, seed);
            return yield utils.encrypt(contractCodeHash, msg);
        });
    }
    decrypt(env, chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            const keyRingType = yield this.keyRingService.getKeyRingType();
            if (keyRingType === "none") {
                throw new router_1.KeplrError("secret-wasm", 130, "Key ring is not initialized");
            }
            // XXX: Keplr should generate the seed deterministically according to the account.
            // Otherwise, it will lost the encryption/decryption key if Keplr is uninstalled or local storage is cleared.
            // For now, use the signature of some string to generate the seed.
            // It need to more research.
            const seed = yield this.getSeed(env, chainInfo);
            const utils = this.getEnigmaUtils(chainInfo, seed);
            return yield utils.decrypt(ciphertext, nonce);
        });
    }
    getEnigmaUtils(chainInfo, seed) {
        const key = `${chainInfo.chainId}-${buffer_1.Buffer.from(seed).toString("hex")}`;
        if (this.cacheEnigmaUtils.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.cacheEnigmaUtils.get(key);
        }
        // TODO: Handle the rest config.
        const utils = new secretjs_1.EnigmaUtils(chainInfo.rest, seed);
        this.cacheEnigmaUtils.set(key, utils);
        return utils;
    }
    // GetSeed will be debounced if the prior promise is pending.
    // GetSeed can be occured multiple times at once,
    // this case can be problem if the cache doesn't exist and key type is ledger,
    // because multiple requests to ledger will make the connection unstable.
    getSeed(env, chainInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.keyRingService.getKey(chainInfo.chainId);
            const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(chainInfo.bech32Config.bech32PrefixAccAddr);
            const debouncerKey = `${env.isInternalMsg}/${chainInfo.chainId}/${bech32Address}`;
            if (!this.debouncerMap.has(debouncerKey)) {
                this.debouncerMap.set(debouncerKey, common_1.Debouncer.promise(this.getSeedInner.bind(this)));
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const debouncedFn = this.debouncerMap.get(debouncerKey);
            return yield debouncedFn(env, chainInfo, bech32Address);
        });
    }
    getSeedInner(env, chainInfo, bech32Address) {
        return __awaiter(this, void 0, void 0, function* () {
            const storeKey = `seed-${chainInfo.chainId}-${bech32Address}`;
            const cached = yield this.kvStore.get(storeKey);
            if (cached) {
                return buffer_1.Buffer.from(cached, "hex");
            }
            const seed = crypto_1.Hash.sha256(buffer_1.Buffer.from(yield this.keyRingService.sign(env, chainInfo.chainId, buffer_1.Buffer.from(JSON.stringify({
                account_number: 0,
                chain_id: chainInfo.chainId,
                fee: [],
                memo: "Create Keplr Secret encryption key. Only approve requests by Keplr.",
                msgs: [],
                sequence: 0,
            })))));
            yield this.kvStore.set(storeKey, buffer_1.Buffer.from(seed).toString("hex"));
            return seed;
        });
    }
}
exports.SecretWasmService = SecretWasmService;
//# sourceMappingURL=service.js.map