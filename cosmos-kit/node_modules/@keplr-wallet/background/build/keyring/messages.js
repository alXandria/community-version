"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportKeyRingDatasMsg = exports.CheckPasswordMsg = exports.SetKeyStoreCoinTypeMsg = exports.GetIsKeyStoreCoinTypeSetMsg = exports.ChangeKeyRingMsg = exports.GetMultiKeyStoreInfoMsg = exports.RequestSignDirectMsg = exports.RequestVerifyADR36AminoSignDoc = exports.RequestSignAminoMsg = exports.GetKeyMsg = exports.UnlockKeyRingMsg = exports.LockKeyRingMsg = exports.AddLedgerKeyMsg = exports.AddPrivateKeyMsg = exports.CreateLedgerKeyMsg = exports.CreatePrivateKeyMsg = exports.AddMnemonicKeyMsg = exports.CreateMnemonicKeyMsg = exports.ShowKeyRingMsg = exports.UpdateNameKeyRingMsg = exports.DeleteKeyRingMsg = exports.RestoreKeyRingMsg = void 0;
const router_1 = require("@keplr-wallet/router");
const constants_1 = require("./constants");
const keyring_1 = require("./keyring");
const cosmos_1 = require("@keplr-wallet/cosmos");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const bip39 = require("bip39");
const tx_1 = require("@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx");
class RestoreKeyRingMsg extends router_1.Message {
    static type() {
        return "restore-keyring";
    }
    constructor() {
        super();
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    validateBasic() { }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return RestoreKeyRingMsg.type();
    }
}
exports.RestoreKeyRingMsg = RestoreKeyRingMsg;
class DeleteKeyRingMsg extends router_1.Message {
    constructor(index, password) {
        super();
        this.index = index;
        this.password = password;
    }
    static type() {
        return "delete-keyring";
    }
    validateBasic() {
        if (!Number.isInteger(this.index)) {
            throw new router_1.KeplrError("keyring", 201, "Invalid index");
        }
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return DeleteKeyRingMsg.type();
    }
}
exports.DeleteKeyRingMsg = DeleteKeyRingMsg;
class UpdateNameKeyRingMsg extends router_1.Message {
    constructor(index, name) {
        super();
        this.index = index;
        this.name = name;
    }
    static type() {
        return "update-name-keyring";
    }
    validateBasic() {
        if (!Number.isInteger(this.index)) {
            throw new router_1.KeplrError("keyring", 201, "Invalid index");
        }
        if (!this.name) {
            throw new router_1.KeplrError("keyring", 273, "name not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return UpdateNameKeyRingMsg.type();
    }
}
exports.UpdateNameKeyRingMsg = UpdateNameKeyRingMsg;
class ShowKeyRingMsg extends router_1.Message {
    constructor(index, password) {
        super();
        this.index = index;
        this.password = password;
    }
    static type() {
        return "show-keyring";
    }
    validateBasic() {
        if (!Number.isInteger(this.index)) {
            throw new router_1.KeplrError("keyring", 201, "Invalid index");
        }
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return ShowKeyRingMsg.type();
    }
}
exports.ShowKeyRingMsg = ShowKeyRingMsg;
class CreateMnemonicKeyMsg extends router_1.Message {
    constructor(kdf, mnemonic, password, meta, bip44HDPath) {
        super();
        this.kdf = kdf;
        this.mnemonic = mnemonic;
        this.password = password;
        this.meta = meta;
        this.bip44HDPath = bip44HDPath;
    }
    static type() {
        return "create-mnemonic-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        if (!this.mnemonic) {
            throw new router_1.KeplrError("keyring", 272, "mnemonic not set");
        }
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
        // Validate mnemonic.
        // Checksome is not validate in this method.
        // Keeper should handle the case of invalid checksome.
        try {
            bip39.mnemonicToEntropy(this.mnemonic);
        }
        catch (e) {
            if (e.message !== "Invalid mnemonic checksum") {
                throw e;
            }
        }
        keyring_1.KeyRing.validateBIP44Path(this.bip44HDPath);
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return CreateMnemonicKeyMsg.type();
    }
}
exports.CreateMnemonicKeyMsg = CreateMnemonicKeyMsg;
class AddMnemonicKeyMsg extends router_1.Message {
    constructor(kdf, mnemonic, meta, bip44HDPath) {
        super();
        this.kdf = kdf;
        this.mnemonic = mnemonic;
        this.meta = meta;
        this.bip44HDPath = bip44HDPath;
    }
    static type() {
        return "add-mnemonic-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        if (!this.mnemonic) {
            throw new router_1.KeplrError("keyring", 272, "mnemonic not set");
        }
        // Validate mnemonic.
        // Checksome is not validate in this method.
        // Keeper should handle the case of invalid checksome.
        try {
            bip39.mnemonicToEntropy(this.mnemonic);
        }
        catch (e) {
            if (e.message !== "Invalid mnemonic checksum") {
                throw e;
            }
        }
        keyring_1.KeyRing.validateBIP44Path(this.bip44HDPath);
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return AddMnemonicKeyMsg.type();
    }
}
exports.AddMnemonicKeyMsg = AddMnemonicKeyMsg;
class CreatePrivateKeyMsg extends router_1.Message {
    constructor(kdf, privateKey, password, meta) {
        super();
        this.kdf = kdf;
        this.privateKey = privateKey;
        this.password = password;
        this.meta = meta;
    }
    static type() {
        return "create-private-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        if (!this.privateKey || this.privateKey.length === 0) {
            throw new router_1.KeplrError("keyring", 275, "private key not set");
        }
        if (this.privateKey.length !== 32) {
            throw new router_1.KeplrError("keyring", 260, "invalid length of private key");
        }
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return CreatePrivateKeyMsg.type();
    }
}
exports.CreatePrivateKeyMsg = CreatePrivateKeyMsg;
class CreateLedgerKeyMsg extends router_1.Message {
    constructor(kdf, password, meta, bip44HDPath) {
        super();
        this.kdf = kdf;
        this.password = password;
        this.meta = meta;
        this.bip44HDPath = bip44HDPath;
    }
    static type() {
        return "create-ledger-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
        keyring_1.KeyRing.validateBIP44Path(this.bip44HDPath);
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return CreateLedgerKeyMsg.type();
    }
}
exports.CreateLedgerKeyMsg = CreateLedgerKeyMsg;
class AddPrivateKeyMsg extends router_1.Message {
    constructor(kdf, privateKey, meta) {
        super();
        this.kdf = kdf;
        this.privateKey = privateKey;
        this.meta = meta;
    }
    static type() {
        return "add-private-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        if (!this.privateKey || this.privateKey.length === 0) {
            throw new router_1.KeplrError("keyring", 275, "private key not set");
        }
        if (this.privateKey.length !== 32) {
            throw new router_1.KeplrError("keyring", 260, "invalid length of private key");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return AddPrivateKeyMsg.type();
    }
}
exports.AddPrivateKeyMsg = AddPrivateKeyMsg;
class AddLedgerKeyMsg extends router_1.Message {
    constructor(kdf, meta, bip44HDPath) {
        super();
        this.kdf = kdf;
        this.meta = meta;
        this.bip44HDPath = bip44HDPath;
    }
    static type() {
        return "add-ledger-key";
    }
    validateBasic() {
        if (this.kdf !== "scrypt" &&
            this.kdf !== "sha256" &&
            this.kdf !== "pbkdf2") {
            throw new router_1.KeplrError("keyring", 202, "Invalid kdf");
        }
        keyring_1.KeyRing.validateBIP44Path(this.bip44HDPath);
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return AddLedgerKeyMsg.type();
    }
}
exports.AddLedgerKeyMsg = AddLedgerKeyMsg;
class LockKeyRingMsg extends router_1.Message {
    static type() {
        return "lock-keyring";
    }
    constructor() {
        super();
    }
    validateBasic() {
        // noop
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return LockKeyRingMsg.type();
    }
}
exports.LockKeyRingMsg = LockKeyRingMsg;
class UnlockKeyRingMsg extends router_1.Message {
    constructor(password = "") {
        super();
        this.password = password;
    }
    static type() {
        return "unlock-keyring";
    }
    validateBasic() {
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return UnlockKeyRingMsg.type();
    }
}
exports.UnlockKeyRingMsg = UnlockKeyRingMsg;
class GetKeyMsg extends router_1.Message {
    constructor(chainId) {
        super();
        this.chainId = chainId;
    }
    static type() {
        return "get-key";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
    }
    approveExternal() {
        return true;
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return GetKeyMsg.type();
    }
}
exports.GetKeyMsg = GetKeyMsg;
class RequestSignAminoMsg extends router_1.Message {
    constructor(chainId, signer, signDoc, signOptions = {}) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.signDoc = signDoc;
        this.signOptions = signOptions;
    }
    static type() {
        return "request-sign-amino";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
        if (!this.signer) {
            throw new router_1.KeplrError("keyring", 230, "signer not set");
        }
        // Validate bech32 address.
        cosmos_1.Bech32Address.validate(this.signer);
        // Check and validate the ADR-36 sign doc.
        // ADR-36 sign doc doesn't have the chain id
        if (!cosmos_1.checkAndValidateADR36AminoSignDoc(this.signDoc)) {
            if (this.signOptions.ethSignType) {
                throw new Error("Eth sign type can be requested with only ADR-36 amino sign doc");
            }
            if (this.signDoc.chain_id !== this.chainId) {
                throw new router_1.KeplrError("keyring", 234, "Chain id in the message is not matched with the requested chain id");
            }
        }
        else {
            if (this.signDoc.msgs[0].value.signer !== this.signer) {
                throw new router_1.KeplrError("keyring", 233, "Unmatched signer in sign doc");
            }
        }
        if (!this.signOptions) {
            throw new router_1.KeplrError("keyring", 235, "Sign options are null");
        }
    }
    approveExternal() {
        return true;
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return RequestSignAminoMsg.type();
    }
}
exports.RequestSignAminoMsg = RequestSignAminoMsg;
class RequestVerifyADR36AminoSignDoc extends router_1.Message {
    constructor(chainId, signer, data, signature) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.data = data;
        this.signature = signature;
    }
    static type() {
        return "request-verify-adr-36-amino-doc";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
        if (!this.signer) {
            throw new router_1.KeplrError("keyring", 230, "signer not set");
        }
        if (!this.signature) {
            throw new router_1.KeplrError("keyring", 271, "Signature not set");
        }
        // Validate bech32 address.
        cosmos_1.Bech32Address.validate(this.signer);
    }
    approveExternal() {
        return true;
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return RequestVerifyADR36AminoSignDoc.type();
    }
}
exports.RequestVerifyADR36AminoSignDoc = RequestVerifyADR36AminoSignDoc;
class RequestSignDirectMsg extends router_1.Message {
    constructor(chainId, signer, signDoc, signOptions = {}) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.signDoc = signDoc;
        this.signOptions = signOptions;
    }
    static type() {
        return "request-sign-direct";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
        if (!this.signer) {
            throw new router_1.KeplrError("keyring", 230, "signer not set");
        }
        // Validate bech32 address.
        cosmos_1.Bech32Address.validate(this.signer);
        const signDoc = tx_1.SignDoc.fromPartial({
            bodyBytes: this.signDoc.bodyBytes,
            authInfoBytes: this.signDoc.authInfoBytes,
            chainId: this.signDoc.chainId,
            accountNumber: this.signDoc.accountNumber,
        });
        if (signDoc.chainId !== this.chainId) {
            throw new router_1.KeplrError("keyring", 234, "Chain id in the message is not matched with the requested chain id");
        }
        if (!this.signOptions) {
            throw new router_1.KeplrError("keyring", 235, "Sign options are null");
        }
    }
    approveExternal() {
        return true;
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return RequestSignDirectMsg.type();
    }
}
exports.RequestSignDirectMsg = RequestSignDirectMsg;
class GetMultiKeyStoreInfoMsg extends router_1.Message {
    static type() {
        return "get-multi-key-store-info";
    }
    constructor() {
        super();
    }
    validateBasic() {
        // noop
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return GetMultiKeyStoreInfoMsg.type();
    }
}
exports.GetMultiKeyStoreInfoMsg = GetMultiKeyStoreInfoMsg;
class ChangeKeyRingMsg extends router_1.Message {
    constructor(index) {
        super();
        this.index = index;
    }
    static type() {
        return "change-keyring";
    }
    validateBasic() {
        if (this.index < 0) {
            throw new router_1.KeplrError("keyring", 200, "Index is negative");
        }
        if (!Number.isInteger(this.index)) {
            throw new router_1.KeplrError("keyring", 201, "Invalid index");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return ChangeKeyRingMsg.type();
    }
}
exports.ChangeKeyRingMsg = ChangeKeyRingMsg;
// Return the list of selectable path.
// If coin type was set for the key store, will return empty array.
class GetIsKeyStoreCoinTypeSetMsg extends router_1.Message {
    constructor(chainId, paths) {
        super();
        this.chainId = chainId;
        this.paths = paths;
    }
    static type() {
        return "get-is-keystore-coin-type-set";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
        if (this.paths.length === 0) {
            throw new router_1.KeplrError("keyring", 250, "empty bip44 path list");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return GetIsKeyStoreCoinTypeSetMsg.type();
    }
}
exports.GetIsKeyStoreCoinTypeSetMsg = GetIsKeyStoreCoinTypeSetMsg;
class SetKeyStoreCoinTypeMsg extends router_1.Message {
    constructor(chainId, coinType) {
        super();
        this.chainId = chainId;
        this.coinType = coinType;
    }
    static type() {
        return "set-keystore-coin-type";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new router_1.KeplrError("keyring", 270, "chain id not set");
        }
        if (this.coinType < 0) {
            throw new router_1.KeplrError("keyring", 240, "coin type can not be negative");
        }
        if (!Number.isInteger(this.coinType)) {
            throw new router_1.KeplrError("keyring", 241, "coin type should be integer");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return SetKeyStoreCoinTypeMsg.type();
    }
}
exports.SetKeyStoreCoinTypeMsg = SetKeyStoreCoinTypeMsg;
class CheckPasswordMsg extends router_1.Message {
    constructor(password) {
        super();
        this.password = password;
    }
    static type() {
        return "check-keyring-password";
    }
    validateBasic() {
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return CheckPasswordMsg.type();
    }
}
exports.CheckPasswordMsg = CheckPasswordMsg;
class ExportKeyRingDatasMsg extends router_1.Message {
    constructor(password) {
        super();
        this.password = password;
    }
    static type() {
        return "export-keyring-datas";
    }
    validateBasic() {
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 274, "password not set");
        }
    }
    route() {
        return constants_1.ROUTE;
    }
    type() {
        return ExportKeyRingDatasMsg.type();
    }
}
exports.ExportKeyRingDatasMsg = ExportKeyRingDatasMsg;
//# sourceMappingURL=messages.js.map