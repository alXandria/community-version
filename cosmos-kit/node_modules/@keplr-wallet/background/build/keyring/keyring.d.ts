import { KeyStore } from "./crypto";
import { KVStore } from "@keplr-wallet/common";
import { LedgerService } from "../ledger";
import { BIP44HDPath, CommonCrypto, ExportKeyRingData } from "./types";
import { ChainInfo, EthSignType } from "@keplr-wallet/types";
import { Env } from "@keplr-wallet/router";
export declare enum KeyRingStatus {
    NOTLOADED = 0,
    EMPTY = 1,
    LOCKED = 2,
    UNLOCKED = 3
}
export interface Key {
    algo: string;
    pubKey: Uint8Array;
    address: Uint8Array;
    isNanoLedger: boolean;
}
export declare type MultiKeyStoreInfoElem = Pick<KeyStore, "version" | "type" | "meta" | "bip44HDPath" | "coinTypeForChain">;
export declare type MultiKeyStoreInfo = MultiKeyStoreInfoElem[];
export declare type MultiKeyStoreInfoWithSelectedElem = MultiKeyStoreInfoElem & {
    selected: boolean;
};
export declare type MultiKeyStoreInfoWithSelected = MultiKeyStoreInfoWithSelectedElem[];
export declare class KeyRing {
    private readonly embedChainInfos;
    private readonly kvStore;
    private readonly ledgerKeeper;
    private readonly crypto;
    private cached;
    private loaded;
    /**
     * Keyring can have either private key or mnemonic.
     * If keyring has private key, it can't set the BIP 44 path.
     */
    private _privateKey?;
    private _mnemonicMasterSeed?;
    private _ledgerPublicKey?;
    private keyStore;
    private multiKeyStore;
    private password;
    constructor(embedChainInfos: ChainInfo[], kvStore: KVStore, ledgerKeeper: LedgerService, crypto: CommonCrypto);
    static getTypeOfKeyStore(keyStore: Omit<KeyStore, "crypto">): "mnemonic" | "privateKey" | "ledger";
    get type(): "mnemonic" | "privateKey" | "ledger" | "none";
    isLocked(): boolean;
    private get privateKey();
    private set privateKey(value);
    private get mnemonicMasterSeed();
    private set mnemonicMasterSeed(value);
    private get ledgerPublicKey();
    private set ledgerPublicKey(value);
    get status(): KeyRingStatus;
    getKeyStoreCoinType(chainId: string): number | undefined;
    getKey(chainId: string, defaultCoinType: number, useEthereumAddress: boolean): Key;
    getKeyStoreMeta(key: string): string;
    computeKeyStoreCoinType(chainId: string, defaultCoinType: number): number;
    getKeyFromCoinType(coinType: number, useEthereumAddress: boolean): Key;
    createMnemonicKey(kdf: "scrypt" | "sha256" | "pbkdf2", mnemonic: string, password: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    createPrivateKey(kdf: "scrypt" | "sha256" | "pbkdf2", privateKey: Uint8Array, password: string, meta: Record<string, string>): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    createLedgerKey(env: Env, kdf: "scrypt" | "sha256" | "pbkdf2", password: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    lock(): void;
    unlock(password: string): Promise<void>;
    save(): Promise<void>;
    restore(): Promise<void>;
    private updateLegacyKeyStore;
    isKeyStoreCoinTypeSet(chainId: string): boolean;
    setKeyStoreCoinType(chainId: string, coinType: number): Promise<void>;
    removeAllKeyStoreCoinType(chainId: string): void;
    deleteKeyRing(index: number, password: string): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
        keyStoreChanged: boolean;
    }>;
    updateNameKeyRing(index: number, name: string): Promise<MultiKeyStoreInfoWithSelected>;
    private loadKey;
    private loadPrivKey;
    sign(env: Env, chainId: string, defaultCoinType: number, message: Uint8Array, useEthereumSigning: boolean): Promise<Uint8Array>;
    signEthereum(chainId: string, defaultCoinType: number, message: Uint8Array, type?: EthSignType): Promise<Uint8Array>;
    showKeyRing(index: number, password: string): Promise<string>;
    get canSetPath(): boolean;
    addMnemonicKey(kdf: "scrypt" | "sha256" | "pbkdf2", mnemonic: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    addPrivateKey(kdf: "scrypt" | "sha256" | "pbkdf2", privateKey: Uint8Array, meta: Record<string, string>): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    addLedgerKey(env: Env, kdf: "scrypt" | "sha256" | "pbkdf2", meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    changeKeyStoreFromMultiKeyStore(index: number): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    getMultiKeyStoreInfo(): MultiKeyStoreInfoWithSelected;
    checkPassword(password: string): boolean;
    exportKeyRingDatas(password: string): Promise<ExportKeyRingData[]>;
    private static CreateMnemonicKeyStore;
    private static CreatePrivateKeyStore;
    private static CreateLedgerKeyStore;
    private assignKeyStoreIdMeta;
    private static getKeyStoreId;
    private static getKeyStoreBIP44Path;
    static validateBIP44Path(bip44Path: BIP44HDPath): void;
    private getIncrementalNumber;
}
