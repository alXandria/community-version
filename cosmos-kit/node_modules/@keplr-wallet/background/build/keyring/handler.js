"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHandler = void 0;
const router_1 = require("@keplr-wallet/router");
const messages_1 = require("./messages");
const cosmos_1 = require("@keplr-wallet/cosmos");
const tx_1 = require("@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx");
const getHandler = (service) => {
    return (env, msg) => {
        switch (msg.constructor) {
            case messages_1.RestoreKeyRingMsg:
                return handleRestoreKeyRingMsg(service)(env, msg);
            case messages_1.DeleteKeyRingMsg:
                return handleDeleteKeyRingMsg(service)(env, msg);
            case messages_1.UpdateNameKeyRingMsg:
                return handleUpdateNameKeyRingMsg(service)(env, msg);
            case messages_1.ShowKeyRingMsg:
                return handleShowKeyRingMsg(service)(env, msg);
            case messages_1.CreateMnemonicKeyMsg:
                return handleCreateMnemonicKeyMsg(service)(env, msg);
            case messages_1.AddMnemonicKeyMsg:
                return handleAddMnemonicKeyMsg(service)(env, msg);
            case messages_1.CreatePrivateKeyMsg:
                return handleCreatePrivateKeyMsg(service)(env, msg);
            case messages_1.AddPrivateKeyMsg:
                return handleAddPrivateKeyMsg(service)(env, msg);
            case messages_1.CreateLedgerKeyMsg:
                return handleCreateLedgerKeyMsg(service)(env, msg);
            case messages_1.AddLedgerKeyMsg:
                return handleAddLedgerKeyMsg(service)(env, msg);
            case messages_1.LockKeyRingMsg:
                return handleLockKeyRingMsg(service)(env, msg);
            case messages_1.UnlockKeyRingMsg:
                return handleUnlockKeyRingMsg(service)(env, msg);
            case messages_1.GetKeyMsg:
                return handleGetKeyMsg(service)(env, msg);
            case messages_1.RequestSignAminoMsg:
                return handleRequestSignAminoMsg(service)(env, msg);
            case messages_1.RequestVerifyADR36AminoSignDoc:
                return handleRequestVerifyADR36AminoSignDoc(service)(env, msg);
            case messages_1.RequestSignDirectMsg:
                return handleRequestSignDirectMsg(service)(env, msg);
            case messages_1.GetMultiKeyStoreInfoMsg:
                return handleGetMultiKeyStoreInfoMsg(service)(env, msg);
            case messages_1.ChangeKeyRingMsg:
                return handleChangeKeyRingMsg(service)(env, msg);
            case messages_1.GetIsKeyStoreCoinTypeSetMsg:
                return handleGetIsKeyStoreCoinTypeSetMsg(service)(env, msg);
            case messages_1.SetKeyStoreCoinTypeMsg:
                return handleSetKeyStoreCoinTypeMsg(service)(env, msg);
            case messages_1.CheckPasswordMsg:
                return handleCheckPasswordMsg(service)(env, msg);
            case messages_1.ExportKeyRingDatasMsg:
                return handleExportKeyRingDatasMsg(service)(env, msg);
            default:
                throw new router_1.KeplrError("keyring", 221, "Unknown msg type");
        }
    };
};
exports.getHandler = getHandler;
const handleRestoreKeyRingMsg = (service) => {
    return (_env, _msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.restore();
    });
};
const handleDeleteKeyRingMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.deleteKeyRing(msg.index, msg.password);
    });
};
const handleUpdateNameKeyRingMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.updateNameKeyRing(msg.index, msg.name);
    });
};
const handleShowKeyRingMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.showKeyRing(msg.index, msg.password);
    });
};
const handleCreateMnemonicKeyMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.createMnemonicKey(msg.kdf, msg.mnemonic, msg.password, msg.meta, msg.bip44HDPath);
    });
};
const handleAddMnemonicKeyMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.addMnemonicKey(msg.kdf, msg.mnemonic, msg.meta, msg.bip44HDPath);
    });
};
const handleCreatePrivateKeyMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.createPrivateKey(msg.kdf, msg.privateKey, msg.password, msg.meta);
    });
};
const handleAddPrivateKeyMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.addPrivateKey(msg.kdf, msg.privateKey, msg.meta);
    });
};
const handleCreateLedgerKeyMsg = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.createLedgerKey(env, msg.kdf, msg.password, msg.meta, msg.bip44HDPath);
    });
};
const handleAddLedgerKeyMsg = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.addLedgerKey(env, msg.kdf, msg.meta, msg.bip44HDPath);
    });
};
const handleLockKeyRingMsg = (service) => {
    return () => {
        return {
            status: service.lock(),
        };
    };
};
const handleUnlockKeyRingMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return {
            status: yield service.unlock(msg.password),
        };
    });
};
const handleGetKeyMsg = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);
        const key = yield service.getKey(msg.chainId);
        return {
            name: service.getKeyStoreMeta("name"),
            algo: "secp256k1",
            pubKey: key.pubKey,
            address: key.address,
            bech32Address: new cosmos_1.Bech32Address(key.address).toBech32((yield service.chainsService.getChainInfo(msg.chainId)).bech32Config
                .bech32PrefixAccAddr),
            isNanoLedger: key.isNanoLedger,
        };
    });
};
const handleRequestSignAminoMsg = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);
        return yield service.requestSignAmino(env, msg.origin, msg.chainId, msg.signer, msg.signDoc, msg.signOptions);
    });
};
const handleRequestVerifyADR36AminoSignDoc = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);
        return yield service.verifyADR36AminoSignDoc(msg.chainId, msg.signer, msg.data, msg.signature);
    });
};
const handleRequestSignDirectMsg = (service) => {
    return (env, msg) => __awaiter(void 0, void 0, void 0, function* () {
        yield service.permissionService.checkOrGrantBasicAccessPermission(env, msg.chainId, msg.origin);
        const signDoc = tx_1.SignDoc.fromPartial({
            bodyBytes: msg.signDoc.bodyBytes,
            authInfoBytes: msg.signDoc.authInfoBytes,
            chainId: msg.signDoc.chainId,
            accountNumber: msg.signDoc.accountNumber,
        });
        const response = yield service.requestSignDirect(env, msg.origin, msg.chainId, msg.signer, signDoc, msg.signOptions);
        return {
            signed: {
                bodyBytes: response.signed.bodyBytes,
                authInfoBytes: response.signed.authInfoBytes,
                chainId: response.signed.chainId,
                accountNumber: response.signed.accountNumber.toString(),
            },
            signature: response.signature,
        };
    });
};
const handleGetMultiKeyStoreInfoMsg = (service) => {
    return () => {
        return {
            multiKeyStoreInfo: service.getMultiKeyStoreInfo(),
        };
    };
};
const handleChangeKeyRingMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.changeKeyStoreFromMultiKeyStore(msg.index);
    });
};
const handleGetIsKeyStoreCoinTypeSetMsg = (service) => {
    return (_, msg) => {
        return service.getKeyStoreBIP44Selectables(msg.chainId, msg.paths);
    };
};
const handleSetKeyStoreCoinTypeMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        yield service.setKeyStoreCoinType(msg.chainId, msg.coinType);
        return service.keyRingStatus;
    });
};
const handleCheckPasswordMsg = (service) => {
    return (_, msg) => {
        return service.checkPassword(msg.password);
    };
};
const handleExportKeyRingDatasMsg = (service) => {
    return (_, msg) => __awaiter(void 0, void 0, void 0, function* () {
        return yield service.exportKeyRingDatas(msg.password);
    });
};
//# sourceMappingURL=handler.js.map