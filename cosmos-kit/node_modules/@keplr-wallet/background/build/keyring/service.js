"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyRingService = void 0;
const keyring_1 = require("./keyring");
const cosmos_1 = require("@keplr-wallet/cosmos");
const common_1 = require("@keplr-wallet/common");
const router_1 = require("@keplr-wallet/router");
const launchpad_1 = require("@cosmjs/launchpad");
const proto_signing_1 = require("@cosmjs/proto-signing");
const tx_1 = require("@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx");
const long_1 = __importDefault(require("long"));
const buffer_1 = require("buffer/");
class KeyRingService {
    constructor(kvStore, embedChainInfos, crypto) {
        this.kvStore = kvStore;
        this.embedChainInfos = embedChainInfos;
        this.crypto = crypto;
        this.onChainRemoved = (chainId) => {
            this.keyRing.removeAllKeyStoreCoinType(chainId);
        };
    }
    init(interactionService, chainsService, permissionService, ledgerService) {
        this.interactionService = interactionService;
        this.chainsService = chainsService;
        this.permissionService = permissionService;
        this.keyRing = new keyring_1.KeyRing(this.embedChainInfos, this.kvStore, ledgerService, this.crypto);
        this.chainsService.addChainRemovedHandler(this.onChainRemoved);
    }
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.keyRing.restore();
            return {
                status: this.keyRing.status,
                multiKeyStoreInfo: this.keyRing.getMultiKeyStoreInfo(),
            };
        });
    }
    enable(env) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keyRing.status === keyring_1.KeyRingStatus.EMPTY) {
                throw new router_1.KeplrError("keyring", 261, "key doesn't exist");
            }
            if (this.keyRing.status === keyring_1.KeyRingStatus.NOTLOADED) {
                yield this.keyRing.restore();
            }
            if (this.keyRing.status === keyring_1.KeyRingStatus.LOCKED) {
                yield this.interactionService.waitApprove(env, "/unlock", "unlock", {});
                return this.keyRing.status;
            }
            return this.keyRing.status;
        });
    }
    get keyRingStatus() {
        return this.keyRing.status;
    }
    deleteKeyRing(index, password) {
        return __awaiter(this, void 0, void 0, function* () {
            let keyStoreChanged = false;
            try {
                const result = yield this.keyRing.deleteKeyRing(index, password);
                keyStoreChanged = result.keyStoreChanged;
                return {
                    multiKeyStoreInfo: result.multiKeyStoreInfo,
                    status: this.keyRing.status,
                };
            }
            finally {
                if (keyStoreChanged) {
                    this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, "keystore-changed", {});
                }
            }
        });
    }
    updateNameKeyRing(index, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const multiKeyStoreInfo = yield this.keyRing.updateNameKeyRing(index, name);
            return {
                multiKeyStoreInfo,
            };
        });
    }
    showKeyRing(index, password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.keyRing.showKeyRing(index, password);
        });
    }
    createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Check mnemonic checksum.
            return yield this.keyRing.createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath);
        });
    }
    createPrivateKey(kdf, privateKey, password, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.keyRing.createPrivateKey(kdf, privateKey, password, meta);
        });
    }
    createLedgerKey(env, kdf, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.keyRing.createLedgerKey(env, kdf, password, meta, bip44HDPath);
        });
    }
    lock() {
        this.keyRing.lock();
        return this.keyRing.status;
    }
    unlock(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.keyRing.unlock(password);
            return this.keyRing.status;
        });
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyRing.getKey(chainId, yield this.chainsService.getChainCoinType(chainId), (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).address);
        });
    }
    getKeyStoreMeta(key) {
        return this.keyRing.getKeyStoreMeta(key);
    }
    getKeyRingType() {
        return this.keyRing.type;
    }
    requestSignAmino(env, msgOrigin, chainId, signer, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            signDoc = Object.assign(Object.assign({}, signDoc), { memo: common_1.escapeHTML(signDoc.memo) });
            const coinType = yield this.chainsService.getChainCoinType(chainId);
            const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);
            const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);
            const bech32Prefix = (yield this.chainsService.getChainInfo(chainId))
                .bech32Config.bech32PrefixAccAddr;
            const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(bech32Prefix);
            if (signer !== bech32Address) {
                throw new router_1.KeplrError("keyring", 231, "Signer mismatched");
            }
            const isADR36SignDoc = cosmos_1.checkAndValidateADR36AminoSignDoc(signDoc, bech32Prefix);
            if (isADR36SignDoc) {
                if (signDoc.msgs[0].value.signer !== signer) {
                    throw new router_1.KeplrError("keyring", 233, "Unmatched signer in sign doc");
                }
            }
            if (signOptions.isADR36WithString != null && !isADR36SignDoc) {
                throw new router_1.KeplrError("keyring", 236, 'Sign doc is not for ADR-36. But, "isADR36WithString" option is defined');
            }
            if (signOptions.ethSignType && !isADR36SignDoc) {
                throw new Error("Eth sign type can be requested with only ADR-36 amino sign doc");
            }
            let newSignDoc = (yield this.interactionService.waitApprove(env, "/sign", "request-sign", {
                msgOrigin,
                chainId,
                mode: "amino",
                signDoc,
                signer,
                signOptions,
                isADR36SignDoc,
                isADR36WithString: signOptions.isADR36WithString,
                ethSignType: signOptions.ethSignType,
            }));
            newSignDoc = Object.assign(Object.assign({}, newSignDoc), { memo: common_1.escapeHTML(newSignDoc.memo) });
            if (isADR36SignDoc) {
                // Validate the new sign doc, if it was for ADR-36.
                if (cosmos_1.checkAndValidateADR36AminoSignDoc(signDoc, bech32Prefix)) {
                    if (signDoc.msgs[0].value.signer !== signer) {
                        throw new router_1.KeplrError("keyring", 232, "Unmatched signer in new sign doc");
                    }
                }
                else {
                    throw new router_1.KeplrError("keyring", 237, "Signing request was for ADR-36. But, accidentally, new sign doc is not for ADR-36");
                }
            }
            // Handle Ethereum signing
            if (signOptions.ethSignType) {
                if (newSignDoc.msgs.length !== 1) {
                    // Validate number of messages
                    throw new Error("Invalid number of messages for Ethereum sign request");
                }
                const signBytes = buffer_1.Buffer.from(newSignDoc.msgs[0].value.data, "base64");
                try {
                    const signatureBytes = yield this.keyRing.signEthereum(chainId, coinType, signBytes, signOptions.ethSignType);
                    return {
                        signed: newSignDoc,
                        signature: {
                            pub_key: launchpad_1.encodeSecp256k1Pubkey(key.pubKey),
                            signature: buffer_1.Buffer.from(signatureBytes).toString("base64"),
                        },
                    };
                }
                finally {
                    this.interactionService.dispatchEvent(router_1.APP_PORT, "request-sign-end", {});
                }
            }
            try {
                const signature = yield this.keyRing.sign(env, chainId, coinType, launchpad_1.serializeSignDoc(newSignDoc), ethereumKeyFeatures.signing);
                return {
                    signed: newSignDoc,
                    signature: launchpad_1.encodeSecp256k1Signature(key.pubKey, signature),
                };
            }
            finally {
                this.interactionService.dispatchEvent(router_1.APP_PORT, "request-sign-end", {});
            }
        });
    }
    requestSignDirect(env, msgOrigin, chainId, signer, signDoc, signOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinType = yield this.chainsService.getChainCoinType(chainId);
            const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);
            const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);
            const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32((yield this.chainsService.getChainInfo(chainId)).bech32Config
                .bech32PrefixAccAddr);
            if (signer !== bech32Address) {
                throw new router_1.KeplrError("keyring", 231, "Signer mismatched");
            }
            const newSignDocBytes = (yield this.interactionService.waitApprove(env, "/sign", "request-sign", {
                msgOrigin,
                chainId,
                mode: "direct",
                signDocBytes: tx_1.SignDoc.encode(signDoc).finish(),
                signer,
                signOptions,
            }));
            const newSignDoc = tx_1.SignDoc.decode(newSignDocBytes);
            const { accountNumber: newSignDocAccountNumber } = newSignDoc, newSignDocRest = __rest(newSignDoc, ["accountNumber"]);
            const cosmJSSignDoc = Object.assign(Object.assign({}, newSignDocRest), { accountNumber: long_1.default.fromString(newSignDocAccountNumber) });
            try {
                const signature = yield this.keyRing.sign(env, chainId, coinType, proto_signing_1.makeSignBytes(cosmJSSignDoc), ethereumKeyFeatures.signing);
                return {
                    signed: cosmJSSignDoc,
                    signature: launchpad_1.encodeSecp256k1Signature(key.pubKey, signature),
                };
            }
            finally {
                this.interactionService.dispatchEvent(router_1.APP_PORT, "request-sign-end", {});
            }
        });
    }
    verifyADR36AminoSignDoc(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinType = yield this.chainsService.getChainCoinType(chainId);
            const ethereumKeyFeatures = yield this.chainsService.getChainEthereumKeyFeatures(chainId);
            const key = yield this.keyRing.getKey(chainId, coinType, ethereumKeyFeatures.address);
            const bech32Prefix = (yield this.chainsService.getChainInfo(chainId))
                .bech32Config.bech32PrefixAccAddr;
            const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(bech32Prefix);
            if (signer !== bech32Address) {
                throw new router_1.KeplrError("keyring", 231, "Signer mismatched");
            }
            if (signature.pub_key.type !== "tendermint/PubKeySecp256k1") {
                throw new router_1.KeplrError("keyring", 211, `Unsupported type of pub key: ${signature.pub_key.type}`);
            }
            if (buffer_1.Buffer.from(key.pubKey).toString("base64") !== signature.pub_key.value) {
                throw new router_1.KeplrError("keyring", 210, "Pub key unmatched");
            }
            const signDoc = cosmos_1.makeADR36AminoSignDoc(signer, data);
            return cosmos_1.verifyADR36AminoSignDoc(bech32Prefix, signDoc, buffer_1.Buffer.from(signature.pub_key.value, "base64"), buffer_1.Buffer.from(signature.signature, "base64"));
        });
    }
    sign(env, chainId, message) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyRing.sign(env, chainId, yield this.chainsService.getChainCoinType(chainId), message, (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).signing);
        });
    }
    addMnemonicKey(kdf, mnemonic, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyRing.addMnemonicKey(kdf, mnemonic, meta, bip44HDPath);
        });
    }
    addPrivateKey(kdf, privateKey, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyRing.addPrivateKey(kdf, privateKey, meta);
        });
    }
    addLedgerKey(env, kdf, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyRing.addLedgerKey(env, kdf, meta, bip44HDPath);
        });
    }
    changeKeyStoreFromMultiKeyStore(index) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.keyRing.changeKeyStoreFromMultiKeyStore(index);
            }
            finally {
                this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, "keystore-changed", {});
            }
        });
    }
    checkPassword(password) {
        return this.keyRing.checkPassword(password);
    }
    getMultiKeyStoreInfo() {
        return this.keyRing.getMultiKeyStoreInfo();
    }
    isKeyStoreCoinTypeSet(chainId) {
        return this.keyRing.isKeyStoreCoinTypeSet(chainId);
    }
    setKeyStoreCoinType(chainId, coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            const prevCoinType = this.keyRing.computeKeyStoreCoinType(chainId, yield this.chainsService.getChainCoinType(chainId));
            yield this.keyRing.setKeyStoreCoinType(chainId, coinType);
            if (prevCoinType !== coinType) {
                this.interactionService.dispatchEvent(router_1.WEBPAGE_PORT, "keystore-changed", {});
            }
        });
    }
    getKeyStoreBIP44Selectables(chainId, paths) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isKeyStoreCoinTypeSet(chainId)) {
                return [];
            }
            const result = [];
            const chainInfo = yield this.chainsService.getChainInfo(chainId);
            for (const path of paths) {
                const key = yield this.keyRing.getKeyFromCoinType(path.coinType, (yield this.chainsService.getChainEthereumKeyFeatures(chainId)).address);
                const bech32Address = new cosmos_1.Bech32Address(key.address).toBech32(chainInfo.bech32Config.bech32PrefixAccAddr);
                result.push({
                    path,
                    bech32Address,
                });
            }
            return result;
        });
    }
    exportKeyRingDatas(password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.keyRing.exportKeyRingDatas(password);
        });
    }
}
exports.KeyRingService = KeyRingService;
//# sourceMappingURL=service.js.map