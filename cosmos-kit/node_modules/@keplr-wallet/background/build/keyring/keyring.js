"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyRing = exports.KeyRingStatus = void 0;
const crypto_1 = require("./crypto");
const crypto_2 = require("@keplr-wallet/crypto");
const types_1 = require("@keplr-wallet/types");
const router_1 = require("@keplr-wallet/router");
const buffer_1 = require("buffer/");
const cosmos_1 = require("@keplr-wallet/cosmos");
const wallet_1 = require("@ethersproject/wallet");
const BytesUtils = __importStar(require("@ethersproject/bytes"));
const address_converter_1 = require("@tharsis/address-converter");
const keccak256_1 = require("@ethersproject/keccak256");
var KeyRingStatus;
(function (KeyRingStatus) {
    KeyRingStatus[KeyRingStatus["NOTLOADED"] = 0] = "NOTLOADED";
    KeyRingStatus[KeyRingStatus["EMPTY"] = 1] = "EMPTY";
    KeyRingStatus[KeyRingStatus["LOCKED"] = 2] = "LOCKED";
    KeyRingStatus[KeyRingStatus["UNLOCKED"] = 3] = "UNLOCKED";
})(KeyRingStatus = exports.KeyRingStatus || (exports.KeyRingStatus = {}));
const KeyStoreKey = "key-store";
const KeyMultiStoreKey = "key-multi-store";
/*
 Keyring stores keys in persistent backround.
 And, this manages the state, crypto, address, signing and so on...
 */
class KeyRing {
    constructor(embedChainInfos, kvStore, ledgerKeeper, crypto) {
        this.embedChainInfos = embedChainInfos;
        this.kvStore = kvStore;
        this.ledgerKeeper = ledgerKeeper;
        this.crypto = crypto;
        this.cached = new Map();
        this.password = "";
        this.loaded = false;
        this.keyStore = null;
        this.multiKeyStore = [];
    }
    static getTypeOfKeyStore(keyStore) {
        const type = keyStore.type;
        if (type == null) {
            return "mnemonic";
        }
        if (type !== "mnemonic" && type !== "privateKey" && type !== "ledger") {
            throw new router_1.KeplrError("keyring", 132, "Invalid type of key store");
        }
        return type;
    }
    get type() {
        if (!this.keyStore) {
            return "none";
        }
        else {
            return KeyRing.getTypeOfKeyStore(this.keyStore);
        }
    }
    isLocked() {
        return (this.privateKey == null &&
            this.mnemonicMasterSeed == null &&
            this.ledgerPublicKey == null);
    }
    get privateKey() {
        return this._privateKey;
    }
    set privateKey(privateKey) {
        this._privateKey = privateKey;
        this._mnemonicMasterSeed = undefined;
        this._ledgerPublicKey = undefined;
        this.cached = new Map();
    }
    get mnemonicMasterSeed() {
        return this._mnemonicMasterSeed;
    }
    set mnemonicMasterSeed(masterSeed) {
        this._mnemonicMasterSeed = masterSeed;
        this._privateKey = undefined;
        this._ledgerPublicKey = undefined;
        this.cached = new Map();
    }
    get ledgerPublicKey() {
        return this._ledgerPublicKey;
    }
    set ledgerPublicKey(publicKey) {
        this._mnemonicMasterSeed = undefined;
        this._privateKey = undefined;
        this._ledgerPublicKey = publicKey;
        this.cached = new Map();
    }
    get status() {
        if (!this.loaded) {
            return KeyRingStatus.NOTLOADED;
        }
        if (!this.keyStore) {
            return KeyRingStatus.EMPTY;
        }
        else if (!this.isLocked()) {
            return KeyRingStatus.UNLOCKED;
        }
        else {
            return KeyRingStatus.LOCKED;
        }
    }
    getKeyStoreCoinType(chainId) {
        if (!this.keyStore) {
            return undefined;
        }
        if (!this.keyStore.coinTypeForChain) {
            return undefined;
        }
        return this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier];
    }
    getKey(chainId, defaultCoinType, useEthereumAddress) {
        return this.loadKey(this.computeKeyStoreCoinType(chainId, defaultCoinType), useEthereumAddress);
    }
    getKeyStoreMeta(key) {
        var _a;
        if (!this.keyStore || this.keyStore.meta == null) {
            return "";
        }
        return (_a = this.keyStore.meta[key]) !== null && _a !== void 0 ? _a : "";
    }
    computeKeyStoreCoinType(chainId, defaultCoinType) {
        var _a;
        if (!this.keyStore) {
            throw new router_1.KeplrError("keyring", 130, "Key store is empty");
        }
        return this.keyStore.coinTypeForChain
            ? (_a = this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier]) !== null && _a !== void 0 ? _a : defaultCoinType : defaultCoinType;
    }
    getKeyFromCoinType(coinType, useEthereumAddress) {
        return this.loadKey(coinType, useEthereumAddress);
    }
    createMnemonicKey(kdf, mnemonic, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.EMPTY) {
                throw new router_1.KeplrError("keyring", 142, "Key ring is not loaded or not empty");
            }
            this.mnemonicMasterSeed = crypto_2.Mnemonic.generateMasterSeedFromMnemonic(mnemonic);
            this.keyStore = yield KeyRing.CreateMnemonicKeyStore(this.crypto, kdf, mnemonic, password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);
            this.password = password;
            this.multiKeyStore.push(this.keyStore);
            yield this.save();
            return {
                status: this.status,
                multiKeyStoreInfo: yield this.getMultiKeyStoreInfo(),
            };
        });
    }
    createPrivateKey(kdf, privateKey, password, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.EMPTY) {
                throw new router_1.KeplrError("keyring", 142, "Key ring is not loaded or not empty");
            }
            this.privateKey = privateKey;
            this.keyStore = yield KeyRing.CreatePrivateKeyStore(this.crypto, kdf, privateKey, password, yield this.assignKeyStoreIdMeta(meta));
            this.password = password;
            this.multiKeyStore.push(this.keyStore);
            yield this.save();
            return {
                status: this.status,
                multiKeyStoreInfo: yield this.getMultiKeyStoreInfo(),
            };
        });
    }
    createLedgerKey(env, kdf, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.EMPTY) {
                throw new router_1.KeplrError("keyring", 142, "Key ring is not loaded or not empty");
            }
            // Get public key first
            this.ledgerPublicKey = yield this.ledgerKeeper.getPublicKey(env, bip44HDPath);
            const keyStore = yield KeyRing.CreateLedgerKeyStore(this.crypto, kdf, this.ledgerPublicKey, password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);
            this.password = password;
            this.keyStore = keyStore;
            this.multiKeyStore.push(this.keyStore);
            yield this.save();
            return {
                status: this.status,
                multiKeyStoreInfo: yield this.getMultiKeyStoreInfo(),
            };
        });
    }
    lock() {
        if (this.status !== KeyRingStatus.UNLOCKED) {
            throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
        }
        this.mnemonicMasterSeed = undefined;
        this.privateKey = undefined;
        this.ledgerPublicKey = undefined;
        this.password = "";
    }
    unlock(password) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyStore || this.type === "none") {
                throw new router_1.KeplrError("keyring", 144, "Key ring not initialized");
            }
            if (this.type === "mnemonic") {
                // If password is invalid, error will be thrown.
                this.mnemonicMasterSeed = crypto_2.Mnemonic.generateMasterSeedFromMnemonic(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString());
            }
            else if (this.type === "privateKey") {
                // If password is invalid, error will be thrown.
                this.privateKey = buffer_1.Buffer.from(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString(), "hex");
            }
            else if (this.type === "ledger") {
                this.ledgerPublicKey = buffer_1.Buffer.from(buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, this.keyStore, password)).toString(), "hex");
            }
            else {
                throw new router_1.KeplrError("keyring", 145, "Unexpected type of keyring");
            }
            this.password = password;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set(KeyStoreKey, this.keyStore);
            yield this.kvStore.set(KeyMultiStoreKey, this.multiKeyStore);
        });
    }
    restore() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyStore = yield this.kvStore.get(KeyStoreKey);
            if (!keyStore) {
                this.keyStore = null;
            }
            else {
                this.keyStore = keyStore;
            }
            const multiKeyStore = yield this.kvStore.get(KeyMultiStoreKey);
            if (!multiKeyStore) {
                // Restore the multi keystore if key store exist 13t multi Key store is empty.
                // This case will occur if extension is updated from the prior version that doesn't support the multi key store.
                // This line ensures the backward compatibility.
                if (keyStore) {
                    keyStore.meta = yield this.assignKeyStoreIdMeta({});
                    this.multiKeyStore = [keyStore];
                }
                else {
                    this.multiKeyStore = [];
                }
                yield this.save();
            }
            else {
                this.multiKeyStore = multiKeyStore;
            }
            let hasLegacyKeyStore = false;
            // In prior of version 1.2, bip44 path didn't tie with the keystore, and bip44 exists on the chain info.
            // But, after some chain matures, they decided the bip44 path's coin type.
            // So, some chain can have the multiple bip44 coin type (one is the standard coin type and other is the legacy coin type).
            // We should support the legacy coin type, so we determined that the coin type ties with the keystore.
            // To decrease the barrier of existing users, set the alternative coin type by force if the keystore version is prior than 1.2.
            if (this.keyStore) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                if (this.keyStore.version === "1" || this.keyStore.version === "1.1") {
                    hasLegacyKeyStore = true;
                    this.updateLegacyKeyStore(this.keyStore);
                }
            }
            for (const keyStore of this.multiKeyStore) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                if (keyStore.version === "1" || keyStore.version === "1.1") {
                    hasLegacyKeyStore = true;
                    this.updateLegacyKeyStore(keyStore);
                }
            }
            if (hasLegacyKeyStore) {
                yield this.save();
            }
            this.loaded = true;
        });
    }
    updateLegacyKeyStore(keyStore) {
        keyStore.version = "1.2";
        for (const chainInfo of this.embedChainInfos) {
            const coinType = (() => {
                if (chainInfo.alternativeBIP44s &&
                    chainInfo.alternativeBIP44s.length > 0) {
                    return chainInfo.alternativeBIP44s[0].coinType;
                }
                else {
                    return chainInfo.bip44.coinType;
                }
            })();
            keyStore.coinTypeForChain = Object.assign(Object.assign({}, keyStore.coinTypeForChain), { [cosmos_1.ChainIdHelper.parse(chainInfo.chainId).identifier]: coinType });
        }
    }
    isKeyStoreCoinTypeSet(chainId) {
        if (!this.keyStore) {
            throw new router_1.KeplrError("keyring", 130, "Key store is empty");
        }
        return (this.keyStore.coinTypeForChain &&
            this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier] !== undefined);
    }
    setKeyStoreCoinType(chainId, coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            if (this.keyStore.coinTypeForChain &&
                this.keyStore.coinTypeForChain[cosmos_1.ChainIdHelper.parse(chainId).identifier] !== undefined) {
                throw new router_1.KeplrError("keyring", 110, "Coin type already set");
            }
            this.keyStore.coinTypeForChain = Object.assign(Object.assign({}, this.keyStore.coinTypeForChain), { [cosmos_1.ChainIdHelper.parse(chainId).identifier]: coinType });
            const keyStoreInMulti = this.multiKeyStore.find((keyStore) => {
                return (KeyRing.getKeyStoreId(keyStore) ===
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    KeyRing.getKeyStoreId(this.keyStore));
            });
            if (keyStoreInMulti) {
                keyStoreInMulti.coinTypeForChain = Object.assign({}, this.keyStore.coinTypeForChain);
            }
            yield this.save();
        });
    }
    removeAllKeyStoreCoinType(chainId) {
        var _a, _b;
        const identifier = cosmos_1.ChainIdHelper.parse(chainId).identifier;
        if (this.keyStore) {
            const coinTypeForChain = (_a = this.keyStore.coinTypeForChain) !== null && _a !== void 0 ? _a : {};
            delete coinTypeForChain[identifier];
            this.keyStore.coinTypeForChain = coinTypeForChain;
        }
        for (const keyStore of this.multiKeyStore) {
            const coinTypeForChain = (_b = keyStore.coinTypeForChain) !== null && _b !== void 0 ? _b : {};
            delete coinTypeForChain[identifier];
            keyStore.coinTypeForChain = coinTypeForChain;
        }
        this.save();
    }
    deleteKeyRing(index, password) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED) {
                throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
            }
            if (this.password !== password) {
                throw new router_1.KeplrError("keyring", 121, "Invalid password");
            }
            const keyStore = this.multiKeyStore[index];
            if (!keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            const multiKeyStore = this.multiKeyStore
                .slice(0, index)
                .concat(this.multiKeyStore.slice(index + 1));
            // Make sure that password is valid.
            yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password);
            let keyStoreChanged = false;
            if (this.keyStore) {
                // If key store is currently selected key store
                if (KeyRing.getKeyStoreId(keyStore) === KeyRing.getKeyStoreId(this.keyStore)) {
                    // If there is a key store left
                    if (multiKeyStore.length > 0) {
                        // Lock key store at first
                        yield this.lock();
                        // Select first key store
                        this.keyStore = multiKeyStore[0];
                        // And unlock it
                        yield this.unlock(password);
                    }
                    else {
                        // Else clear keyring.
                        this.keyStore = null;
                        this.mnemonicMasterSeed = undefined;
                        this.privateKey = undefined;
                        this.ledgerPublicKey = undefined;
                    }
                    keyStoreChanged = true;
                }
            }
            this.multiKeyStore = multiKeyStore;
            yield this.save();
            return {
                multiKeyStoreInfo: this.getMultiKeyStoreInfo(),
                keyStoreChanged,
            };
        });
    }
    updateNameKeyRing(index, name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED) {
                throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
            }
            const keyStore = this.multiKeyStore[index];
            if (!keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            keyStore.meta = Object.assign(Object.assign({}, keyStore.meta), { name: name });
            // If select key store and changed store are same, sync keystore
            if (this.keyStore &&
                KeyRing.getKeyStoreId(this.keyStore) === KeyRing.getKeyStoreId(keyStore)) {
                this.keyStore = keyStore;
            }
            yield this.save();
            return this.getMultiKeyStoreInfo();
        });
    }
    loadKey(coinType, useEthereumAddress = false) {
        if (this.status !== KeyRingStatus.UNLOCKED) {
            throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
        }
        if (!this.keyStore) {
            throw new router_1.KeplrError("keyring", 130, "Key store is empty");
        }
        if (this.keyStore.type === "ledger") {
            if (!this.ledgerPublicKey) {
                throw new router_1.KeplrError("keyring", 150, "Ledger public key not set");
            }
            if (useEthereumAddress) {
                throw new router_1.KeplrError("keyring", 152, "Ledger is not compatible with this coinType right now");
            }
            const pubKey = new crypto_2.PubKeySecp256k1(this.ledgerPublicKey);
            return {
                algo: "secp256k1",
                pubKey: pubKey.toBytes(),
                address: pubKey.getAddress(),
                isNanoLedger: true,
            };
        }
        else {
            const privKey = this.loadPrivKey(coinType);
            const pubKey = privKey.getPubKey();
            if (useEthereumAddress) {
                // For Ethereum Key-Gen Only:
                const wallet = new wallet_1.Wallet(privKey.toBytes());
                const ethereumAddress = address_converter_1.ETH.decoder(wallet.address);
                return {
                    algo: "ethsecp256k1",
                    pubKey: pubKey.toBytes(),
                    address: ethereumAddress,
                    isNanoLedger: false,
                };
            }
            // Default
            return {
                algo: "secp256k1",
                pubKey: pubKey.toBytes(),
                address: pubKey.getAddress(),
                isNanoLedger: false,
            };
        }
    }
    loadPrivKey(coinType) {
        if (this.status !== KeyRingStatus.UNLOCKED ||
            this.type === "none" ||
            !this.keyStore) {
            throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
        }
        const bip44HDPath = KeyRing.getKeyStoreBIP44Path(this.keyStore);
        if (this.type === "mnemonic") {
            const path = `m/44'/${coinType}'/${bip44HDPath.account}'/${bip44HDPath.change}/${bip44HDPath.addressIndex}`;
            const cachedKey = this.cached.get(path);
            if (cachedKey) {
                return new crypto_2.PrivKeySecp256k1(cachedKey);
            }
            if (!this.mnemonicMasterSeed) {
                throw new router_1.KeplrError("keyring", 133, "Key store type is mnemonic and it is unlocked. But, mnemonic is not loaded unexpectedly");
            }
            const privKey = crypto_2.Mnemonic.generatePrivateKeyFromMasterSeed(this.mnemonicMasterSeed, path);
            this.cached.set(path, privKey);
            return new crypto_2.PrivKeySecp256k1(privKey);
        }
        else if (this.type === "privateKey") {
            // If key store type is private key, path will be ignored.
            if (!this.privateKey) {
                throw new router_1.KeplrError("keyring", 134, "Key store type is private key and it is unlocked. But, private key is not loaded unexpectedly");
            }
            return new crypto_2.PrivKeySecp256k1(this.privateKey);
        }
        else {
            throw new router_1.KeplrError("keyring", 145, "Unexpected type of keyring");
        }
    }
    sign(env, chainId, defaultCoinType, message, useEthereumSigning) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED) {
                throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
            }
            if (!this.keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            // Sign with Evmos/Ethereum
            if (useEthereumSigning) {
                return this.signEthereum(chainId, defaultCoinType, message);
            }
            if (this.keyStore.type === "ledger") {
                const pubKey = this.ledgerPublicKey;
                if (!pubKey) {
                    throw new router_1.KeplrError("keyring", 151, "Ledger public key is not initialized");
                }
                return yield this.ledgerKeeper.sign(env, KeyRing.getKeyStoreBIP44Path(this.keyStore), pubKey, message);
            }
            else {
                const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);
                const privKey = this.loadPrivKey(coinType);
                const signature = privKey.sign(message);
                // Signing indicates an explicit use of this coin type.
                // Mainly, this logic exists to explicitly set the coin type when signing by an external request.
                if (!this.isKeyStoreCoinTypeSet(chainId)) {
                    yield this.setKeyStoreCoinType(chainId, coinType);
                }
                return signature;
            }
        });
    }
    signEthereum(chainId, defaultCoinType, message, type = types_1.EthSignType.BYTE64 // Default to Ethereum signing for Evmos
    ) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED) {
                throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
            }
            if (!this.keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            if (this.keyStore.type === "ledger") {
                // TODO: Ethereum Ledger Integration
                throw new router_1.KeplrError("keyring", 112, "Ethereum signing with Ledger is not yet supported");
            }
            const coinType = this.computeKeyStoreCoinType(chainId, defaultCoinType);
            // Allow signing with Ethereum for chains with coinType !== 60
            const privKey = this.loadPrivKey(coinType);
            const ethWallet = new wallet_1.Wallet(privKey.toBytes());
            if (type === types_1.EthSignType.BYTE64) {
                // ECDSA Sign Keccak256 and discard parity byte
                const signature = yield ethWallet
                    ._signingKey()
                    .signDigest(keccak256_1.keccak256(message));
                const splitSignature = BytesUtils.splitSignature(signature);
                return BytesUtils.arrayify(BytesUtils.concat([splitSignature.r, splitSignature.s]));
            }
            else if (type === types_1.EthSignType.MESSAGE) {
                // Sign bytes with prefixed Ethereum magic
                const signature = yield ethWallet.signMessage(message);
                return BytesUtils.arrayify(signature);
            }
            else {
                // Sign Ethereum transaction
                const signature = yield ethWallet.signTransaction(JSON.parse(buffer_1.Buffer.from(message).toString()));
                return BytesUtils.arrayify(signature);
            }
        });
    }
    // Show private key or mnemonic key if password is valid.
    showKeyRing(index, password) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED) {
                throw new router_1.KeplrError("keyring", 143, "Key ring is not unlocked");
            }
            if (this.password !== password) {
                throw new router_1.KeplrError("keyring", 121, "Invalid password");
            }
            const keyStore = this.multiKeyStore[index];
            if (!keyStore) {
                throw new router_1.KeplrError("keyring", 130, "Key store is empty");
            }
            if (keyStore.type === "mnemonic") {
                // If password is invalid, error will be thrown.
                return buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();
            }
            else {
                // If password is invalid, error will be thrown.
                return buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();
            }
        });
    }
    get canSetPath() {
        return this.type === "mnemonic" || this.type === "ledger";
    }
    addMnemonicKey(kdf, mnemonic, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED || this.password == "") {
                throw new router_1.KeplrError("keyring", 141, "Key ring is locked or not initialized");
            }
            const keyStore = yield KeyRing.CreateMnemonicKeyStore(this.crypto, kdf, mnemonic, this.password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);
            this.multiKeyStore.push(keyStore);
            yield this.save();
            return {
                multiKeyStoreInfo: this.getMultiKeyStoreInfo(),
            };
        });
    }
    addPrivateKey(kdf, privateKey, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED || this.password == "") {
                throw new router_1.KeplrError("keyring", 141, "Key ring is locked or not initialized");
            }
            const keyStore = yield KeyRing.CreatePrivateKeyStore(this.crypto, kdf, privateKey, this.password, yield this.assignKeyStoreIdMeta(meta));
            this.multiKeyStore.push(keyStore);
            yield this.save();
            return {
                multiKeyStoreInfo: this.getMultiKeyStoreInfo(),
            };
        });
    }
    addLedgerKey(env, kdf, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED || this.password == "") {
                throw new router_1.KeplrError("keyring", 141, "Key ring is locked or not initialized");
            }
            // Get public key first
            const publicKey = yield this.ledgerKeeper.getPublicKey(env, bip44HDPath);
            const keyStore = yield KeyRing.CreateLedgerKeyStore(this.crypto, kdf, publicKey, this.password, yield this.assignKeyStoreIdMeta(meta), bip44HDPath);
            this.multiKeyStore.push(keyStore);
            yield this.save();
            return {
                multiKeyStoreInfo: this.getMultiKeyStoreInfo(),
            };
        });
    }
    changeKeyStoreFromMultiKeyStore(index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== KeyRingStatus.UNLOCKED || this.password == "") {
                throw new router_1.KeplrError("keyring", 141, "Key ring is locked or not initialized");
            }
            const keyStore = this.multiKeyStore[index];
            if (!keyStore) {
                throw new router_1.KeplrError("keyring", 120, "Invalid keystore");
            }
            this.keyStore = keyStore;
            yield this.unlock(this.password);
            yield this.save();
            return {
                multiKeyStoreInfo: this.getMultiKeyStoreInfo(),
            };
        });
    }
    getMultiKeyStoreInfo() {
        const result = [];
        for (const keyStore of this.multiKeyStore) {
            result.push({
                version: keyStore.version,
                type: keyStore.type,
                meta: keyStore.meta,
                coinTypeForChain: keyStore.coinTypeForChain,
                bip44HDPath: keyStore.bip44HDPath,
                selected: this.keyStore
                    ? KeyRing.getKeyStoreId(keyStore) ===
                        KeyRing.getKeyStoreId(this.keyStore)
                    : false,
            });
        }
        return result;
    }
    checkPassword(password) {
        if (!this.password) {
            throw new router_1.KeplrError("keyring", 100, "Keyring is locked");
        }
        return this.password === password;
    }
    exportKeyRingDatas(password) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.password) {
                throw new router_1.KeplrError("keyring", 100, "Keyring is locked");
            }
            if (this.password !== password) {
                throw new router_1.KeplrError("keyring", 121, "Invalid password");
            }
            const result = [];
            for (const keyStore of this.multiKeyStore) {
                const type = (_a = keyStore.type) !== null && _a !== void 0 ? _a : "mnemonic";
                switch (type) {
                    case "mnemonic": {
                        const mnemonic = buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();
                        result.push({
                            bip44HDPath: (_b = keyStore.bip44HDPath) !== null && _b !== void 0 ? _b : {
                                account: 0,
                                change: 0,
                                addressIndex: 0,
                            },
                            coinTypeForChain: keyStore.coinTypeForChain,
                            key: mnemonic,
                            meta: (_c = keyStore.meta) !== null && _c !== void 0 ? _c : {},
                            type: "mnemonic",
                        });
                        break;
                    }
                    case "privateKey": {
                        const privateKey = buffer_1.Buffer.from(yield crypto_1.Crypto.decrypt(this.crypto, keyStore, password)).toString();
                        result.push({
                            bip44HDPath: (_d = keyStore.bip44HDPath) !== null && _d !== void 0 ? _d : {
                                account: 0,
                                change: 0,
                                addressIndex: 0,
                            },
                            coinTypeForChain: keyStore.coinTypeForChain,
                            key: privateKey,
                            meta: (_e = keyStore.meta) !== null && _e !== void 0 ? _e : {},
                            type: "privateKey",
                        });
                        break;
                    }
                }
            }
            return result;
        });
    }
    static CreateMnemonicKeyStore(crypto, kdf, mnemonic, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield crypto_1.Crypto.encrypt(crypto, kdf, "mnemonic", mnemonic, password, meta, bip44HDPath);
        });
    }
    static CreatePrivateKeyStore(crypto, kdf, privateKey, password, meta) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield crypto_1.Crypto.encrypt(crypto, kdf, "privateKey", buffer_1.Buffer.from(privateKey).toString("hex"), password, meta);
        });
    }
    static CreateLedgerKeyStore(crypto, kdf, publicKey, password, meta, bip44HDPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield crypto_1.Crypto.encrypt(crypto, kdf, "ledger", buffer_1.Buffer.from(publicKey).toString("hex"), password, meta, bip44HDPath);
        });
    }
    assignKeyStoreIdMeta(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            // `__id__` is used to distinguish the key store.
            return Object.assign({}, meta, {
                __id__: (yield this.getIncrementalNumber()).toString(),
            });
        });
    }
    static getKeyStoreId(keyStore) {
        var _a;
        const id = (_a = keyStore.meta) === null || _a === void 0 ? void 0 : _a.__id__;
        if (!id) {
            throw new router_1.KeplrError("keyring", 131, "Key store's id is empty");
        }
        return id;
    }
    static getKeyStoreBIP44Path(keyStore) {
        if (!keyStore.bip44HDPath) {
            return {
                account: 0,
                change: 0,
                addressIndex: 0,
            };
        }
        KeyRing.validateBIP44Path(keyStore.bip44HDPath);
        return keyStore.bip44HDPath;
    }
    static validateBIP44Path(bip44Path) {
        if (!Number.isInteger(bip44Path.account) || bip44Path.account < 0) {
            throw new router_1.KeplrError("keyring", 100, "Invalid account in hd path");
        }
        if (!Number.isInteger(bip44Path.change) ||
            !(bip44Path.change === 0 || bip44Path.change === 1)) {
            throw new router_1.KeplrError("keyring", 102, "Invalid change in hd path");
        }
        if (!Number.isInteger(bip44Path.addressIndex) ||
            bip44Path.addressIndex < 0) {
            throw new router_1.KeplrError("keyring", 101, "Invalid address index in hd path");
        }
    }
    getIncrementalNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            let num = yield this.kvStore.get("incrementalNumber");
            if (num === undefined) {
                num = 0;
            }
            num++;
            yield this.kvStore.set("incrementalNumber", num);
            return num;
        });
    }
}
exports.KeyRing = KeyRing;
//# sourceMappingURL=keyring.js.map