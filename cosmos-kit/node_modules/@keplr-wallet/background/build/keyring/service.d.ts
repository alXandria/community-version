import { Key, KeyRingStatus, MultiKeyStoreInfoWithSelected } from "./keyring";
import { BIP44HDPath, CommonCrypto, ExportKeyRingData } from "./types";
import { KVStore } from "@keplr-wallet/common";
import { ChainsService } from "../chains";
import { LedgerService } from "../ledger";
import { BIP44, ChainInfo, EthSignType, KeplrSignOptions } from "@keplr-wallet/types";
import { Env } from "@keplr-wallet/router";
import { InteractionService } from "../interaction";
import { PermissionService } from "../permission";
import { AminoSignResponse, StdSignDoc, StdSignature } from "@cosmjs/launchpad";
import { DirectSignResponse } from "@cosmjs/proto-signing";
import { SignDoc } from "@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx";
export declare class KeyRingService {
    protected readonly kvStore: KVStore;
    protected readonly embedChainInfos: ChainInfo[];
    protected readonly crypto: CommonCrypto;
    private keyRing;
    protected interactionService: InteractionService;
    chainsService: ChainsService;
    permissionService: PermissionService;
    constructor(kvStore: KVStore, embedChainInfos: ChainInfo[], crypto: CommonCrypto);
    init(interactionService: InteractionService, chainsService: ChainsService, permissionService: PermissionService, ledgerService: LedgerService): void;
    protected readonly onChainRemoved: (chainId: string) => void;
    restore(): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    enable(env: Env): Promise<KeyRingStatus>;
    get keyRingStatus(): KeyRingStatus;
    deleteKeyRing(index: number, password: string): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
        status: KeyRingStatus;
    }>;
    updateNameKeyRing(index: number, name: string): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    showKeyRing(index: number, password: string): Promise<string>;
    createMnemonicKey(kdf: "scrypt" | "sha256" | "pbkdf2", mnemonic: string, password: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    createPrivateKey(kdf: "scrypt" | "sha256" | "pbkdf2", privateKey: Uint8Array, password: string, meta: Record<string, string>): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    createLedgerKey(env: Env, kdf: "scrypt" | "sha256" | "pbkdf2", password: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        status: KeyRingStatus;
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    lock(): KeyRingStatus;
    unlock(password: string): Promise<KeyRingStatus>;
    getKey(chainId: string): Promise<Key>;
    getKeyStoreMeta(key: string): string;
    getKeyRingType(): string;
    requestSignAmino(env: Env, msgOrigin: string, chainId: string, signer: string, signDoc: StdSignDoc, signOptions: KeplrSignOptions & {
        isADR36WithString?: boolean;
        ethSignType?: EthSignType;
    }): Promise<AminoSignResponse>;
    requestSignDirect(env: Env, msgOrigin: string, chainId: string, signer: string, signDoc: SignDoc, signOptions: KeplrSignOptions): Promise<DirectSignResponse>;
    verifyADR36AminoSignDoc(chainId: string, signer: string, data: Uint8Array, signature: StdSignature): Promise<boolean>;
    sign(env: Env, chainId: string, message: Uint8Array): Promise<Uint8Array>;
    addMnemonicKey(kdf: "scrypt" | "sha256" | "pbkdf2", mnemonic: string, meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    addPrivateKey(kdf: "scrypt" | "sha256" | "pbkdf2", privateKey: Uint8Array, meta: Record<string, string>): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    addLedgerKey(env: Env, kdf: "scrypt" | "sha256" | "pbkdf2", meta: Record<string, string>, bip44HDPath: BIP44HDPath): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    changeKeyStoreFromMultiKeyStore(index: number): Promise<{
        multiKeyStoreInfo: MultiKeyStoreInfoWithSelected;
    }>;
    checkPassword(password: string): boolean;
    getMultiKeyStoreInfo(): MultiKeyStoreInfoWithSelected;
    isKeyStoreCoinTypeSet(chainId: string): boolean;
    setKeyStoreCoinType(chainId: string, coinType: number): Promise<void>;
    getKeyStoreBIP44Selectables(chainId: string, paths: BIP44[]): Promise<{
        readonly path: BIP44;
        readonly bech32Address: string;
    }[]>;
    exportKeyRingDatas(password: string): Promise<ExportKeyRingData[]>;
}
