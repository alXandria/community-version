import { ChainInfo, EthSignType, Keplr, Keplr as IKeplr, KeplrIntereactionOptions, KeplrMode, KeplrSignOptions, Key } from "@keplr-wallet/types";
import { Result } from "@keplr-wallet/router";
import { BroadcastMode, AminoSignResponse, StdSignDoc, StdTx, OfflineSigner, StdSignature } from "@cosmjs/launchpad";
import { SecretUtils } from "secretjs/types/enigmautils";
import { DirectSignResponse, OfflineDirectSigner } from "@cosmjs/proto-signing";
import Long from "long";
export interface ProxyRequest {
    type: "proxy-request";
    id: string;
    method: keyof Keplr;
    args: any[];
}
export interface ProxyRequestResponse {
    type: "proxy-request-response";
    id: string;
    result: Result | undefined;
}
/**
 * InjectedKeplr would be injected to the webpage.
 * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.
 * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.
 * This will use `window.postMessage` to interact with the content script.
 */
export declare class InjectedKeplr implements IKeplr {
    readonly version: string;
    readonly mode: KeplrMode;
    protected readonly eventListener: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    };
    protected readonly parseMessage?: ((message: any) => any) | undefined;
    static startProxy(keplr: IKeplr, eventListener?: {
        addMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, parseMessage?: (message: any) => any): void;
    protected requestMethod(method: keyof IKeplr, args: any[]): Promise<any>;
    protected enigmaUtils: Map<string, SecretUtils>;
    defaultOptions: KeplrIntereactionOptions;
    constructor(version: string, mode: KeplrMode, eventListener?: {
        addMessageListener: (fn: (e: any) => void) => void;
        removeMessageListener: (fn: (e: any) => void) => void;
        postMessage: (message: any) => void;
    }, parseMessage?: ((message: any) => any) | undefined);
    enable(chainIds: string | string[]): Promise<void>;
    experimentalSuggestChain(chainInfo: ChainInfo): Promise<void>;
    getKey(chainId: string): Promise<Key>;
    sendTx(chainId: string, tx: StdTx | Uint8Array, mode: BroadcastMode): Promise<Uint8Array>;
    signAmino(chainId: string, signer: string, signDoc: StdSignDoc, signOptions?: KeplrSignOptions): Promise<AminoSignResponse>;
    signDirect(chainId: string, signer: string, signDoc: {
        bodyBytes?: Uint8Array | null;
        authInfoBytes?: Uint8Array | null;
        chainId?: string | null;
        accountNumber?: Long | null;
    }, signOptions?: KeplrSignOptions): Promise<DirectSignResponse>;
    signArbitrary(chainId: string, signer: string, data: string | Uint8Array): Promise<StdSignature>;
    verifyArbitrary(chainId: string, signer: string, data: string | Uint8Array, signature: StdSignature): Promise<boolean>;
    signEthereum(chainId: string, signer: string, data: string | Uint8Array, type: EthSignType): Promise<Uint8Array>;
    getOfflineSigner(chainId: string): OfflineSigner & OfflineDirectSigner;
    getOfflineSignerOnlyAmino(chainId: string): OfflineSigner;
    getOfflineSignerAuto(chainId: string): Promise<OfflineSigner | OfflineDirectSigner>;
    suggestToken(chainId: string, contractAddress: string, viewingKey?: string): Promise<void>;
    getSecret20ViewingKey(chainId: string, contractAddress: string): Promise<string>;
    getEnigmaPubKey(chainId: string): Promise<Uint8Array>;
    getEnigmaTxEncryptionKey(chainId: string, nonce: Uint8Array): Promise<Uint8Array>;
    enigmaEncrypt(chainId: string, contractCodeHash: string, msg: object): Promise<Uint8Array>;
    enigmaDecrypt(chainId: string, ciphertext: Uint8Array, nonce: Uint8Array): Promise<Uint8Array>;
    getEnigmaUtils(chainId: string): SecretUtils;
}
