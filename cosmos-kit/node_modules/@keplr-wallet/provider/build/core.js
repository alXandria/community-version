"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keplr = void 0;
const types_1 = require("@keplr-wallet/types");
const router_1 = require("@keplr-wallet/router");
const types_2 = require("./types");
const enigma_1 = require("./enigma");
const cosmjs_1 = require("./cosmjs");
const deepmerge_1 = __importDefault(require("deepmerge"));
const long_1 = __importDefault(require("long"));
const buffer_1 = require("buffer/");
class Keplr {
    constructor(version, mode, requester) {
        this.version = version;
        this.mode = mode;
        this.requester = requester;
        this.enigmaUtils = new Map();
        this.defaultOptions = {};
    }
    enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof chainIds === "string") {
                chainIds = [chainIds];
            }
            yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.EnableAccessMsg(chainIds));
        });
    }
    experimentalSuggestChain(chainInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.SuggestChainInfoMsg(chainInfo);
            yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.GetKeyMsg(chainId);
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.SendTxMsg(chainId, tx, mode);
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.RequestSignAminoMsg(chainId, signer, signDoc, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions));
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.RequestSignDirectMsg(chainId, signer, {
                bodyBytes: signDoc.bodyBytes,
                authInfoBytes: signDoc.authInfoBytes,
                chainId: signDoc.chainId,
                accountNumber: signDoc.accountNumber
                    ? signDoc.accountNumber.toString()
                    : null,
            }, deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions));
            const response = yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
            return {
                signed: {
                    bodyBytes: response.signed.bodyBytes,
                    authInfoBytes: response.signed.authInfoBytes,
                    chainId: response.signed.chainId,
                    accountNumber: long_1.default.fromString(response.signed.accountNumber),
                },
                signature: response.signature,
            };
        });
    }
    signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let isADR36WithString;
            [data, isADR36WithString] = this.getDataForADR36(data);
            const signDoc = this.getADR36SignDoc(signer, data);
            const msg = new types_2.RequestSignAminoMsg(chainId, signer, signDoc, {
                isADR36WithString,
            });
            return (yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg)).signature;
        });
    }
    verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof data === "string") {
                data = buffer_1.Buffer.from(data);
            }
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.RequestVerifyADR36AminoSignDoc(chainId, signer, data, signature));
        });
    }
    signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type !== types_1.EthSignType.MESSAGE && type !== types_1.EthSignType.TRANSACTION) {
                throw new Error("Unsupported Ethereum signing type: expected 'message' or 'transaction.'");
            }
            let isADR36WithString;
            [data, isADR36WithString] = this.getDataForADR36(data);
            const signDoc = this.getADR36SignDoc(signer, data);
            if (data === "") {
                throw new Error("Signing empty data is not supported.");
            }
            const msg = new types_2.RequestSignAminoMsg(chainId, signer, signDoc, {
                isADR36WithString,
                ethSignType: type,
            });
            const signature = (yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))
                .signature;
            return buffer_1.Buffer.from(signature.signature, "base64");
        });
    }
    getOfflineSigner(chainId) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this);
    }
    getOfflineSignerOnlyAmino(chainId) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);
    }
    getOfflineSignerAuto(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey(chainId);
            if (key.isNanoLedger) {
                return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);
            }
            return new cosmjs_1.CosmJSOfflineSigner(chainId, this);
        });
    }
    suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.SuggestTokenMsg(chainId, contractAddress, viewingKey);
            yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new types_2.GetSecret20ViewingKey(chainId, contractAddress);
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.GetPubkeyMsg(chainId));
        });
    }
    getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.GetTxEncryptionKeyMsg(chainId, nonce));
        });
    }
    enigmaEncrypt(chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.ReqeustEncryptMsg(chainId, contractCodeHash, msg));
        });
    }
    enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!ciphertext || ciphertext.length === 0) {
                return new Uint8Array();
            }
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new types_2.RequestDecryptMsg(chainId, ciphertext, nonce));
        });
    }
    getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
    }
    getDataForADR36(data) {
        let isADR36WithString = false;
        if (typeof data === "string") {
            data = buffer_1.Buffer.from(data).toString("base64");
            isADR36WithString = true;
        }
        else {
            data = buffer_1.Buffer.from(data).toString("base64");
        }
        return [data, isADR36WithString];
    }
    getADR36SignDoc(signer, data) {
        return {
            chain_id: "",
            account_number: "0",
            sequence: "0",
            fee: {
                gas: "0",
                amount: [],
            },
            msgs: [
                {
                    type: "sign/MsgSignData",
                    value: {
                        signer,
                        data,
                    },
                },
            ],
            memo: "",
        };
    }
}
exports.Keplr = Keplr;
//# sourceMappingURL=core.js.map