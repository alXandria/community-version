"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetTxEncryptionKeyMsg = exports.RequestDecryptMsg = exports.ReqeustEncryptMsg = exports.GetPubkeyMsg = exports.RequestSignDirectMsg = exports.RequestVerifyADR36AminoSignDoc = exports.RequestSignAminoMsg = exports.GetSecret20ViewingKey = exports.SendTxMsg = exports.SuggestTokenMsg = exports.SuggestChainInfoMsg = exports.GetKeyMsg = exports.EnableAccessMsg = void 0;
const router_1 = require("@keplr-wallet/router");
class EnableAccessMsg extends router_1.Message {
    constructor(chainIds) {
        super();
        this.chainIds = chainIds;
    }
    static type() {
        return "enable-access";
    }
    validateBasic() {
        if (!this.chainIds || this.chainIds.length === 0) {
            throw new Error("chain id not set");
        }
    }
    route() {
        return "permission";
    }
    type() {
        return EnableAccessMsg.type();
    }
}
exports.EnableAccessMsg = EnableAccessMsg;
class GetKeyMsg extends router_1.Message {
    constructor(chainId) {
        super();
        this.chainId = chainId;
    }
    static type() {
        return "get-key";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
    }
    route() {
        return "keyring";
    }
    type() {
        return GetKeyMsg.type();
    }
}
exports.GetKeyMsg = GetKeyMsg;
class SuggestChainInfoMsg extends router_1.Message {
    constructor(chainInfo) {
        super();
        this.chainInfo = chainInfo;
    }
    static type() {
        return "suggest-chain-info";
    }
    validateBasic() {
        if (!this.chainInfo) {
            throw new Error("chain info not set");
        }
    }
    route() {
        return "chains";
    }
    type() {
        return SuggestChainInfoMsg.type();
    }
}
exports.SuggestChainInfoMsg = SuggestChainInfoMsg;
class SuggestTokenMsg extends router_1.Message {
    constructor(chainId, contractAddress, viewingKey) {
        super();
        this.chainId = chainId;
        this.contractAddress = contractAddress;
        this.viewingKey = viewingKey;
    }
    static type() {
        return "suggest-token";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("Chain id is empty");
        }
        if (!this.contractAddress) {
            throw new Error("Contract address is empty");
        }
    }
    route() {
        return "tokens";
    }
    type() {
        return SuggestTokenMsg.type();
    }
}
exports.SuggestTokenMsg = SuggestTokenMsg;
// Return the tx hash
class SendTxMsg extends router_1.Message {
    constructor(chainId, tx, mode) {
        super();
        this.chainId = chainId;
        this.tx = tx;
        this.mode = mode;
    }
    static type() {
        return "send-tx-to-background";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id is empty");
        }
        if (!this.tx) {
            throw new Error("tx is empty");
        }
        if (!this.mode ||
            (this.mode !== "sync" && this.mode !== "async" && this.mode !== "block")) {
            throw new Error("invalid mode");
        }
    }
    route() {
        return "background-tx";
    }
    type() {
        return SendTxMsg.type();
    }
}
exports.SendTxMsg = SendTxMsg;
class GetSecret20ViewingKey extends router_1.Message {
    constructor(chainId, contractAddress) {
        super();
        this.chainId = chainId;
        this.contractAddress = contractAddress;
    }
    static type() {
        return "get-secret20-viewing-key";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("Chain id is empty");
        }
        if (!this.contractAddress) {
            throw new Error("Contract address is empty");
        }
    }
    route() {
        return "tokens";
    }
    type() {
        return GetSecret20ViewingKey.type();
    }
}
exports.GetSecret20ViewingKey = GetSecret20ViewingKey;
class RequestSignAminoMsg extends router_1.Message {
    constructor(chainId, signer, signDoc, signOptions = {}) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.signDoc = signDoc;
        this.signOptions = signOptions;
    }
    static type() {
        return "request-sign-amino";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.signer) {
            throw new Error("signer not set");
        }
        // It is not important to check this on the client side as opposed to increasing the bundle size.
        // Validate bech32 address.
        // Bech32Address.validate(this.signer);
        const signDoc = this.signDoc;
        // Check that the sign doc is for ADR-36,
        // the validation should be performed on the background.
        const hasOnlyMsgSignData = (() => {
            if (signDoc &&
                signDoc.msgs &&
                Array.isArray(signDoc.msgs) &&
                signDoc.msgs.length === 1) {
                const msg = signDoc.msgs[0];
                return msg.type === "sign/MsgSignData";
            }
            else {
                return false;
            }
        })();
        // If the sign doc is expected to be for ADR-36,
        // it doesn't have to have the chain id in the sign doc.
        if (!hasOnlyMsgSignData && signDoc.chain_id !== this.chainId) {
            throw new Error("Chain id in the message is not matched with the requested chain id");
        }
        if (!this.signOptions) {
            throw new Error("Sign options are null");
        }
    }
    route() {
        return "keyring";
    }
    type() {
        return RequestSignAminoMsg.type();
    }
}
exports.RequestSignAminoMsg = RequestSignAminoMsg;
class RequestVerifyADR36AminoSignDoc extends router_1.Message {
    constructor(chainId, signer, data, signature) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.data = data;
        this.signature = signature;
    }
    static type() {
        return "request-verify-adr-36-amino-doc";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.signer) {
            throw new Error("signer not set");
        }
        if (!this.signature) {
            throw new Error("Signature not set");
        }
        // It is not important to check this on the client side as opposed to increasing the bundle size.
        // Validate bech32 address.
        // Bech32Address.validate(this.signer);
    }
    route() {
        return "keyring";
    }
    type() {
        return RequestVerifyADR36AminoSignDoc.type();
    }
}
exports.RequestVerifyADR36AminoSignDoc = RequestVerifyADR36AminoSignDoc;
class RequestSignDirectMsg extends router_1.Message {
    constructor(chainId, signer, signDoc, signOptions = {}) {
        super();
        this.chainId = chainId;
        this.signer = signer;
        this.signDoc = signDoc;
        this.signOptions = signOptions;
    }
    static type() {
        return "request-sign-direct";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.signer) {
            throw new Error("signer not set");
        }
        // It is not important to check this on the client side as opposed to increasing the bundle size.
        // Validate bech32 address.
        // Bech32Address.validate(this.signer);
        // const signDoc = cosmos.tx.v1beta1.SignDoc.create({
        //   bodyBytes: this.signDoc.bodyBytes,
        //   authInfoBytes: this.signDoc.authInfoBytes,
        //   chainId: this.signDoc.chainId,
        //   accountNumber: this.signDoc.accountNumber
        //     ? Long.fromString(this.signDoc.accountNumber)
        //     : undefined,
        // });
        //
        // if (signDoc.chainId !== this.chainId) {
        //   throw new Error(
        //     "Chain id in the message is not matched with the requested chain id"
        //   );
        // }
        if (!this.signOptions) {
            throw new Error("Sign options are null");
        }
    }
    route() {
        return "keyring";
    }
    type() {
        return RequestSignDirectMsg.type();
    }
}
exports.RequestSignDirectMsg = RequestSignDirectMsg;
class GetPubkeyMsg extends router_1.Message {
    constructor(chainId) {
        super();
        this.chainId = chainId;
    }
    static type() {
        return "get-pubkey-msg";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
    }
    route() {
        return "secret-wasm";
    }
    type() {
        return GetPubkeyMsg.type();
    }
}
exports.GetPubkeyMsg = GetPubkeyMsg;
class ReqeustEncryptMsg extends router_1.Message {
    constructor(chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        super();
        this.chainId = chainId;
        this.contractCodeHash = contractCodeHash;
        this.msg = msg;
    }
    static type() {
        return "request-encrypt-msg";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.contractCodeHash) {
            throw new Error("contract code hash not set");
        }
        if (!this.msg) {
            throw new Error("msg not set");
        }
    }
    route() {
        return "secret-wasm";
    }
    type() {
        return ReqeustEncryptMsg.type();
    }
}
exports.ReqeustEncryptMsg = ReqeustEncryptMsg;
class RequestDecryptMsg extends router_1.Message {
    constructor(chainId, cipherText, nonce) {
        super();
        this.chainId = chainId;
        this.cipherText = cipherText;
        this.nonce = nonce;
    }
    static type() {
        return "request-decrypt-msg";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.cipherText || this.cipherText.length === 0) {
            throw new Error("ciphertext not set");
        }
        if (!this.nonce || this.nonce.length === 0) {
            throw new Error("nonce not set");
        }
    }
    route() {
        return "secret-wasm";
    }
    type() {
        return RequestDecryptMsg.type();
    }
}
exports.RequestDecryptMsg = RequestDecryptMsg;
class GetTxEncryptionKeyMsg extends router_1.Message {
    constructor(chainId, nonce) {
        super();
        this.chainId = chainId;
        this.nonce = nonce;
    }
    static type() {
        return "get-tx-encryption-key-msg";
    }
    validateBasic() {
        if (!this.chainId) {
            throw new Error("chain id not set");
        }
        if (!this.nonce) {
            // Nonce of zero length is permitted.
            throw new Error("nonce is null");
        }
    }
    route() {
        return "secret-wasm";
    }
    type() {
        return GetTxEncryptionKeyMsg.type();
    }
}
exports.GetTxEncryptionKeyMsg = GetTxEncryptionKeyMsg;
//# sourceMappingURL=msgs.js.map