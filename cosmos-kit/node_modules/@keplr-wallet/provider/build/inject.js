"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InjectedKeplr = void 0;
const router_1 = require("@keplr-wallet/router");
const enigma_1 = require("./enigma");
const cosmjs_1 = require("./cosmjs");
const deepmerge_1 = __importDefault(require("deepmerge"));
const long_1 = __importDefault(require("long"));
/**
 * InjectedKeplr would be injected to the webpage.
 * In the webpage, it can't request any messages to the extension because it doesn't have any API related to the extension.
 * So, to request some methods of the extension, this will proxy the request to the content script that is injected to webpage on the extension level.
 * This will use `window.postMessage` to interact with the content script.
 */
class InjectedKeplr {
    constructor(version, mode, eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        removeMessageListener: (fn) => window.removeEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, parseMessage) {
        this.version = version;
        this.mode = mode;
        this.eventListener = eventListener;
        this.parseMessage = parseMessage;
        this.enigmaUtils = new Map();
        this.defaultOptions = {};
    }
    static startProxy(keplr, eventListener = {
        addMessageListener: (fn) => window.addEventListener("message", fn),
        postMessage: (message) => window.postMessage(message, window.location.origin),
    }, parseMessage) {
        eventListener.addMessageListener((e) => __awaiter(this, void 0, void 0, function* () {
            const message = parseMessage
                ? parseMessage(e.data)
                : e.data;
            if (!message || message.type !== "proxy-request") {
                return;
            }
            try {
                if (!message.id) {
                    throw new Error("Empty id");
                }
                if (message.method === "version") {
                    throw new Error("Version is not function");
                }
                if (message.method === "mode") {
                    throw new Error("Mode is not function");
                }
                if (message.method === "defaultOptions") {
                    throw new Error("DefaultOptions is not function");
                }
                if (!keplr[message.method] ||
                    typeof keplr[message.method] !== "function") {
                    throw new Error(`Invalid method: ${message.method}`);
                }
                if (message.method === "getOfflineSigner") {
                    throw new Error("GetOfflineSigner method can't be proxy request");
                }
                if (message.method === "getOfflineSignerOnlyAmino") {
                    throw new Error("GetOfflineSignerOnlyAmino method can't be proxy request");
                }
                if (message.method === "getOfflineSignerAuto") {
                    throw new Error("GetOfflineSignerAuto method can't be proxy request");
                }
                if (message.method === "getEnigmaUtils") {
                    throw new Error("GetEnigmaUtils method can't be proxy request");
                }
                const result = message.method === "signDirect"
                    ? yield (() => __awaiter(this, void 0, void 0, function* () {
                        const receivedSignDoc = message.args[2];
                        const result = yield keplr.signDirect(message.args[0], message.args[1], {
                            bodyBytes: receivedSignDoc.bodyBytes,
                            authInfoBytes: receivedSignDoc.authInfoBytes,
                            chainId: receivedSignDoc.chainId,
                            accountNumber: receivedSignDoc.accountNumber
                                ? long_1.default.fromString(receivedSignDoc.accountNumber)
                                : null,
                        }, message.args[3]);
                        return {
                            signed: {
                                bodyBytes: result.signed.bodyBytes,
                                authInfoBytes: result.signed.authInfoBytes,
                                chainId: result.signed.chainId,
                                accountNumber: result.signed.accountNumber.toString(),
                            },
                            signature: result.signature,
                        };
                    }))()
                    : yield keplr[message.method](
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    ...router_1.JSONUint8Array.unwrap(message.args));
                const proxyResponse = {
                    type: "proxy-request-response",
                    id: message.id,
                    result: {
                        return: router_1.JSONUint8Array.wrap(result),
                    },
                };
                eventListener.postMessage(proxyResponse);
            }
            catch (e) {
                const proxyResponse = {
                    type: "proxy-request-response",
                    id: message.id,
                    result: {
                        error: e.message || e.toString(),
                    },
                };
                eventListener.postMessage(proxyResponse);
            }
        }));
    }
    requestMethod(method, args) {
        const bytes = new Uint8Array(8);
        const id = Array.from(crypto.getRandomValues(bytes))
            .map((value) => {
            return value.toString(16);
        })
            .join("");
        const proxyMessage = {
            type: "proxy-request",
            id,
            method,
            args: router_1.JSONUint8Array.wrap(args),
        };
        return new Promise((resolve, reject) => {
            const receiveResponse = (e) => {
                const proxyResponse = this.parseMessage
                    ? this.parseMessage(e.data)
                    : e.data;
                if (!proxyResponse || proxyResponse.type !== "proxy-request-response") {
                    return;
                }
                if (proxyResponse.id !== id) {
                    return;
                }
                this.eventListener.removeMessageListener(receiveResponse);
                const result = router_1.JSONUint8Array.unwrap(proxyResponse.result);
                if (!result) {
                    reject(new Error("Result is null"));
                    return;
                }
                if (result.error) {
                    reject(new Error(result.error));
                    return;
                }
                resolve(result.return);
            };
            this.eventListener.addMessageListener(receiveResponse);
            this.eventListener.postMessage(proxyMessage);
        });
    }
    enable(chainIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requestMethod("enable", [chainIds]);
        });
    }
    experimentalSuggestChain(chainInfo) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = chainInfo.features) === null || _a === void 0 ? void 0 : _a.includes("stargate")) || ((_b = chainInfo.features) === null || _b === void 0 ? void 0 : _b.includes("no-legacy-stdTx"))) {
                console.log("“stargate”, “no-legacy-stdTx” feature has been deprecated. The launchpad is no longer supported, thus works without the two features. We would keep the aforementioned two feature for a while, but the upcoming update would potentially cause errors. Remove the two feature.");
            }
            yield this.requestMethod("experimentalSuggestChain", [chainInfo]);
        });
    }
    getKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getKey", [chainId]);
        });
    }
    sendTx(chainId, tx, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!("length" in tx)) {
                console.log("Do not send legacy std tx via `sendTx` API. We now only support protobuf tx. The usage of legeacy std tx would throw an error in the near future.");
            }
            return yield this.requestMethod("sendTx", [chainId, tx, mode]);
        });
    }
    signAmino(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signAmino", [
                chainId,
                signer,
                signDoc,
                deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
        });
    }
    signDirect(chainId, signer, signDoc, signOptions = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.requestMethod("signDirect", [
                chainId,
                signer,
                // We can't send the `Long` with remaing the type.
                // Receiver should change the `string` to `Long`.
                {
                    bodyBytes: signDoc.bodyBytes,
                    authInfoBytes: signDoc.authInfoBytes,
                    chainId: signDoc.chainId,
                    accountNumber: signDoc.accountNumber
                        ? signDoc.accountNumber.toString()
                        : null,
                },
                deepmerge_1.default((_a = this.defaultOptions.sign) !== null && _a !== void 0 ? _a : {}, signOptions),
            ]);
            const signed = result.signed;
            return {
                signed: {
                    bodyBytes: signed.bodyBytes,
                    authInfoBytes: signed.authInfoBytes,
                    chainId: signed.chainId,
                    // We can't send the `Long` with remaing the type.
                    // Sender should change the `Long` to `string`.
                    accountNumber: long_1.default.fromString(signed.accountNumber),
                },
                signature: result.signature,
            };
        });
    }
    signArbitrary(chainId, signer, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signArbitrary", [chainId, signer, data]);
        });
    }
    verifyArbitrary(chainId, signer, data, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("verifyArbitrary", [
                chainId,
                signer,
                data,
                signature,
            ]);
        });
    }
    signEthereum(chainId, signer, data, type) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("signEthereum", [
                chainId,
                signer,
                data,
                type,
            ]);
        });
    }
    getOfflineSigner(chainId) {
        return new cosmjs_1.CosmJSOfflineSigner(chainId, this);
    }
    getOfflineSignerOnlyAmino(chainId) {
        return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);
    }
    getOfflineSignerAuto(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.getKey(chainId);
            if (key.isNanoLedger) {
                return new cosmjs_1.CosmJSOfflineSignerOnlyAmino(chainId, this);
            }
            return new cosmjs_1.CosmJSOfflineSigner(chainId, this);
        });
    }
    suggestToken(chainId, contractAddress, viewingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("suggestToken", [
                chainId,
                contractAddress,
                viewingKey,
            ]);
        });
    }
    getSecret20ViewingKey(chainId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getSecret20ViewingKey", [
                chainId,
                contractAddress,
            ]);
        });
    }
    getEnigmaPubKey(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaPubKey", [chainId]);
        });
    }
    getEnigmaTxEncryptionKey(chainId, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("getEnigmaTxEncryptionKey", [
                chainId,
                nonce,
            ]);
        });
    }
    enigmaEncrypt(chainId, contractCodeHash, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaEncrypt", [
                chainId,
                contractCodeHash,
                msg,
            ]);
        });
    }
    enigmaDecrypt(chainId, ciphertext, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requestMethod("enigmaDecrypt", [
                chainId,
                ciphertext,
                nonce,
            ]);
        });
    }
    getEnigmaUtils(chainId) {
        if (this.enigmaUtils.has(chainId)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.enigmaUtils.get(chainId);
        }
        const enigmaUtils = new enigma_1.KeplrEnigmaUtils(chainId, this);
        this.enigmaUtils.set(chainId, enigmaUtils);
        return enigmaUtils;
    }
}
exports.InjectedKeplr = InjectedKeplr;
//# sourceMappingURL=inject.js.map