"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensStore = exports.TokensStoreInner = void 0;
const common_1 = require("../common");
const router_1 = require("@keplr-wallet/router");
const background_1 = require("@keplr-wallet/background");
const mobx_1 = require("mobx");
const common_2 = require("@keplr-wallet/common");
const cosmos_1 = require("@keplr-wallet/cosmos");
class TokensStoreInner {
    constructor(eventListener, chainStore, chainId, requester) {
        this.eventListener = eventListener;
        this.chainStore = chainStore;
        this.chainId = chainId;
        this.requester = requester;
        this._tokens = [];
        mobx_1.makeObservable(this);
        this.refreshTokens();
        // If key store in the keplr extension is unlocked, this event will be dispatched.
        // This is needed becuase the token such as secret20 exists according to the account.
        this.eventListener.addEventListener("keplr_keystoreunlock", () => {
            this.refreshTokens();
        });
        // If key store in the keplr extension is changed, this event will be dispatched.
        // This is needed becuase the token such as secret20 exists according to the account.
        this.eventListener.addEventListener("keplr_keystorechange", () => {
            this.refreshTokens();
        });
    }
    get tokens() {
        return this._tokens;
    }
    *refreshTokens() {
        const chainInfo = this.chainStore.getChain(this.chainId);
        if (chainInfo.features &&
            // Tokens service is only needed for secretwasm and cosmwasm,
            // so, there is no need to fetch the registered token if the chain doesn't support the secretwasm and cosmwasm.
            (chainInfo.features.includes("secretwasm") ||
                chainInfo.features.includes("cosmwasm"))) {
            const msg = new background_1.GetTokensMsg(this.chainId);
            this._tokens = yield* common_2.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        }
        else {
            this._tokens = [];
        }
    }
    *addToken(currency) {
        const msg = new background_1.AddTokenMsg(this.chainId, currency);
        yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        yield this.refreshTokens();
    }
    *removeToken(currency) {
        const msg = new background_1.RemoveTokenMsg(this.chainId, currency);
        yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        yield this.refreshTokens();
    }
}
__decorate([
    mobx_1.observable.ref
], TokensStoreInner.prototype, "_tokens", void 0);
__decorate([
    mobx_1.flow
], TokensStoreInner.prototype, "refreshTokens", null);
__decorate([
    mobx_1.flow
], TokensStoreInner.prototype, "addToken", null);
__decorate([
    mobx_1.flow
], TokensStoreInner.prototype, "removeToken", null);
exports.TokensStoreInner = TokensStoreInner;
class TokensStore extends common_1.HasMapStore {
    constructor(eventListener, chainStore, requester, interactionStore) {
        super((chainId) => {
            return new TokensStoreInner(this.eventListener, this.chainStore, chainId, this.requester);
        });
        this.eventListener = eventListener;
        this.chainStore = chainStore;
        this.requester = requester;
        this.interactionStore = interactionStore;
        this.prevTokens = new Map();
        mobx_1.makeObservable(this);
        this.chainStore.addSetChainInfoHandler((chainInfoInner) => {
            mobx_1.autorun(() => {
                var _a;
                const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainInfoInner.chainId);
                // Tokens should be changed whenever the account changed.
                // But, the added currencies are not removed automatically.
                // So, we should remove the prev token currencies from the chain info.
                const prevToken = (_a = this.prevTokens.get(chainIdentifier.identifier)) !== null && _a !== void 0 ? _a : [];
                chainInfoInner.removeCurrencies(...prevToken.map((token) => token.coinMinimalDenom));
                const inner = this.getTokensOf(chainInfoInner.chainId);
                chainInfoInner.addCurrencies(...inner.tokens);
                this.prevTokens.set(chainIdentifier.identifier, inner.tokens);
            });
        });
    }
    getTokensOf(chainId) {
        return this.get(chainId);
    }
    get waitingSuggestedToken() {
        const datas = this.interactionStore.getDatas(background_1.SuggestTokenMsg.type());
        if (datas.length > 0) {
            return datas[0];
        }
    }
    *approveSuggestedToken(appCurrency) {
        const data = this.waitingSuggestedToken;
        if (data) {
            yield this.interactionStore.approve(background_1.SuggestTokenMsg.type(), data.id, appCurrency);
            yield this.getTokensOf(data.data.chainId).refreshTokens();
        }
    }
    *rejectSuggestedToken() {
        const data = this.waitingSuggestedToken;
        if (data) {
            yield this.interactionStore.reject(background_1.SuggestTokenMsg.type(), data.id);
        }
    }
    *rejectAllSuggestedTokens() {
        yield this.interactionStore.rejectAll(background_1.SuggestTokenMsg.type());
    }
}
__decorate([
    mobx_1.flow
], TokensStore.prototype, "approveSuggestedToken", null);
__decorate([
    mobx_1.flow
], TokensStore.prototype, "rejectSuggestedToken", null);
__decorate([
    mobx_1.flow
], TokensStore.prototype, "rejectAllSuggestedTokens", null);
exports.TokensStore = TokensStore;
//# sourceMappingURL=tokens.js.map