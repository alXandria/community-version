"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignInteractionStore = void 0;
const mobx_1 = require("mobx");
const cosmos_1 = require("@keplr-wallet/cosmos");
class SignInteractionStore {
    constructor(interactionStore) {
        this.interactionStore = interactionStore;
        this._isLoading = false;
        mobx_1.makeObservable(this);
        mobx_1.autorun(() => {
            // Reject all interactions that is not first one.
            // This interaction can have only one interaction at once.
            const datas = this.waitingDatas.slice();
            if (datas.length > 1) {
                for (let i = 1; i < datas.length; i++) {
                    this.rejectWithId(datas[i].id);
                }
            }
        });
    }
    get waitingDatas() {
        return this.interactionStore.getDatas("request-sign");
    }
    get waitingData() {
        const datas = this.waitingDatas;
        if (datas.length === 0) {
            return undefined;
        }
        const data = datas[0];
        const wrapper = data.data.mode === "amino"
            ? cosmos_1.SignDocWrapper.fromAminoSignDoc(data.data.signDoc)
            : cosmos_1.SignDocWrapper.fromDirectSignDocBytes(data.data.signDocBytes);
        return {
            id: data.id,
            type: data.type,
            isInternal: data.isInternal,
            data: {
                chainId: data.data.chainId,
                msgOrigin: data.data.msgOrigin,
                signer: data.data.signer,
                signDocWrapper: wrapper,
                signOptions: data.data.signOptions,
                isADR36WithString: "isADR36WithString" in data.data
                    ? data.data.isADR36WithString
                    : undefined,
                ethSignType: "ethSignType" in data.data ? data.data.ethSignType : undefined,
            },
        };
    }
    isEnded() {
        return this.interactionStore.getEvents("request-sign-end").length > 0;
    }
    clearEnded() {
        this.interactionStore.clearEvent("request-sign-end");
    }
    waitEnd() {
        if (this.isEnded()) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (this.isEnded()) {
                    resolve();
                    this.clearEnded();
                    disposer();
                }
            });
        });
    }
    *approveAndWaitEnd(newSignDocWrapper) {
        if (this.waitingDatas.length === 0) {
            return;
        }
        this._isLoading = true;
        const id = this.waitingDatas[0].id;
        try {
            const newSignDoc = newSignDocWrapper.mode === "amino"
                ? newSignDocWrapper.aminoSignDoc
                : newSignDocWrapper.protoSignDoc.toBytes();
            yield this.interactionStore.approveWithoutRemovingData(id, newSignDoc);
        }
        finally {
            yield this.waitEnd();
            this.interactionStore.removeData("request-sign", id);
            this._isLoading = false;
        }
    }
    *reject() {
        if (this.waitingDatas.length === 0) {
            return;
        }
        this._isLoading = true;
        try {
            yield this.interactionStore.reject("request-sign", this.waitingDatas[0].id);
        }
        finally {
            this._isLoading = false;
        }
    }
    *rejectAll() {
        this._isLoading = true;
        try {
            yield this.interactionStore.rejectAll("request-sign");
        }
        finally {
            this._isLoading = false;
        }
    }
    *rejectWithId(id) {
        yield this.interactionStore.reject("request-sign", id);
    }
    get isLoading() {
        return this._isLoading;
    }
}
__decorate([
    mobx_1.observable
], SignInteractionStore.prototype, "_isLoading", void 0);
__decorate([
    mobx_1.computed
], SignInteractionStore.prototype, "waitingData", null);
__decorate([
    mobx_1.flow
], SignInteractionStore.prototype, "approveAndWaitEnd", null);
__decorate([
    mobx_1.flow
], SignInteractionStore.prototype, "reject", null);
__decorate([
    mobx_1.flow
], SignInteractionStore.prototype, "rejectAll", null);
__decorate([
    mobx_1.flow
], SignInteractionStore.prototype, "rejectWithId", null);
exports.SignInteractionStore = SignInteractionStore;
//# sourceMappingURL=sign.js.map