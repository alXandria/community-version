"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionStore = void 0;
const router_1 = require("@keplr-wallet/router");
const background_1 = require("@keplr-wallet/background");
const mobx_1 = require("mobx");
class InteractionStore {
    constructor(router, msgRequester) {
        this.router = router;
        this.msgRequester = msgRequester;
        this.datas = new Map();
        this.events = new Map();
        mobx_1.makeObservable(this);
        const service = new background_1.InteractionForegroundService(this);
        background_1.interactionForegroundInit(router, service);
    }
    getDatas(type) {
        var _a;
        return (_a = mobx_1.toJS(this.datas.get(type))) !== null && _a !== void 0 ? _a : [];
    }
    getEvents(type) {
        var _a;
        return ((_a = mobx_1.toJS(this.events.get(type))) !== null && _a !== void 0 ? _a : []);
    }
    onInteractionDataReceived(data) {
        if (!this.datas.has(data.type)) {
            this.datas.set(data.type, mobx_1.observable.array([], {
                deep: false,
            }));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.datas.get(data.type).push(data);
    }
    onEventDataReceived(data) {
        if (!this.events.has(data.type)) {
            this.events.set(data.type, mobx_1.observable.array([], {
                deep: false,
            }));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.events.get(data.type).push(data);
    }
    *approve(type, id, result) {
        this.removeData(type, id);
        yield this.msgRequester.sendMessage(router_1.BACKGROUND_PORT, new background_1.ApproveInteractionMsg(id, result));
    }
    /**
     * Approve the interaction without removing the data on the store.
     * Actually, this method is used for the sign interaction to wait the actual signing ends.
     * You should make sure that remove the data manually.
     * @param id
     * @param result
     */
    *approveWithoutRemovingData(id, result) {
        yield this.msgRequester.sendMessage(router_1.BACKGROUND_PORT, new background_1.ApproveInteractionMsg(id, result));
    }
    *reject(type, id) {
        this.removeData(type, id);
        yield this.msgRequester.sendMessage(router_1.BACKGROUND_PORT, new background_1.RejectInteractionMsg(id));
    }
    *rejectAll(type) {
        const datas = this.getDatas(type);
        for (const data of datas) {
            yield this.reject(data.type, data.id);
        }
    }
    removeData(type, id) {
        if (this.datas.has(type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const find = this.datas.get(type).find((data) => {
                return data.id === id;
            });
            if (find) {
                this.datas.get(type).remove(find);
            }
        }
    }
    clearEvent(type) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.events.has(type) && this.events.get(type).length > 0) {
            this.events.set(type, mobx_1.observable.array([], {
                deep: false,
            }));
        }
    }
}
__decorate([
    mobx_1.observable.shallow
], InteractionStore.prototype, "datas", void 0);
__decorate([
    mobx_1.observable.shallow
], InteractionStore.prototype, "events", void 0);
__decorate([
    mobx_1.action
], InteractionStore.prototype, "onInteractionDataReceived", null);
__decorate([
    mobx_1.action
], InteractionStore.prototype, "onEventDataReceived", null);
__decorate([
    mobx_1.flow
], InteractionStore.prototype, "approve", null);
__decorate([
    mobx_1.flow
], InteractionStore.prototype, "approveWithoutRemovingData", null);
__decorate([
    mobx_1.flow
], InteractionStore.prototype, "reject", null);
__decorate([
    mobx_1.flow
], InteractionStore.prototype, "rejectAll", null);
__decorate([
    mobx_1.action
], InteractionStore.prototype, "removeData", null);
__decorate([
    mobx_1.action
], InteractionStore.prototype, "clearEvent", null);
exports.InteractionStore = InteractionStore;
//# sourceMappingURL=interaction.js.map