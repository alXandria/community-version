"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyRingStore = exports.KeyRingSelectablesStore = void 0;
const router_1 = require("@keplr-wallet/router");
const background_1 = require("@keplr-wallet/background");
const mobx_1 = require("mobx");
const common_1 = require("@keplr-wallet/common");
class KeyRingSelectablesStore {
    constructor(chainGetter, requester, chainId, keyRingStore) {
        this.chainGetter = chainGetter;
        this.requester = requester;
        this.chainId = chainId;
        this.keyRingStore = keyRingStore;
        this.isInitializing = false;
        this._isKeyStoreCoinTypeSet = false;
        this._selectables = [];
        mobx_1.makeObservable(this);
        this.refresh();
    }
    get needSelectCoinType() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        if (!chainInfo.alternativeBIP44s ||
            chainInfo.alternativeBIP44s.length === 0) {
            return false;
        }
        return !this.isInitializing && !this._isKeyStoreCoinTypeSet;
    }
    get selectables() {
        return this._selectables;
    }
    *refresh() {
        var _a;
        // No need to set the coin type if the key store type is not mnemonic.
        if (this.keyRingStore.keyRingType !== "mnemonic") {
            this.isInitializing = false;
            this._isKeyStoreCoinTypeSet = true;
            this._selectables = [];
            return;
        }
        this.isInitializing = true;
        const chainInfo = this.chainGetter.getChain(this.chainId);
        const msg = new background_1.GetIsKeyStoreCoinTypeSetMsg(this.chainId, [
            chainInfo.bip44,
            ...((_a = chainInfo.alternativeBIP44s) !== null && _a !== void 0 ? _a : []),
        ]);
        const seletables = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        if (seletables.length === 0) {
            this._isKeyStoreCoinTypeSet = true;
        }
        else if (seletables.length === 1) {
            yield this.keyRingStore.setKeyStoreCoinType(this.chainId, seletables[0].path.coinType);
            this._isKeyStoreCoinTypeSet = true;
        }
        else {
            this._selectables = seletables;
            this._isKeyStoreCoinTypeSet = false;
        }
        this.isInitializing = false;
    }
}
__decorate([
    mobx_1.observable
], KeyRingSelectablesStore.prototype, "isInitializing", void 0);
__decorate([
    mobx_1.observable
], KeyRingSelectablesStore.prototype, "_isKeyStoreCoinTypeSet", void 0);
__decorate([
    mobx_1.observable.ref
], KeyRingSelectablesStore.prototype, "_selectables", void 0);
__decorate([
    mobx_1.computed
], KeyRingSelectablesStore.prototype, "needSelectCoinType", null);
__decorate([
    mobx_1.flow
], KeyRingSelectablesStore.prototype, "refresh", null);
exports.KeyRingSelectablesStore = KeyRingSelectablesStore;
/*
 Actual key ring logic is managed in persistent background. Refer "src/common/message" and "src/background/keyring"
 This store only interact with key ring in persistent background.
 */
class KeyRingStore {
    constructor(eventDispatcher, defaultKdf, chainGetter, requester, interactionStore) {
        this.eventDispatcher = eventDispatcher;
        this.defaultKdf = defaultKdf;
        this.chainGetter = chainGetter;
        this.requester = requester;
        this.interactionStore = interactionStore;
        this.status = background_1.KeyRingStatus.NOTLOADED;
        this.multiKeyStoreInfo = [];
        this.selectablesMap = new Map();
        this.keyStoreChangedListeners = [];
        mobx_1.makeObservable(this);
        this.restore();
    }
    get keyRingType() {
        const keyStore = this.multiKeyStoreInfo.find((keyStore) => keyStore.selected);
        if (!keyStore) {
            return "none";
        }
        else {
            return background_1.KeyRing.getTypeOfKeyStore(keyStore);
        }
    }
    *createMnemonicKey(mnemonic, password, meta, bip44HDPath, kdf = this.defaultKdf) {
        const msg = new background_1.CreateMnemonicKeyMsg(kdf, mnemonic, password, meta, bip44HDPath);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
    }
    *createPrivateKey(privateKey, password, meta, kdf = this.defaultKdf) {
        const msg = new background_1.CreatePrivateKeyMsg(kdf, privateKey, password, meta);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
    }
    *createLedgerKey(password, meta, bip44HDPath, kdf = this.defaultKdf) {
        const msg = new background_1.CreateLedgerKeyMsg(kdf, password, meta, bip44HDPath);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
    }
    *addMnemonicKey(mnemonic, meta, bip44HDPath, kdf = this.defaultKdf) {
        const msg = new background_1.AddMnemonicKeyMsg(kdf, mnemonic, meta, bip44HDPath);
        this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;
    }
    *addPrivateKey(privateKey, meta, kdf = this.defaultKdf) {
        const msg = new background_1.AddPrivateKeyMsg(kdf, privateKey, meta);
        this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;
    }
    *addLedgerKey(meta, bip44HDPath, kdf = this.defaultKdf) {
        const msg = new background_1.AddLedgerKeyMsg(kdf, meta, bip44HDPath);
        this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;
    }
    *changeKeyRing(index) {
        const msg = new background_1.ChangeKeyRingMsg(index);
        this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg))).multiKeyStoreInfo;
        // Emit the key store changed event manually.
        this.dispatchKeyStoreChangeEvent();
        this.selectablesMap.forEach((selectables) => selectables.refresh());
    }
    *lock() {
        const msg = new background_1.LockKeyRingMsg();
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
    }
    *unlock(password) {
        const msg = new background_1.UnlockKeyRingMsg(password);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        // Approve all waiting interaction for the enabling key ring.
        for (const interaction of this.interactionStore.getDatas("unlock")) {
            yield this.interactionStore.approve("unlock", interaction.id, {});
        }
        this.dispatchKeyStoreChangeEvent();
        this.selectablesMap.forEach((selectables) => selectables.refresh());
    }
    *rejectAll() {
        yield this.interactionStore.rejectAll("unlock");
    }
    *restore() {
        const msg = new background_1.RestoreKeyRingMsg();
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
    }
    showKeyRing(index, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = new background_1.ShowKeyRingMsg(index, password);
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, msg);
        });
    }
    *deleteKeyRing(index, password) {
        const selectedIndex = this.multiKeyStoreInfo.findIndex((keyStore) => keyStore.selected);
        const msg = new background_1.DeleteKeyRingMsg(index, password);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.status = result.status;
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
        // Selected keystore may be changed if the selected one is deleted.
        if (selectedIndex === index) {
            this.dispatchKeyStoreChangeEvent();
            this.selectablesMap.forEach((selectables) => selectables.refresh());
        }
    }
    *updateNameKeyRing(index, name) {
        const msg = new background_1.UpdateNameKeyRingMsg(index, name);
        const result = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, msg));
        this.multiKeyStoreInfo = result.multiKeyStoreInfo;
        const selectedIndex = this.multiKeyStoreInfo.findIndex((keyStore) => keyStore.selected);
        // If selectedIndex and index are same, name could be changed, so dispatch keystore event
        if (selectedIndex === index) {
            this.dispatchKeyStoreChangeEvent();
        }
    }
    checkPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.CheckPasswordMsg(password));
        });
    }
    getKeyStoreSelectables(chainId) {
        if (!this.selectablesMap.has(chainId)) {
            mobx_1.runInAction(() => {
                this.selectablesMap.set(chainId, new KeyRingSelectablesStore(this.chainGetter, this.requester, chainId, this));
            });
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.selectablesMap.get(chainId);
    }
    // Set the coin type to current key store.
    // And, save it, refresh the key store.
    *setKeyStoreCoinType(chainId, coinType) {
        const status = yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.SetKeyStoreCoinTypeMsg(chainId, coinType)));
        this.multiKeyStoreInfo = (yield* common_1.toGenerator(this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.GetMultiKeyStoreInfoMsg()))).multiKeyStoreInfo;
        this.status = status;
        // Emit the key store changed event manually.
        this.dispatchKeyStoreChangeEvent();
        this.selectablesMap.forEach((selectables) => selectables.refresh());
    }
    exportKeyRingDatas(password) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.requester.sendMessage(router_1.BACKGROUND_PORT, new background_1.ExportKeyRingDatasMsg(password));
        });
    }
    dispatchKeyStoreChangeEvent() {
        this.eventDispatcher.dispatchEvent("keplr_keystorechange");
        for (const listener of this.keyStoreChangedListeners) {
            listener();
        }
    }
    addKeyStoreChangedListener(listener) {
        this.keyStoreChangedListeners.push(listener);
    }
    removeKeyStoreChangedListener(listener) {
        const i = this.keyStoreChangedListeners.indexOf(listener);
        if (i >= 0) {
            this.keyStoreChangedListeners.splice(i, 1);
        }
    }
}
__decorate([
    mobx_1.observable
], KeyRingStore.prototype, "status", void 0);
__decorate([
    mobx_1.observable
], KeyRingStore.prototype, "multiKeyStoreInfo", void 0);
__decorate([
    mobx_1.observable.shallow
], KeyRingStore.prototype, "selectablesMap", void 0);
__decorate([
    mobx_1.computed
], KeyRingStore.prototype, "keyRingType", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "createMnemonicKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "createPrivateKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "createLedgerKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "addMnemonicKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "addPrivateKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "addLedgerKey", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "changeKeyRing", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "lock", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "unlock", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "rejectAll", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "restore", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "deleteKeyRing", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "updateNameKeyRing", null);
__decorate([
    mobx_1.flow
], KeyRingStore.prototype, "setKeyStoreCoinType", null);
exports.KeyRingStore = KeyRingStore;
//# sourceMappingURL=keyring.js.map