import { AppCurrency, ChainInfo } from "@keplr-wallet/types";
import { ChainInfoInner, ChainStore } from "../chain";
import { CosmosQueries, CosmwasmQueries, IQueriesStore, QueriesSetBase } from "../query";
import { KVStore } from "@keplr-wallet/common";
declare type CacheIBCDenomData = {
    denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    };
    originChainId: string | undefined;
    counterpartyChainId: string | undefined;
};
export declare class IBCCurrencyRegsitrarInner<C extends ChainInfo = ChainInfo> {
    protected readonly kvStore: KVStore;
    protected readonly cacheDuration: number;
    protected readonly chainInfoInner: ChainInfoInner<C>;
    protected readonly chainStore: ChainStore<C>;
    protected readonly accountStore: {
        hasAccount(chainId: string): boolean;
        getAccount(chainId: string): {
            bech32Address: string;
        };
    };
    protected readonly queriesStore: IQueriesStore<CosmosQueries>;
    protected readonly cosmwasmQueriesStore: IQueriesStore<CosmwasmQueries> | undefined;
    protected readonly coinDenomGenerator: (denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    }, originChainInfo: ChainInfoInner | undefined, counterpartyChainInfo: ChainInfoInner | undefined, originCurrency: AppCurrency | undefined) => string;
    protected isInitialized: boolean;
    protected isInitializing: boolean;
    /**
     * Because the `QueryStore` returns the response from cache first if the last response exists, it takes the IO.
     * But, if many unknown currencies requested, this make many IO and queries occur at the same time.
     * This can make the performance issue, so to reduce this problem, use the alternative caching logic
     * and the denom trace shouldn't be changed in the normal case.
     * To decrease the number of IO, make sure that reading from storage should happen when the unknown currencies exist
     * and don't split the data with keys and as posible as combine them to one data structure and key.
     * @protected
     */
    protected cacheDenomTracePaths: Map<string, CacheIBCDenomData & {
        timestamp: number;
    }>;
    constructor(kvStore: KVStore, cacheDuration: number, chainInfoInner: ChainInfoInner<C>, chainStore: ChainStore<C>, accountStore: {
        hasAccount(chainId: string): boolean;
        getAccount(chainId: string): {
            bech32Address: string;
        };
    }, queriesStore: IQueriesStore<CosmosQueries>, cosmwasmQueriesStore: IQueriesStore<CosmwasmQueries> | undefined, coinDenomGenerator: (denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    }, originChainInfo: ChainInfoInner | undefined, counterpartyChainInfo: ChainInfoInner | undefined, originCurrency: AppCurrency | undefined) => string);
    protected restoreCache(): Generator<Promise<Record<string, CacheIBCDenomData & {
        timestamp: number;
    }> | undefined>, void, Record<string, CacheIBCDenomData & {
        timestamp: number;
    }> | undefined>;
    protected getCacheIBCDenomData(denomTraceHash: string): CacheIBCDenomData | undefined;
    protected setCacheIBCDenomData(denomTraceHash: string, data: CacheIBCDenomData): Generator<Promise<void>, void, unknown>;
    registerUnknownCurrencies(coinMinimalDenom: string): [AppCurrency | undefined, boolean] | undefined;
}
/**
 * IBCCurrencyRegsitrar gets the native balances that exist on the chain itself (ex. atom, scrt...)
 * And, IBCCurrencyRegsitrar registers the currencies from IBC to the chain info.
 * In cosmos-sdk, the denomination of IBC token has the form of "ibc/{hash}".
 * And, its paths can be found by getting the denom trace from the node.
 * If the native balance querier's response have the token that is form of IBC token,
 * this will try to get the denom info by traversing the paths, and register the currency with the decimal and denom info.
 * But, if failed to traverse the paths, this will register the currency with 0 decimal and the minimal denom even though it is not suitable for human.
 */
export declare class IBCCurrencyRegsitrar<C extends ChainInfo = ChainInfo> {
    protected readonly kvStore: KVStore;
    protected readonly cacheDuration: number;
    protected readonly chainStore: ChainStore<C>;
    protected readonly accountStore: {
        hasAccount(chainId: string): boolean;
        getAccount(chainId: string): {
            bech32Address: string;
        };
    };
    protected readonly queriesStore: {
        get(chainId: string): QueriesSetBase & CosmosQueries;
    };
    protected readonly cosmwasmQueriesStore: {
        get(chainId: string): QueriesSetBase & CosmwasmQueries;
    } | undefined;
    protected readonly coinDenomGenerator: (denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    }, originChainInfo: ChainInfoInner | undefined, counterpartyChainInfo: ChainInfoInner | undefined, originCurrency: AppCurrency | undefined) => string;
    protected map: Map<string, IBCCurrencyRegsitrarInner<C>>;
    static defaultCoinDenomGenerator(denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    }, _: ChainInfoInner | undefined, counterpartyChainInfo: ChainInfoInner | undefined, originCurrency: AppCurrency | undefined): string;
    constructor(kvStore: KVStore, cacheDuration: number, // 1 days
    chainStore: ChainStore<C>, accountStore: {
        hasAccount(chainId: string): boolean;
        getAccount(chainId: string): {
            bech32Address: string;
        };
    }, queriesStore: {
        get(chainId: string): QueriesSetBase & CosmosQueries;
    }, cosmwasmQueriesStore: {
        get(chainId: string): QueriesSetBase & CosmwasmQueries;
    } | undefined, coinDenomGenerator?: (denomTrace: {
        denom: string;
        paths: {
            portId: string;
            channelId: string;
        }[];
    }, originChainInfo: ChainInfoInner | undefined, counterpartyChainInfo: ChainInfoInner | undefined, originCurrency: AppCurrency | undefined) => string);
    setChainInfoHandler(chainInfoInner: ChainInfoInner<C>): void;
    protected get(chainInfoInner: ChainInfoInner<C>): IBCCurrencyRegsitrarInner<C>;
}
export {};
