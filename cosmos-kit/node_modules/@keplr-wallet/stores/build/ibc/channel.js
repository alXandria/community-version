"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IBCChannelStore = exports.IBCChannelStoreInner = void 0;
const common_1 = require("@keplr-wallet/common");
const mobx_1 = require("mobx");
const mobx_utils_1 = require("mobx-utils");
const common_2 = require("../common");
const cosmos_1 = require("@keplr-wallet/cosmos");
class IBCChannelStoreInner {
    constructor(kvStore, chainId) {
        this.kvStore = kvStore;
        this.chainId = chainId;
        // channelMap[portId][channelId]
        this.channelMap = new Map();
        this.getChannelsToPort = mobx_utils_1.computedFn((portId) => {
            if (!this.channelMap.has(portId)) {
                mobx_1.runInAction(() => {
                    this.channelMap.set(portId, mobx_1.observable.map({}, {
                        deep: false,
                    }));
                });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const channelMapOfPort = this.channelMap.get(portId);
            const channels = [];
            for (const channel of channelMapOfPort.values()) {
                channels.push(channel);
            }
            return channels;
        });
        this.getChannel = mobx_utils_1.computedFn((portId, channelId) => {
            var _a;
            return (_a = this.channelMap.get(portId)) === null || _a === void 0 ? void 0 : _a.get(channelId);
        });
        mobx_1.makeObservable(this);
        this.loadChannels();
    }
    getTransferChannels() {
        return this.getChannelsToPort("transfer");
    }
    *addChannel(channel) {
        if (!this.channelMap.has(channel.portId)) {
            this.channelMap.set(channel.portId, mobx_1.observable.map({}, {
                deep: false,
            }));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.channelMap.get(channel.portId).set(channel.channelId, channel);
        yield this.saveChannels();
    }
    *loadChannels() {
        const obj = yield* common_1.toGenerator(this.kvStore.get(`${cosmos_1.ChainIdHelper.parse(this.chainId).identifier}-channels`));
        if (obj) {
            for (const portId of Object.keys(obj)) {
                const map = obj[portId];
                for (const channelId of Object.keys(map)) {
                    if (!this.channelMap.has(portId)) {
                        this.channelMap.set(portId, mobx_1.observable.map({}, { deep: false }));
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const innerMap = this.channelMap.get(portId);
                    innerMap.set(channelId, map[channelId]);
                }
            }
        }
    }
    saveChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            const obj = {};
            this.channelMap.forEach((v, portId) => {
                obj[portId] = (() => {
                    const obj = {};
                    v.forEach((channel, channelId) => {
                        obj[channelId] = channel;
                    });
                    return obj;
                })();
            });
            yield this.kvStore.set(`${cosmos_1.ChainIdHelper.parse(this.chainId).identifier}-channels`, obj);
        });
    }
}
__decorate([
    mobx_1.observable.shallow
], IBCChannelStoreInner.prototype, "channelMap", void 0);
__decorate([
    mobx_1.flow
], IBCChannelStoreInner.prototype, "addChannel", null);
__decorate([
    mobx_1.flow
], IBCChannelStoreInner.prototype, "loadChannels", null);
exports.IBCChannelStoreInner = IBCChannelStoreInner;
/**
 * IBCChannelStore saves the IBC channel infomations to the storage.
 */
class IBCChannelStore extends common_2.HasMapStore {
    constructor(kvStore) {
        super((chainId) => {
            return new IBCChannelStoreInner(kvStore, chainId);
        });
        this.kvStore = kvStore;
    }
    get(chainId) {
        return super.get(chainId);
    }
}
exports.IBCChannelStore = IBCChannelStore;
//# sourceMappingURL=channel.js.map