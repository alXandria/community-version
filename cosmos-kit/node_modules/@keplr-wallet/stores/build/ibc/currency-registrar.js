"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IBCCurrencyRegsitrar = exports.IBCCurrencyRegsitrarInner = void 0;
const mobx_1 = require("mobx");
const common_1 = require("@keplr-wallet/common");
class IBCCurrencyRegsitrarInner {
    constructor(kvStore, cacheDuration, chainInfoInner, chainStore, accountStore, queriesStore, cosmwasmQueriesStore, coinDenomGenerator) {
        this.kvStore = kvStore;
        this.cacheDuration = cacheDuration;
        this.chainInfoInner = chainInfoInner;
        this.chainStore = chainStore;
        this.accountStore = accountStore;
        this.queriesStore = queriesStore;
        this.cosmwasmQueriesStore = cosmwasmQueriesStore;
        this.coinDenomGenerator = coinDenomGenerator;
        this.isInitialized = false;
        this.isInitializing = false;
        /**
         * Because the `QueryStore` returns the response from cache first if the last response exists, it takes the IO.
         * But, if many unknown currencies requested, this make many IO and queries occur at the same time.
         * This can make the performance issue, so to reduce this problem, use the alternative caching logic
         * and the denom trace shouldn't be changed in the normal case.
         * To decrease the number of IO, make sure that reading from storage should happen when the unknown currencies exist
         * and don't split the data with keys and as posible as combine them to one data structure and key.
         * @protected
         */
        this.cacheDenomTracePaths = new Map();
        mobx_1.makeObservable(this);
    }
    *restoreCache() {
        this.isInitializing = true;
        const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;
        const obj = yield* common_1.toGenerator(this.kvStore.get(key));
        if (obj) {
            for (const key of Object.keys(obj)) {
                this.cacheDenomTracePaths.set(key, obj[key]);
            }
        }
        this.isInitialized = true;
        this.isInitializing = false;
    }
    getCacheIBCDenomData(denomTraceHash) {
        const result = this.cacheDenomTracePaths.get(denomTraceHash);
        if (result && result.timestamp + this.cacheDuration > Date.now()) {
            return result;
        }
    }
    *setCacheIBCDenomData(denomTraceHash, data) {
        this.cacheDenomTracePaths.set(denomTraceHash, Object.assign(Object.assign({}, data), { timestamp: Date.now() }));
        const obj = {};
        this.cacheDenomTracePaths.forEach((value, key) => {
            obj[key] = value;
        });
        const key = `cache-ibc-denom-trace-paths/${this.chainInfoInner.chainId}`;
        yield this.kvStore.set(key, obj);
    }
    registerUnknownCurrencies(coinMinimalDenom) {
        const denomHelper = new common_1.DenomHelper(coinMinimalDenom);
        if (denomHelper.type !== "native" ||
            !denomHelper.denom.startsWith("ibc/")) {
            // IBC Currency's denom should start with "ibc/"
            return;
        }
        // When the unknown ibc denom is delivered, try to restore the cache from storage.
        if (!this.isInitialized) {
            this.restoreCache();
        }
        if (this.isInitializing) {
            return [undefined, false];
        }
        const queries = this.queriesStore.get(this.chainInfoInner.chainId);
        const hash = denomHelper.denom.replace("ibc/", "");
        const cached = this.getCacheIBCDenomData(hash);
        let counterpartyChainInfo;
        let originChainInfo;
        let denomTrace;
        if (cached) {
            denomTrace = cached.denomTrace;
            if (cached.originChainId &&
                this.chainStore.hasChain(cached.originChainId)) {
                originChainInfo = this.chainStore.getChain(cached.originChainId);
            }
            if (cached.counterpartyChainId &&
                this.chainStore.hasChain(cached.counterpartyChainId)) {
                counterpartyChainInfo = this.chainStore.getChain(cached.counterpartyChainId);
            }
        }
        else {
            const queryDenomTrace = queries.cosmos.queryIBCDenomTrace.getDenomTrace(hash);
            denomTrace = queryDenomTrace.denomTrace;
            if (denomTrace) {
                const paths = denomTrace.paths;
                // The previous chain id from current path.
                let chainIdBefore = this.chainInfoInner.chainId;
                for (const path of paths) {
                    const clientState = this.queriesStore
                        .get(chainIdBefore)
                        .cosmos.queryIBCClientState.getClientState(path.portId, path.channelId);
                    if (clientState.clientChainId &&
                        this.chainStore.hasChain(clientState.clientChainId)) {
                        chainIdBefore = clientState.clientChainId;
                        originChainInfo = this.chainStore.getChain(clientState.clientChainId);
                        if (!counterpartyChainInfo) {
                            counterpartyChainInfo = this.chainStore.getChain(clientState.clientChainId);
                        }
                    }
                    else {
                        originChainInfo = undefined;
                        break;
                    }
                }
                if (originChainInfo) {
                    this.setCacheIBCDenomData(hash, {
                        counterpartyChainId: counterpartyChainInfo === null || counterpartyChainInfo === void 0 ? void 0 : counterpartyChainInfo.chainId,
                        denomTrace,
                        originChainId: originChainInfo.chainId,
                    });
                }
            }
        }
        if (originChainInfo && denomTrace) {
            if (denomTrace.denom.split(/^(cw20):(\w+)$/).length === 4) {
                // If the origin currency is ics20-cw20.
                let cw20Currency = originChainInfo.currencies.find((cur) => denomTrace && cur.coinMinimalDenom.startsWith(denomTrace.denom));
                if (!cw20Currency && this.cosmwasmQueriesStore) {
                    const cosmwasmQuries = this.cosmwasmQueriesStore.get(originChainInfo.chainId);
                    const contractAddress = denomTrace.denom.replace("cw20:", "");
                    const contractInfo = cosmwasmQuries.cosmwasm.querycw20ContractInfo.getQueryContract(contractAddress);
                    if (contractInfo.response) {
                        cw20Currency = {
                            type: "cw20",
                            contractAddress,
                            coinDecimals: contractInfo.response.data.decimals,
                            coinDenom: contractInfo.response.data.symbol,
                            coinMinimalDenom: `cw20:${contractAddress}:${contractInfo.response.data.name}`,
                        };
                        originChainInfo.addCurrencies(cw20Currency);
                    }
                }
                if (cw20Currency) {
                    return [
                        {
                            coinDecimals: cw20Currency.coinDecimals,
                            coinGeckoId: cw20Currency.coinGeckoId,
                            coinImageUrl: cw20Currency.coinImageUrl,
                            coinMinimalDenom: denomHelper.denom,
                            coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, cw20Currency),
                            paths: denomTrace.paths,
                            originChainId: originChainInfo.chainId,
                            originCurrency: cw20Currency,
                        },
                        true,
                    ];
                }
            }
            else {
                const currency = originChainInfo.findCurrency(denomTrace.denom);
                if (currency && !("paths" in currency)) {
                    return [
                        {
                            coinDecimals: currency.coinDecimals,
                            coinGeckoId: currency.coinGeckoId,
                            coinImageUrl: currency.coinImageUrl,
                            coinMinimalDenom: denomHelper.denom,
                            coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, currency),
                            paths: denomTrace.paths,
                            originChainId: originChainInfo.chainId,
                            originCurrency: currency,
                        },
                        true,
                    ];
                }
            }
            // In this case, just show the raw currency.
            // But, it is possible to know the currency from query later.
            // So, let them to be observed.
            return [
                {
                    coinDecimals: 0,
                    coinMinimalDenom: denomHelper.denom,
                    coinDenom: this.coinDenomGenerator(denomTrace, originChainInfo, counterpartyChainInfo, undefined),
                    paths: denomTrace.paths,
                    originChainId: undefined,
                    originCurrency: undefined,
                },
                false,
            ];
        }
        return [undefined, false];
    }
}
__decorate([
    mobx_1.observable
], IBCCurrencyRegsitrarInner.prototype, "isInitialized", void 0);
__decorate([
    mobx_1.observable
], IBCCurrencyRegsitrarInner.prototype, "isInitializing", void 0);
__decorate([
    mobx_1.observable.shallow
], IBCCurrencyRegsitrarInner.prototype, "cacheDenomTracePaths", void 0);
__decorate([
    mobx_1.flow
], IBCCurrencyRegsitrarInner.prototype, "restoreCache", null);
__decorate([
    mobx_1.flow
], IBCCurrencyRegsitrarInner.prototype, "setCacheIBCDenomData", null);
exports.IBCCurrencyRegsitrarInner = IBCCurrencyRegsitrarInner;
/**
 * IBCCurrencyRegsitrar gets the native balances that exist on the chain itself (ex. atom, scrt...)
 * And, IBCCurrencyRegsitrar registers the currencies from IBC to the chain info.
 * In cosmos-sdk, the denomination of IBC token has the form of "ibc/{hash}".
 * And, its paths can be found by getting the denom trace from the node.
 * If the native balance querier's response have the token that is form of IBC token,
 * this will try to get the denom info by traversing the paths, and register the currency with the decimal and denom info.
 * But, if failed to traverse the paths, this will register the currency with 0 decimal and the minimal denom even though it is not suitable for human.
 */
class IBCCurrencyRegsitrar {
    constructor(kvStore, cacheDuration = 24 * 3600 * 1000, // 1 days
    chainStore, accountStore, queriesStore, cosmwasmQueriesStore, coinDenomGenerator = IBCCurrencyRegsitrar.defaultCoinDenomGenerator) {
        this.kvStore = kvStore;
        this.cacheDuration = cacheDuration;
        this.chainStore = chainStore;
        this.accountStore = accountStore;
        this.queriesStore = queriesStore;
        this.cosmwasmQueriesStore = cosmwasmQueriesStore;
        this.coinDenomGenerator = coinDenomGenerator;
        this.map = new Map();
        this.chainStore.addSetChainInfoHandler((chainInfoInner) => this.setChainInfoHandler(chainInfoInner));
    }
    static defaultCoinDenomGenerator(denomTrace, _, counterpartyChainInfo, originCurrency) {
        if (originCurrency) {
            return `${originCurrency.coinDenom} (${counterpartyChainInfo ? counterpartyChainInfo.chainName : "Unknown"}/${denomTrace.paths[0].channelId})`;
        }
        else {
            return `${denomTrace.denom} (${counterpartyChainInfo ? counterpartyChainInfo.chainName : "Unknown"}/${denomTrace.paths[0].channelId})`;
        }
    }
    setChainInfoHandler(chainInfoInner) {
        const inner = this.get(chainInfoInner);
        chainInfoInner.registerCurrencyRegistrar((coinMinimalDenom) => inner.registerUnknownCurrencies(coinMinimalDenom));
    }
    get(chainInfoInner) {
        if (!this.map.has(chainInfoInner.chainId)) {
            mobx_1.runInAction(() => {
                this.map.set(chainInfoInner.chainId, new IBCCurrencyRegsitrarInner(this.kvStore, this.cacheDuration, chainInfoInner, this.chainStore, this.accountStore, this.queriesStore, this.cosmwasmQueriesStore, this.coinDenomGenerator));
            });
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.map.get(chainInfoInner.chainId);
    }
}
__decorate([
    mobx_1.observable.shallow
], IBCCurrencyRegsitrar.prototype, "map", void 0);
exports.IBCCurrencyRegsitrar = IBCCurrencyRegsitrar;
//# sourceMappingURL=currency-registrar.js.map