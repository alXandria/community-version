"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainStore = exports.ChainInfoInner = void 0;
const mobx_1 = require("mobx");
const cosmos_1 = require("@keplr-wallet/cosmos");
const mobx_utils_1 = require("mobx-utils");
class ChainInfoInner {
    constructor(chainInfo) {
        this.unknownDenoms = [];
        this.registeredCurrencies = [];
        /**
         * 위의 unknownDenoms에 값이 들어오면 밑의 배열의 함수를 순차적으로 실행한다.
         * 만약 Currency 반환하면 그 registrar이 그 denom을 처리했다고 판단하고 순회를 멈춘다.
         * 또한 AppCurrency가 아니라 [AppCurrency, boolean]의 튜플을 반활할 수 있는데
         * 튜플을 반활할 경우 뒤의 boolean이 true일 때우(committed)까지 계속 observe한다.
         * IBC 토큰을 처리하는 경우처럼 쿼리가 다 되기 전에 raw한 currency를 반환할 필요가 있는 경우처럼
         * 등록된 currency가 나중에 replace될 수 있는 경우에 사용할 수 있다.
         */
        this.currencyRegistrars = [];
        this._chainInfo = chainInfo;
        mobx_1.makeObservable(this);
        mobx_utils_1.keepAlive(this, "currencyMap");
    }
    getCurrencyFromRegistrars(coinMinimalDenom) {
        for (let i = 0; i < this.currencyRegistrars.length; i++) {
            const registrar = this.currencyRegistrars[i];
            const currency = registrar(coinMinimalDenom);
            if (currency) {
                // AppCurrency일 경우
                if ("coinMinimalDenom" in currency) {
                    return [currency, true];
                }
                return currency;
            }
        }
        return undefined;
    }
    /*
     * 해당되는 denom의 currency를 모를 때 이 메소드를 사용해서 등록을 요청할 수 있다.
     * 이미 등록되어 있거나 등록을 시도 중이면 아무 행동도 하지 않는.
     * 예를들어 네이티브 balance 쿼리에서 모르는 denom이 나오거나
     * IBC denom의 등록을 요청할 때 쓸 수 있다.
     */
    addUnknownCurrencies(...coinMinimalDenoms) {
        for (const coinMinimalDenom of coinMinimalDenoms) {
            if (this.unknownDenoms.find((denom) => denom === coinMinimalDenom)) {
                continue;
            }
            if (this.currencyMap.has(coinMinimalDenom)) {
                continue;
            }
            this.unknownDenoms.push(coinMinimalDenom);
            const disposer = mobx_1.autorun(() => {
                const registered = this.getCurrencyFromRegistrars(coinMinimalDenom);
                if (registered) {
                    const [currency, committed] = registered;
                    mobx_1.runInAction(() => {
                        if (currency) {
                            const index = this.unknownDenoms.findIndex((denom) => denom === coinMinimalDenom);
                            if (index >= 0) {
                                this.unknownDenoms.splice(index, 1);
                            }
                            this.addOrReplaceCurrency(currency);
                        }
                        if (committed) {
                            disposer();
                        }
                    });
                }
                else {
                    disposer();
                }
            });
        }
    }
    registerCurrencyRegistrar(registrar) {
        this.currencyRegistrars.push(registrar);
    }
    setChainInfo(chainInfo) {
        this._chainInfo = chainInfo;
    }
    get raw() {
        return this._chainInfo;
    }
    get chainId() {
        return this._chainInfo.chainId;
    }
    get currencies() {
        return this._chainInfo.currencies.concat(this.registeredCurrencies);
    }
    get currencyMap() {
        const result = new Map();
        for (const currency of this.currencies) {
            result.set(currency.coinMinimalDenom, currency);
        }
        return result;
    }
    addCurrencies(...currencies) {
        const currencyMap = this.currencyMap;
        for (const currency of currencies) {
            if (!currencyMap.has(currency.coinMinimalDenom)) {
                this.registeredCurrencies.push(currency);
            }
        }
    }
    removeCurrencies(...coinMinimalDenoms) {
        const map = new Map();
        for (const coinMinimalDenom of coinMinimalDenoms) {
            map.set(coinMinimalDenom, true);
        }
        this.registeredCurrencies = this.registeredCurrencies.filter((currency) => !map.get(currency.coinMinimalDenom));
    }
    /**
     * Currency를 반환한다.
     * 만약 해당 Currency가 없다면 unknown currency에 추가한다.
     * @param coinMinimalDenom
     */
    findCurrency(coinMinimalDenom) {
        if (this.currencyMap.has(coinMinimalDenom)) {
            return this.currencyMap.get(coinMinimalDenom);
        }
        this.addUnknownCurrencies(coinMinimalDenom);
        // Unknown denom can be registered synchronously in some cases.
        // For this case, re-try to get currency.
        if (this.currencyMap.has(coinMinimalDenom)) {
            return this.currencyMap.get(coinMinimalDenom);
        }
    }
    /**
     * findCurrency와 비슷하지만 해당하는 currency가 존재하지 않을 경우 raw currency를 반환한다.
     * @param coinMinimalDenom
     */
    forceFindCurrency(coinMinimalDenom) {
        const currency = this.findCurrency(coinMinimalDenom);
        if (!currency) {
            return {
                coinMinimalDenom,
                coinDenom: coinMinimalDenom,
                coinDecimals: 0,
            };
        }
        return currency;
    }
    addOrReplaceCurrency(currency) {
        if (this.currencyMap.has(currency.coinMinimalDenom)) {
            const index = this.registeredCurrencies.findIndex((cur) => cur.coinMinimalDenom === currency.coinMinimalDenom);
            if (index >= 0) {
                this.registeredCurrencies.splice(index, 1, currency);
            }
        }
        else {
            this.registeredCurrencies.push(currency);
        }
    }
    get stakeCurrency() {
        return this.raw.stakeCurrency;
    }
    get alternativeBIP44s() {
        return this.raw.alternativeBIP44s;
    }
    get bech32Config() {
        return this.raw.bech32Config;
    }
    get beta() {
        return this.raw.beta;
    }
    get bip44() {
        return this.raw.bip44;
    }
    get chainName() {
        return this.raw.chainName;
    }
    get coinType() {
        return this.raw.coinType;
    }
    get features() {
        return this.raw.features;
    }
    get feeCurrencies() {
        return this.raw.feeCurrencies;
    }
    get gasPriceStep() {
        return this.raw.gasPriceStep;
    }
    get rest() {
        return this.raw.rest;
    }
    get restConfig() {
        return this.raw.restConfig;
    }
    get rpc() {
        return this.raw.rpc;
    }
    get rpcConfig() {
        return this.raw.rpcConfig;
    }
    get walletUrl() {
        return this.raw.walletUrl;
    }
    get walletUrlForStaking() {
        return this.raw.walletUrlForStaking;
    }
}
__decorate([
    mobx_1.observable.ref
], ChainInfoInner.prototype, "_chainInfo", void 0);
__decorate([
    mobx_1.observable.shallow
], ChainInfoInner.prototype, "unknownDenoms", void 0);
__decorate([
    mobx_1.observable.shallow
], ChainInfoInner.prototype, "registeredCurrencies", void 0);
__decorate([
    mobx_1.observable
], ChainInfoInner.prototype, "currencyRegistrars", void 0);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "addUnknownCurrencies", null);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "registerCurrencyRegistrar", null);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "setChainInfo", null);
__decorate([
    mobx_1.computed
], ChainInfoInner.prototype, "currencyMap", null);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "addCurrencies", null);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "removeCurrencies", null);
__decorate([
    mobx_1.action
], ChainInfoInner.prototype, "addOrReplaceCurrency", null);
exports.ChainInfoInner = ChainInfoInner;
class ChainStore {
    constructor(embedChainInfos) {
        this.setChainInfoHandlers = [];
        this._cachedChainInfosMap = new Map();
        this.setChainInfos(embedChainInfos);
        mobx_1.makeObservable(this);
    }
    get chainInfos() {
        return this._chainInfos;
    }
    getChain(chainId) {
        const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainId);
        const find = this.chainInfos.find((info) => {
            return (cosmos_1.ChainIdHelper.parse(info.chainId).identifier ===
                chainIdentifier.identifier);
        });
        if (!find) {
            throw new Error(`Unknown chain info: ${chainId}`);
        }
        return find;
    }
    hasChain(chainId) {
        const chainIdentifier = cosmos_1.ChainIdHelper.parse(chainId);
        const find = this.chainInfos.find((info) => {
            return (cosmos_1.ChainIdHelper.parse(info.chainId).identifier ===
                chainIdentifier.identifier);
        });
        return find != null;
    }
    addSetChainInfoHandler(handler) {
        this.setChainInfoHandlers.push(handler);
        for (const chainInfo of this.chainInfos) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const cached = this._cachedChainInfosMap.get(chainInfo.chainId);
            handler(cached);
        }
    }
    setChainInfos(chainInfos) {
        const chainInfoInners = [];
        for (const chainInfo of chainInfos) {
            if (this._cachedChainInfosMap.has(chainInfo.chainId)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const cached = this._cachedChainInfosMap.get(chainInfo.chainId);
                cached.setChainInfo(chainInfo);
                chainInfoInners.push(cached);
            }
            else {
                const chainInfoInner = new ChainInfoInner(chainInfo);
                this._cachedChainInfosMap.set(chainInfo.chainId, chainInfoInner);
                chainInfoInners.push(chainInfoInner);
                for (const handler of this.setChainInfoHandlers) {
                    handler(chainInfoInner);
                }
            }
        }
        this._chainInfos = chainInfoInners;
    }
}
__decorate([
    mobx_1.observable.ref
], ChainStore.prototype, "_chainInfos", void 0);
__decorate([
    mobx_1.action
], ChainStore.prototype, "setChainInfos", null);
exports.ChainStore = ChainStore;
//# sourceMappingURL=index.js.map