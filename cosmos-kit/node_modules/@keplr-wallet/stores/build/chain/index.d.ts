import { AppCurrency, Bech32Config, BIP44, ChainInfo, Currency } from "@keplr-wallet/types";
import { ChainGetter } from "../common";
import { DeepReadonly } from "utility-types";
import { AxiosRequestConfig } from "axios";
declare type CurrencyRegistrar = (coinMinimalDenom: string) => AppCurrency | [AppCurrency | undefined, boolean] | undefined;
export declare class ChainInfoInner<C extends ChainInfo = ChainInfo> implements ChainInfo {
    protected _chainInfo: C;
    protected unknownDenoms: string[];
    protected registeredCurrencies: AppCurrency[];
    /**
     * 위의 unknownDenoms에 값이 들어오면 밑의 배열의 함수를 순차적으로 실행한다.
     * 만약 Currency 반환하면 그 registrar이 그 denom을 처리했다고 판단하고 순회를 멈춘다.
     * 또한 AppCurrency가 아니라 [AppCurrency, boolean]의 튜플을 반활할 수 있는데
     * 튜플을 반활할 경우 뒤의 boolean이 true일 때우(committed)까지 계속 observe한다.
     * IBC 토큰을 처리하는 경우처럼 쿼리가 다 되기 전에 raw한 currency를 반환할 필요가 있는 경우처럼
     * 등록된 currency가 나중에 replace될 수 있는 경우에 사용할 수 있다.
     */
    protected currencyRegistrars: CurrencyRegistrar[];
    constructor(chainInfo: C);
    protected getCurrencyFromRegistrars(coinMinimalDenom: string): [AppCurrency | undefined, boolean] | undefined;
    addUnknownCurrencies(...coinMinimalDenoms: string[]): void;
    registerCurrencyRegistrar(registrar: CurrencyRegistrar): void;
    setChainInfo(chainInfo: C): void;
    get raw(): C;
    get chainId(): string;
    get currencies(): AppCurrency[];
    get currencyMap(): Map<string, AppCurrency>;
    addCurrencies(...currencies: AppCurrency[]): void;
    removeCurrencies(...coinMinimalDenoms: string[]): void;
    /**
     * Currency를 반환한다.
     * 만약 해당 Currency가 없다면 unknown currency에 추가한다.
     * @param coinMinimalDenom
     */
    findCurrency(coinMinimalDenom: string): AppCurrency | undefined;
    /**
     * findCurrency와 비슷하지만 해당하는 currency가 존재하지 않을 경우 raw currency를 반환한다.
     * @param coinMinimalDenom
     */
    forceFindCurrency(coinMinimalDenom: string): AppCurrency;
    protected addOrReplaceCurrency(currency: AppCurrency): void;
    get stakeCurrency(): Currency;
    get alternativeBIP44s(): BIP44[] | undefined;
    get bech32Config(): Bech32Config;
    get beta(): boolean | undefined;
    get bip44(): BIP44;
    get chainName(): string;
    get coinType(): number | undefined;
    get features(): string[] | undefined;
    get feeCurrencies(): Currency[];
    get gasPriceStep(): {
        low: number;
        average: number;
        high: number;
    } | undefined;
    get rest(): string;
    get restConfig(): AxiosRequestConfig | undefined;
    get rpc(): string;
    get rpcConfig(): AxiosRequestConfig | undefined;
    get walletUrl(): string | undefined;
    get walletUrlForStaking(): string | undefined;
}
export declare type ChainInfoOverrider<C extends ChainInfo = ChainInfo> = (chainInfo: DeepReadonly<C>) => C;
export declare class ChainStore<C extends ChainInfo = ChainInfo> implements ChainGetter {
    protected _chainInfos: ChainInfoInner<C>[];
    protected setChainInfoHandlers: ((chainInfoInner: ChainInfoInner<C>) => void)[];
    protected _cachedChainInfosMap: Map<string, ChainInfoInner<C>>;
    constructor(embedChainInfos: C[]);
    get chainInfos(): ChainInfoInner<C>[];
    getChain(chainId: string): ChainInfoInner<C>;
    hasChain(chainId: string): boolean;
    addSetChainInfoHandler(handler: (chainInfoInner: ChainInfoInner<C>) => void): void;
    protected setChainInfos(chainInfos: C[]): void;
}
export {};
