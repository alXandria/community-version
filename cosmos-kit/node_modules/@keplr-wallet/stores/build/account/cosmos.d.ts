import { AccountSetBaseSuper, MsgOpt } from "./base";
import { AppCurrency, KeplrSignOptions } from "@keplr-wallet/types";
import { StdFee, StdSignDoc } from "@cosmjs/launchpad";
import { Any } from "@keplr-wallet/proto-types/google/protobuf/any";
import { QueriesSetBase, IQueriesStore, CosmosQueries } from "../query";
import { DeepPartial, DeepReadonly } from "utility-types";
import { ChainGetter } from "../common";
import { AxiosInstance } from "axios";
import { MakeTxResponse, ProtoMsgsOrWithAminoMsgs } from "./types";
export interface CosmosAccount {
    cosmos: CosmosAccountImpl;
}
export declare const CosmosAccount: {
    use(options: {
        msgOptsCreator?: ((chainId: string) => DeepPartial<CosmosMsgOpts> | undefined) | undefined;
        queriesStore: IQueriesStore<CosmosQueries>;
        wsObject?: (new (url: string, protocols?: string | string[] | undefined) => WebSocket) | undefined;
        preTxEvents?: {
            onBroadcastFailed?: ((chainId: string, e?: Error | undefined) => void) | undefined;
            onBroadcasted?: ((chainId: string, txHash: Uint8Array) => void) | undefined;
            onFulfill?: ((chainId: string, tx: any) => void) | undefined;
        } | undefined;
    }): (base: AccountSetBaseSuper, chainGetter: ChainGetter, chainId: string) => CosmosAccount;
};
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
export interface CosmosMsgOpts {
    readonly send: {
        readonly native: MsgOpt;
    };
    readonly ibcTransfer: MsgOpt;
    readonly delegate: MsgOpt;
    readonly undelegate: MsgOpt;
    readonly redelegate: MsgOpt;
    readonly withdrawRewards: MsgOpt;
    readonly govVote: MsgOpt;
}
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
export declare const defaultCosmosMsgOpts: CosmosMsgOpts;
export declare class CosmosAccountImpl {
    protected readonly base: AccountSetBaseSuper;
    protected readonly chainGetter: ChainGetter;
    protected readonly chainId: string;
    protected readonly queriesStore: IQueriesStore<CosmosQueries>;
    protected readonly _msgOpts: CosmosMsgOpts;
    protected readonly txOpts: {
        wsObject?: new (url: string, protocols?: string | string[]) => WebSocket;
        preTxEvents?: {
            onBroadcastFailed?: (chainId: string, e?: Error) => void;
            onBroadcasted?: (chainId: string, txHash: Uint8Array) => void;
            onFulfill?: (chainId: string, tx: any) => void;
        };
    };
    broadcastMode: "sync" | "async" | "block";
    constructor(base: AccountSetBaseSuper, chainGetter: ChainGetter, chainId: string, queriesStore: IQueriesStore<CosmosQueries>, _msgOpts: CosmosMsgOpts, txOpts: {
        wsObject?: new (url: string, protocols?: string | string[]) => WebSocket;
        preTxEvents?: {
            onBroadcastFailed?: (chainId: string, e?: Error) => void;
            onBroadcasted?: (chainId: string, txHash: Uint8Array) => void;
            onFulfill?: (chainId: string, tx: any) => void;
        };
    });
    /**
     * @deprecated Predict gas through simulation rather than using a fixed gas.
     */
    get msgOpts(): CosmosMsgOpts;
    protected processMakeSendTokenTx(amount: string, currency: AppCurrency, recipient: string): MakeTxResponse | undefined;
    /**
     * @deprecated
     */
    protected processSendToken(amount: string, currency: AppCurrency, recipient: string, memo: string, stdFee: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<boolean>;
    sendMsgs(type: string | "unknown", msgs: ProtoMsgsOrWithAminoMsgs | (() => Promise<ProtoMsgsOrWithAminoMsgs> | ProtoMsgsOrWithAminoMsgs), memo: string | undefined, fee: StdFee, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcastFailed?: (e?: Error) => void;
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    protected broadcastMsgs(msgs: ProtoMsgsOrWithAminoMsgs, fee: StdFee, memo?: string, signOptions?: KeplrSignOptions, mode?: "block" | "async" | "sync"): Promise<{
        txHash: Uint8Array;
        signDoc: StdSignDoc;
    }>;
    /**
     * Simulate tx without making state transition on chain or not waiting the tx committed.
     * Mainly used to estimate the gas needed to process tx.
     * You should multiply arbitrary number (gas adjustment) for gas before sending tx.
     *
     * NOTE: "/cosmos/tx/v1beta1/simulate" returns 400, 500 or (more?) status and error code as a response when tx fails on stimulate.
     *       Currently, non 200~300 status is handled as error, thus error would be thrown.
     *
     * XXX: Uses the simulate request format for cosmos-sdk@0.43+
     *      Thus, may throw an error if the chain is below cosmos-sdk@0.43
     *      And, for simplicity, doesn't set the public key to tx bytes.
     *      Thus, the gas estimated doesn't include the tx bytes size of public key.
     *
     * @param msgs
     * @param fee
     * @param memo
     */
    simulateTx(msgs: Any[], fee: Omit<StdFee, "gas">, memo?: string): Promise<{
        gasUsed: number;
    }>;
    makeTx(type: string | "unknown", msgs: ProtoMsgsOrWithAminoMsgs | (() => Promise<ProtoMsgsOrWithAminoMsgs>), preOnTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): MakeTxResponse;
    get instance(): AxiosInstance;
    makeIBCTransferTx(channel: {
        portId: string;
        channelId: string;
        counterpartyChainId: string;
    }, amount: string, currency: AppCurrency, recipient: string): MakeTxResponse;
    sendIBCTransferMsg(channel: {
        portId: string;
        channelId: string;
        counterpartyChainId: string;
    }, amount: string, currency: AppCurrency, recipient: string, memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    makeDelegateTx(amount: string, validatorAddress: string): MakeTxResponse;
    /**
     * Send `MsgDelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param validatorAddress
     * @param memo
     * @param onFulfill
     */
    sendDelegateMsg(amount: string, validatorAddress: string, memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    makeUndelegateTx(amount: string, validatorAddress: string): MakeTxResponse;
    /**
     * @deprecated
     * Send `MsgUndelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param validatorAddress
     * @param memo
     * @param onFulfill
     */
    sendUndelegateMsg(amount: string, validatorAddress: string, memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    makeBeginRedelegateTx(amount: string, srcValidatorAddress: string, dstValidatorAddress: string): MakeTxResponse;
    /**
     * @deprecated
     * Send `MsgBeginRedelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param srcValidatorAddress
     * @param dstValidatorAddress
     * @param memo
     * @param onFulfill
     */
    sendBeginRedelegateMsg(amount: string, srcValidatorAddress: string, dstValidatorAddress: string, memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    makeWithdrawDelegationRewardTx(validatorAddresses: string[]): MakeTxResponse;
    /**
     * @deprecated
     */
    sendWithdrawDelegationRewardMsgs(validatorAddresses: string[], memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    makeGovVoteTx(proposalId: string, option: "Yes" | "No" | "Abstain" | "NoWithVeto"): MakeTxResponse;
    /**
     * @deprecated
     */
    sendGovVoteMsg(proposalId: string, option: "Yes" | "No" | "Abstain" | "NoWithVeto", memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<void>;
    protected get queries(): DeepReadonly<QueriesSetBase & CosmosQueries>;
    protected get hasEthereumAddress(): boolean;
}
