import { AccountSetBase, AccountSetBaseSuper, MsgOpt } from "./base";
import { SecretQueries, QueriesSetBase, IQueriesStore } from "../query";
import { ChainGetter, CoinPrimitive } from "../common";
import { StdFee } from "@cosmjs/launchpad";
import { AppCurrency, KeplrSignOptions } from "@keplr-wallet/types";
import { DeepPartial, DeepReadonly, Optional } from "utility-types";
import { CosmosAccount } from "./cosmos";
export interface SecretAccount {
    secret: SecretAccountImpl;
}
export declare const SecretAccount: {
    use(options: {
        msgOptsCreator?: ((chainId: string) => DeepPartial<SecretMsgOpts> | undefined) | undefined;
        queriesStore: IQueriesStore<SecretQueries>;
    }): (base: AccountSetBaseSuper & CosmosAccount, chainGetter: ChainGetter, chainId: string) => SecretAccount;
};
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
export interface SecretMsgOpts {
    readonly send: {
        readonly secret20: Pick<MsgOpt, "gas">;
    };
    readonly createSecret20ViewingKey: Pick<MsgOpt, "gas">;
    readonly executeSecretWasm: Pick<MsgOpt, "type">;
}
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
export declare const defaultSecretMsgOpts: SecretMsgOpts;
export declare class SecretAccountImpl {
    protected readonly base: AccountSetBase & CosmosAccount;
    protected readonly chainGetter: ChainGetter;
    protected readonly chainId: string;
    protected readonly queriesStore: IQueriesStore<SecretQueries>;
    protected readonly _msgOpts: SecretMsgOpts;
    constructor(base: AccountSetBase & CosmosAccount, chainGetter: ChainGetter, chainId: string, queriesStore: IQueriesStore<SecretQueries>, _msgOpts: SecretMsgOpts);
    /**
     * @deprecated Predict gas through simulation rather than using a fixed gas.
     */
    get msgOpts(): SecretMsgOpts;
    protected processMakeSendTokenTx(amount: string, currency: AppCurrency, recipient: string): import("./types").MakeTxResponse | undefined;
    /**
     * @deprecated
     */
    protected processSendToken(amount: string, currency: AppCurrency, recipient: string, memo: string, stdFee: Partial<StdFee>, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<boolean>;
    createSecret20ViewingKey(contractAddress: string, memo?: string, stdFee?: Partial<StdFee>, signOptions?: KeplrSignOptions, onFulfill?: (tx: any, viewingKey: string) => void): Promise<void>;
    makeExecuteSecretContractTx(type: "unknown" | "send" | "createSecret20ViewingKey" | "executeSecretWasm" | undefined, contractAddress: string, obj: object, sentFunds: CoinPrimitive[], preOnTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): import("./types").MakeTxResponse;
    /**
     * @deprecated
     */
    sendExecuteSecretContractMsg(type: "unknown" | "send" | "createSecret20ViewingKey" | "executeSecretWasm" | undefined, contractAddress: string, obj: object, sentFunds: CoinPrimitive[], memo: string | undefined, stdFee: Optional<StdFee, "amount">, signOptions?: KeplrSignOptions, onTxEvents?: ((tx: any) => void) | {
        onBroadcasted?: (txHash: Uint8Array) => void;
        onFulfill?: (tx: any) => void;
    }): Promise<Uint8Array>;
    protected encryptSecretContractMsg(contractAddress: string, obj: object): Promise<Uint8Array>;
    protected get queries(): DeepReadonly<QueriesSetBase & SecretQueries>;
}
