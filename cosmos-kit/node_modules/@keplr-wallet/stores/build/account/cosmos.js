"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosAccountImpl = exports.defaultCosmosMsgOpts = exports.CosmosAccount = void 0;
const base_1 = require("./base");
const launchpad_1 = require("@cosmjs/launchpad");
const common_1 = require("@keplr-wallet/common");
const unit_1 = require("@keplr-wallet/unit");
const tx_1 = require("@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx");
const signing_1 = require("@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing");
const keys_1 = require("@keplr-wallet/proto-types/cosmos/crypto/secp256k1/keys");
const tx_2 = require("@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx");
const tx_3 = require("@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx");
const tx_4 = require("@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx");
const tx_5 = require("@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx");
const tx_6 = require("@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx");
const gov_1 = require("@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov");
const cosmos_1 = require("@keplr-wallet/cosmos");
const types_1 = require("../query/cosmos/staking/types");
const axios_1 = __importDefault(require("axios"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const address_1 = require("@ethersproject/address");
const buffer_1 = require("buffer/");
const utils_1 = require("./utils");
exports.CosmosAccount = {
    use(options) {
        return (base, chainGetter, chainId) => {
            const msgOptsFromCreator = options.msgOptsCreator
                ? options.msgOptsCreator(chainId)
                : undefined;
            return {
                cosmos: new CosmosAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultCosmosMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {}), options),
            };
        };
    },
};
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
exports.defaultCosmosMsgOpts = {
    send: {
        native: {
            type: "cosmos-sdk/MsgSend",
            gas: 80000,
        },
    },
    ibcTransfer: {
        type: "cosmos-sdk/MsgTransfer",
        gas: 450000,
    },
    delegate: {
        type: "cosmos-sdk/MsgDelegate",
        gas: 250000,
    },
    undelegate: {
        type: "cosmos-sdk/MsgUndelegate",
        gas: 250000,
    },
    redelegate: {
        type: "cosmos-sdk/MsgBeginRedelegate",
        gas: 250000,
    },
    // The gas multiplication per rewards.
    withdrawRewards: {
        type: "cosmos-sdk/MsgWithdrawDelegationReward",
        gas: 140000,
    },
    govVote: {
        type: "cosmos-sdk/MsgVote",
        gas: 250000,
    },
};
class CosmosAccountImpl {
    constructor(base, chainGetter, chainId, queriesStore, _msgOpts, txOpts) {
        this.base = base;
        this.chainGetter = chainGetter;
        this.chainId = chainId;
        this.queriesStore = queriesStore;
        this._msgOpts = _msgOpts;
        this.txOpts = txOpts;
        this.broadcastMode = "sync";
        this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));
        this.base.registerSendTokenFn(this.processSendToken.bind(this));
    }
    /**
     * @deprecated Predict gas through simulation rather than using a fixed gas.
     */
    get msgOpts() {
        return this._msgOpts;
    }
    processMakeSendTokenTx(amount, currency, recipient) {
        const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
        const hexAdjustedRecipient = (recipient) => {
            const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config
                .bech32PrefixAccAddr;
            if (this.hasEthereumAddress && recipient.startsWith("0x")) {
                // Validate hex address
                if (!address_1.isAddress(recipient)) {
                    throw new Error("Invalid hex address");
                }
                const buf = buffer_1.Buffer.from(recipient.replace("0x", "").toLowerCase(), "hex");
                return new cosmos_1.Bech32Address(buf).toBech32(bech32prefix);
            }
            return recipient;
        };
        if (denomHelper.type === "native") {
            const actualAmount = (() => {
                let dec = new unit_1.Dec(amount);
                dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                return dec.truncate().toString();
            })();
            recipient = hexAdjustedRecipient(recipient);
            cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);
            const msg = {
                type: this.msgOpts.send.native.type,
                value: {
                    from_address: this.base.bech32Address,
                    to_address: recipient,
                    amount: [
                        {
                            denom: currency.coinMinimalDenom,
                            amount: actualAmount,
                        },
                    ],
                },
            };
            return this.makeTx("send", {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                        value: tx_2.MsgSend.encode({
                            fromAddress: msg.value.from_address,
                            toAddress: msg.value.to_address,
                            amount: msg.value.amount,
                        }).finish(),
                    },
                ],
            }, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to send token, refresh the balance.
                    const queryBalance = this.queries.queryBalances
                        .getQueryBech32Address(this.base.bech32Address)
                        .balances.find((bal) => {
                        return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                    });
                    if (queryBalance) {
                        queryBalance.fetch();
                    }
                }
            });
        }
    }
    /**
     * @deprecated
     */
    processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
            const hexAdjustedRecipient = (recipient) => {
                const bech32prefix = this.chainGetter.getChain(this.chainId).bech32Config
                    .bech32PrefixAccAddr;
                if (this.hasEthereumAddress && recipient.startsWith("0x")) {
                    // Validate hex address
                    if (!address_1.isAddress(recipient)) {
                        throw new Error("Invalid hex address");
                    }
                    const buf = buffer_1.Buffer.from(recipient.replace("0x", "").toLowerCase(), "hex");
                    return new cosmos_1.Bech32Address(buf).toBech32(bech32prefix);
                }
                return recipient;
            };
            switch (denomHelper.type) {
                case "native":
                    const actualAmount = (() => {
                        let dec = new unit_1.Dec(amount);
                        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                        return dec.truncate().toString();
                    })();
                    const msg = {
                        type: this.msgOpts.send.native.type,
                        value: {
                            from_address: this.base.bech32Address,
                            to_address: hexAdjustedRecipient(recipient),
                            amount: [
                                {
                                    denom: currency.coinMinimalDenom,
                                    amount: actualAmount,
                                },
                            ],
                        },
                    };
                    yield this.sendMsgs("send", {
                        aminoMsgs: [msg],
                        protoMsgs: [
                            {
                                typeUrl: "/cosmos.bank.v1beta1.MsgSend",
                                value: tx_2.MsgSend.encode({
                                    fromAddress: msg.value.from_address,
                                    toAddress: msg.value.to_address,
                                    amount: msg.value.amount,
                                }).finish(),
                            },
                        ],
                    }, memo, {
                        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.native.gas.toString(),
                    }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                        if (tx.code == null || tx.code === 0) {
                            // After succeeding to send token, refresh the balance.
                            const queryBalance = this.queries.queryBalances
                                .getQueryBech32Address(this.base.bech32Address)
                                .balances.find((bal) => {
                                return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                            });
                            if (queryBalance) {
                                queryBalance.fetch();
                            }
                        }
                    }));
                    return true;
            }
            return false;
        });
    }
    sendMsgs(type, msgs, memo = "", fee, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.base.setTxTypeInProgress(type);
            let txHash;
            let signDoc;
            try {
                if (typeof msgs === "function") {
                    msgs = yield msgs();
                }
                const result = yield this.broadcastMsgs(msgs, fee, memo, signOptions, this.broadcastMode);
                txHash = result.txHash;
                signDoc = result.signDoc;
            }
            catch (e) {
                this.base.setTxTypeInProgress("");
                if ((_a = this.txOpts.preTxEvents) === null || _a === void 0 ? void 0 : _a.onBroadcastFailed) {
                    this.txOpts.preTxEvents.onBroadcastFailed(this.chainId, e);
                }
                if (onTxEvents &&
                    "onBroadcastFailed" in onTxEvents &&
                    onTxEvents.onBroadcastFailed) {
                    onTxEvents.onBroadcastFailed(e);
                }
                throw e;
            }
            let onBroadcasted;
            let onFulfill;
            if (onTxEvents) {
                if (typeof onTxEvents === "function") {
                    onFulfill = onTxEvents;
                }
                else {
                    onBroadcasted = onTxEvents.onBroadcasted;
                    onFulfill = onTxEvents.onFulfill;
                }
            }
            if ((_b = this.txOpts.preTxEvents) === null || _b === void 0 ? void 0 : _b.onBroadcasted) {
                this.txOpts.preTxEvents.onBroadcasted(this.chainId, txHash);
            }
            if (onBroadcasted) {
                onBroadcasted(txHash);
            }
            const txTracer = new cosmos_1.TendermintTxTracer(this.chainGetter.getChain(this.chainId).rpc, "/websocket", {
                wsObject: this.txOpts.wsObject,
            });
            txTracer.traceTx(txHash).then((tx) => {
                var _a;
                txTracer.close();
                this.base.setTxTypeInProgress("");
                // After sending tx, the balances is probably changed due to the fee.
                for (const feeAmount of signDoc.fee.amount) {
                    const bal = this.queries.queryBalances
                        .getQueryBech32Address(this.base.bech32Address)
                        .balances.find((bal) => bal.currency.coinMinimalDenom === feeAmount.denom);
                    if (bal) {
                        bal.fetch();
                    }
                }
                // Always add the tx hash data.
                if (tx && !tx.hash) {
                    tx.hash = buffer_1.Buffer.from(txHash).toString("hex");
                }
                if ((_a = this.txOpts.preTxEvents) === null || _a === void 0 ? void 0 : _a.onFulfill) {
                    this.txOpts.preTxEvents.onFulfill(this.chainId, tx);
                }
                if (onFulfill) {
                    onFulfill(tx);
                }
            });
        });
    }
    // Return the tx hash.
    broadcastMsgs(msgs, fee, memo = "", signOptions, mode = "async") {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.base.walletStatus !== base_1.WalletStatus.Loaded) {
                throw new Error(`Wallet is not loaded: ${this.base.walletStatus}`);
            }
            const aminoMsgs = msgs.aminoMsgs;
            const protoMsgs = msgs.protoMsgs;
            // TODO: Make proto sign doc if `aminoMsgs` is empty or null
            if (aminoMsgs.length === 0 || protoMsgs.length === 0) {
                throw new Error("There is no msg to send");
            }
            if (aminoMsgs.length !== protoMsgs.length) {
                throw new Error("The length of aminoMsgs and protoMsgs are different");
            }
            const account = yield cosmos_1.BaseAccount.fetchFromRest(this.instance, this.base.bech32Address, true);
            const useEthereumSign = (_a = this.chainGetter
                .getChain(this.chainId)
                .features) === null || _a === void 0 ? void 0 : _a.includes("eth-key-sign");
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const keplr = (yield this.base.getKeplr());
            const signDoc = launchpad_1.makeSignDoc(aminoMsgs, fee, this.chainId, common_1.escapeHTML(memo), account.getAccountNumber().toString(), account.getSequence().toString());
            const signResponse = yield keplr.signAmino(this.chainId, this.base.bech32Address, signDoc, signOptions);
            const signedTx = tx_1.TxRaw.encode({
                bodyBytes: tx_1.TxBody.encode(tx_1.TxBody.fromPartial({
                    messages: protoMsgs,
                    memo: signResponse.signed.memo,
                })).finish(),
                authInfoBytes: tx_1.AuthInfo.encode({
                    signerInfos: [
                        {
                            publicKey: {
                                typeUrl: useEthereumSign
                                    ? "/ethermint.crypto.v1.ethsecp256k1.PubKey"
                                    : "/cosmos.crypto.secp256k1.PubKey",
                                value: keys_1.PubKey.encode({
                                    key: buffer_1.Buffer.from(signResponse.signature.pub_key.value, "base64"),
                                }).finish(),
                            },
                            modeInfo: {
                                single: {
                                    mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON,
                                },
                                multi: undefined,
                            },
                            sequence: signResponse.signed.sequence,
                        },
                    ],
                    fee: tx_1.Fee.fromPartial({
                        amount: signResponse.signed.fee.amount,
                        gasLimit: signResponse.signed.fee.gas,
                    }),
                }).finish(),
                signatures: [buffer_1.Buffer.from(signResponse.signature.signature, "base64")],
            }).finish();
            return {
                txHash: yield keplr.sendTx(this.chainId, signedTx, mode),
                signDoc: signResponse.signed,
            };
        });
    }
    /**
     * Simulate tx without making state transition on chain or not waiting the tx committed.
     * Mainly used to estimate the gas needed to process tx.
     * You should multiply arbitrary number (gas adjustment) for gas before sending tx.
     *
     * NOTE: "/cosmos/tx/v1beta1/simulate" returns 400, 500 or (more?) status and error code as a response when tx fails on stimulate.
     *       Currently, non 200~300 status is handled as error, thus error would be thrown.
     *
     * XXX: Uses the simulate request format for cosmos-sdk@0.43+
     *      Thus, may throw an error if the chain is below cosmos-sdk@0.43
     *      And, for simplicity, doesn't set the public key to tx bytes.
     *      Thus, the gas estimated doesn't include the tx bytes size of public key.
     *
     * @param msgs
     * @param fee
     * @param memo
     */
    simulateTx(msgs, fee, memo = "") {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield cosmos_1.BaseAccount.fetchFromRest(this.instance, this.base.bech32Address, true);
            const unsignedTx = tx_1.TxRaw.encode({
                bodyBytes: tx_1.TxBody.encode(tx_1.TxBody.fromPartial({
                    messages: msgs,
                    memo: memo,
                })).finish(),
                authInfoBytes: tx_1.AuthInfo.encode({
                    signerInfos: [
                        tx_1.SignerInfo.fromPartial({
                            // Pub key is ignored.
                            // It is fine to ignore the pub key when simulating tx.
                            // However, the estimated gas would be slightly smaller because tx size doesn't include pub key.
                            modeInfo: {
                                single: {
                                    mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON,
                                },
                                multi: undefined,
                            },
                            sequence: account.getSequence().toString(),
                        }),
                    ],
                    fee: tx_1.Fee.fromPartial({
                        amount: fee.amount.map((amount) => {
                            return { amount: amount.amount, denom: amount.denom };
                        }),
                    }),
                }).finish(),
                // Because of the validation of tx itself, the signature must exist.
                // However, since they do not actually verify the signature, it is okay to use any value.
                signatures: [new Uint8Array(64)],
            }).finish();
            const result = yield this.instance.post("/cosmos/tx/v1beta1/simulate", {
                tx_bytes: buffer_1.Buffer.from(unsignedTx).toString("base64"),
            });
            const gasUsed = parseInt(result.data.gas_info.gas_used);
            if (Number.isNaN(gasUsed)) {
                throw new Error(`Invalid integer gas: ${result.data.gas_info.gas_used}`);
            }
            return {
                gasUsed,
            };
        });
    }
    makeTx(type, msgs, preOnTxEvents) {
        const simulate = (fee = {}, memo = "") => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (typeof msgs === "function") {
                msgs = yield msgs();
            }
            return this.simulateTx(msgs.protoMsgs, {
                amount: (_a = fee.amount) !== null && _a !== void 0 ? _a : [],
            }, memo);
        });
        const sendWithGasPrice = (gasInfo, memo = "", signOptions, onTxEvents) => __awaiter(this, void 0, void 0, function* () {
            if (gasInfo.gas < 0) {
                throw new Error("Gas is zero or negative");
            }
            const fee = {
                gas: gasInfo.gas.toString(),
                amount: gasInfo.gasPrice
                    ? [
                        {
                            denom: gasInfo.gasPrice.denom,
                            amount: gasInfo.gasPrice.amount
                                .mul(new unit_1.Dec(gasInfo.gas))
                                .truncate()
                                .toString(),
                        },
                    ]
                    : [],
            };
            return this.sendMsgs(type, msgs, memo, fee, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents));
        });
        return {
            msgs: () => __awaiter(this, void 0, void 0, function* () {
                if (typeof msgs === "function") {
                    msgs = yield msgs();
                }
                return msgs;
            }),
            simulate,
            simulateAndSend: (feeOptions, memo = "", signOptions, onTxEvents) => __awaiter(this, void 0, void 0, function* () {
                this.base.setTxTypeInProgress(type);
                try {
                    const { gasUsed } = yield simulate({}, memo);
                    if (gasUsed < 0) {
                        throw new Error("Gas estimated is zero or negative");
                    }
                    const gasAdjusted = feeOptions.gasAdjustment * gasUsed;
                    return sendWithGasPrice({
                        gas: gasAdjusted,
                        gasPrice: feeOptions.gasPrice,
                    }, memo, signOptions, onTxEvents);
                }
                catch (e) {
                    this.base.setTxTypeInProgress("");
                    throw e;
                }
            }),
            send: (fee, memo = "", signOptions, onTxEvents) => __awaiter(this, void 0, void 0, function* () {
                return this.sendMsgs(type, msgs, memo, fee, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, preOnTxEvents));
            }),
            sendWithGasPrice,
        };
    }
    get instance() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        return axios_1.default.create(Object.assign({
            baseURL: chainInfo.rest,
        }, chainInfo.restConfig));
    }
    makeIBCTransferTx(channel, amount, currency, recipient) {
        if (new common_1.DenomHelper(currency.coinMinimalDenom).type !== "native") {
            throw new Error("Only native token can be sent via IBC");
        }
        const actualAmount = (() => {
            let dec = new unit_1.Dec(amount);
            dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
            return dec.truncate().toString();
        })();
        const destinationInfo = this.queriesStore.get(channel.counterpartyChainId)
            .cosmos.queryRPCStatus;
        return this.makeTx("ibcTransfer", () => __awaiter(this, void 0, void 0, function* () {
            // Wait until fetching complete.
            yield destinationInfo.waitFreshResponse();
            if (!destinationInfo.network) {
                throw new Error(`Failed to fetch the network chain id of ${channel.counterpartyChainId}`);
            }
            if (cosmos_1.ChainIdHelper.parse(destinationInfo.network).identifier !==
                cosmos_1.ChainIdHelper.parse(channel.counterpartyChainId).identifier) {
                throw new Error(`Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`);
            }
            if (!destinationInfo.latestBlockHeight ||
                destinationInfo.latestBlockHeight.equals(new unit_1.Int("0"))) {
                throw new Error(`Failed to fetch the latest block of ${channel.counterpartyChainId}`);
            }
            const msg = {
                type: this.msgOpts.ibcTransfer.type,
                value: {
                    source_port: channel.portId,
                    source_channel: channel.channelId,
                    token: {
                        denom: currency.coinMinimalDenom,
                        amount: actualAmount,
                    },
                    sender: this.base.bech32Address,
                    receiver: recipient,
                    timeout_height: {
                        revision_number: cosmos_1.ChainIdHelper.parse(destinationInfo.network).version.toString(),
                        // Set the timeout height as the current height + 150.
                        revision_height: destinationInfo.latestBlockHeight
                            .add(new unit_1.Int("150"))
                            .toString(),
                    },
                },
            };
            if (msg.value.timeout_height.revision_number === "0") {
                delete msg.value.timeout_height.revision_number;
            }
            return {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
                        value: tx_3.MsgTransfer.encode(tx_3.MsgTransfer.fromPartial({
                            sourcePort: msg.value.source_port,
                            sourceChannel: msg.value.source_channel,
                            token: msg.value.token,
                            sender: msg.value.sender,
                            receiver: msg.value.receiver,
                            timeoutHeight: {
                                revisionNumber: msg.value.timeout_height.revision_number
                                    ? msg.value.timeout_height.revision_number
                                    : "0",
                                revisionHeight: msg.value.timeout_height.revision_height,
                            },
                        })).finish(),
                    },
                ],
            };
        }), (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to send token, refresh the balance.
                const queryBalance = this.queries.queryBalances
                    .getQueryBech32Address(this.base.bech32Address)
                    .balances.find((bal) => {
                    return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                });
                if (queryBalance) {
                    queryBalance.fetch();
                }
            }
        });
    }
    sendIBCTransferMsg(channel, amount, currency, recipient, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (new common_1.DenomHelper(currency.coinMinimalDenom).type !== "native") {
                throw new Error("Only native token can be sent via IBC");
            }
            const actualAmount = (() => {
                let dec = new unit_1.Dec(amount);
                dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                return dec.truncate().toString();
            })();
            const destinationInfo = this.queriesStore.get(channel.counterpartyChainId)
                .cosmos.queryRPCStatus;
            yield this.sendMsgs("ibcTransfer", () => __awaiter(this, void 0, void 0, function* () {
                // Wait until fetching complete.
                yield destinationInfo.waitFreshResponse();
                if (!destinationInfo.network) {
                    throw new Error(`Failed to fetch the network chain id of ${channel.counterpartyChainId}`);
                }
                if (cosmos_1.ChainIdHelper.parse(destinationInfo.network).identifier !==
                    cosmos_1.ChainIdHelper.parse(channel.counterpartyChainId).identifier) {
                    throw new Error(`Fetched the network chain id is different with counterparty chain id (${destinationInfo.network}, ${channel.counterpartyChainId})`);
                }
                if (!destinationInfo.latestBlockHeight ||
                    destinationInfo.latestBlockHeight.equals(new unit_1.Int("0"))) {
                    throw new Error(`Failed to fetch the latest block of ${channel.counterpartyChainId}`);
                }
                const msg = {
                    type: this.msgOpts.ibcTransfer.type,
                    value: {
                        source_port: channel.portId,
                        source_channel: channel.channelId,
                        token: {
                            denom: currency.coinMinimalDenom,
                            amount: actualAmount,
                        },
                        sender: this.base.bech32Address,
                        receiver: recipient,
                        timeout_height: {
                            revision_number: cosmos_1.ChainIdHelper.parse(destinationInfo.network).version.toString(),
                            // Set the timeout height as the current height + 150.
                            revision_height: destinationInfo.latestBlockHeight
                                .add(new unit_1.Int("150"))
                                .toString(),
                        },
                    },
                };
                if (msg.value.timeout_height.revision_number === "0") {
                    delete msg.value.timeout_height.revision_number;
                }
                return {
                    aminoMsgs: [msg],
                    protoMsgs: [
                        {
                            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
                            value: tx_3.MsgTransfer.encode(tx_3.MsgTransfer.fromPartial({
                                sourcePort: msg.value.source_port,
                                sourceChannel: msg.value.source_channel,
                                token: msg.value.token,
                                sender: msg.value.sender,
                                receiver: msg.value.receiver,
                                timeoutHeight: {
                                    revisionNumber: msg.value.timeout_height.revision_number
                                        ? msg.value.timeout_height.revision_number
                                        : "0",
                                    revisionHeight: msg.value.timeout_height.revision_height,
                                },
                            })).finish(),
                        },
                    ],
                };
            }), memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.ibcTransfer.gas.toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to send token, refresh the balance.
                    const queryBalance = this.queries.queryBalances
                        .getQueryBech32Address(this.base.bech32Address)
                        .balances.find((bal) => {
                        return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                    });
                    if (queryBalance) {
                        queryBalance.fetch();
                    }
                }
            }));
        });
    }
    makeDelegateTx(amount, validatorAddress) {
        cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);
        const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
        let dec = new unit_1.Dec(amount);
        dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
        const msg = {
            type: this.msgOpts.delegate.type,
            value: {
                delegator_address: this.base.bech32Address,
                validator_address: validatorAddress,
                amount: {
                    denom: currency.coinMinimalDenom,
                    amount: dec.truncate().toString(),
                },
            },
        };
        return this.makeTx("delegate", {
            aminoMsgs: [msg],
            protoMsgs: [
                {
                    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                    value: tx_4.MsgDelegate.encode({
                        delegatorAddress: msg.value.delegator_address,
                        validatorAddress: msg.value.validator_address,
                        amount: msg.value.amount,
                    }).finish(),
                },
            ],
        }, (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to delegate, refresh the validators and delegations, rewards.
                this.queries.cosmos.queryValidators
                    .getQueryStatus(types_1.BondStatus.Bonded)
                    .fetch();
                this.queries.cosmos.queryDelegations
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
                this.queries.cosmos.queryRewards
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
            }
        });
    }
    /**
     * Send `MsgDelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param validatorAddress
     * @param memo
     * @param onFulfill
     */
    sendDelegateMsg(amount, validatorAddress, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
            let dec = new unit_1.Dec(amount);
            dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
            const msg = {
                type: this.msgOpts.delegate.type,
                value: {
                    delegator_address: this.base.bech32Address,
                    validator_address: validatorAddress,
                    amount: {
                        denom: currency.coinMinimalDenom,
                        amount: dec.truncate().toString(),
                    },
                },
            };
            yield this.sendMsgs("delegate", {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
                        value: tx_4.MsgDelegate.encode({
                            delegatorAddress: msg.value.delegator_address,
                            validatorAddress: msg.value.validator_address,
                            amount: msg.value.amount,
                        }).finish(),
                    },
                ],
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.delegate.gas.toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to delegate, refresh the validators and delegations, rewards.
                    this.queries.cosmos.queryValidators
                        .getQueryStatus(types_1.BondStatus.Bonded)
                        .fetch();
                    this.queries.cosmos.queryDelegations
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                    this.queries.cosmos.queryRewards
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                }
            }));
        });
    }
    makeUndelegateTx(amount, validatorAddress) {
        cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);
        const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
        let dec = new unit_1.Dec(amount);
        dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
        const msg = {
            type: this.msgOpts.undelegate.type,
            value: {
                delegator_address: this.base.bech32Address,
                validator_address: validatorAddress,
                amount: {
                    denom: currency.coinMinimalDenom,
                    amount: dec.truncate().toString(),
                },
            },
        };
        return this.makeTx("undelegate", {
            aminoMsgs: [msg],
            protoMsgs: [
                {
                    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                    value: tx_4.MsgUndelegate.encode({
                        delegatorAddress: msg.value.delegator_address,
                        validatorAddress: msg.value.validator_address,
                        amount: msg.value.amount,
                    }).finish(),
                },
            ],
        }, (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.
                this.queries.cosmos.queryValidators
                    .getQueryStatus(types_1.BondStatus.Bonded)
                    .fetch();
                this.queries.cosmos.queryDelegations
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
                this.queries.cosmos.queryUnbondingDelegations
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
                this.queries.cosmos.queryRewards
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
            }
        });
    }
    /**
     * @deprecated
     * Send `MsgUndelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param validatorAddress
     * @param memo
     * @param onFulfill
     */
    sendUndelegateMsg(amount, validatorAddress, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
            let dec = new unit_1.Dec(amount);
            dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
            const msg = {
                type: this.msgOpts.undelegate.type,
                value: {
                    delegator_address: this.base.bech32Address,
                    validator_address: validatorAddress,
                    amount: {
                        denom: currency.coinMinimalDenom,
                        amount: dec.truncate().toString(),
                    },
                },
            };
            yield this.sendMsgs("undelegate", {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
                        value: tx_4.MsgUndelegate.encode({
                            delegatorAddress: msg.value.delegator_address,
                            validatorAddress: msg.value.validator_address,
                            amount: msg.value.amount,
                        }).finish(),
                    },
                ],
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.undelegate.gas.toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to unbond, refresh the validators and delegations, unbonding delegations, rewards.
                    this.queries.cosmos.queryValidators
                        .getQueryStatus(types_1.BondStatus.Bonded)
                        .fetch();
                    this.queries.cosmos.queryDelegations
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                    this.queries.cosmos.queryUnbondingDelegations
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                    this.queries.cosmos.queryRewards
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                }
            }));
        });
    }
    makeBeginRedelegateTx(amount, srcValidatorAddress, dstValidatorAddress) {
        cosmos_1.Bech32Address.validate(srcValidatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);
        cosmos_1.Bech32Address.validate(dstValidatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);
        const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
        let dec = new unit_1.Dec(amount);
        dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
        const msg = {
            type: this.msgOpts.redelegate.type,
            value: {
                delegator_address: this.base.bech32Address,
                validator_src_address: srcValidatorAddress,
                validator_dst_address: dstValidatorAddress,
                amount: {
                    denom: currency.coinMinimalDenom,
                    amount: dec.truncate().toString(),
                },
            },
        };
        return this.makeTx("redelegate", {
            aminoMsgs: [msg],
            protoMsgs: [
                {
                    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                    value: tx_4.MsgBeginRedelegate.encode({
                        delegatorAddress: msg.value.delegator_address,
                        validatorSrcAddress: msg.value.validator_src_address,
                        validatorDstAddress: msg.value.validator_dst_address,
                        amount: msg.value.amount,
                    }).finish(),
                },
            ],
        }, (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to redelegate, refresh the validators and delegations, rewards.
                this.queries.cosmos.queryValidators
                    .getQueryStatus(types_1.BondStatus.Bonded)
                    .fetch();
                this.queries.cosmos.queryDelegations
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
                this.queries.cosmos.queryRewards
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
            }
        });
    }
    /**
     * @deprecated
     * Send `MsgBeginRedelegate` msg to the chain.
     * @param amount Decimal number used by humans.
     *               If amount is 0.1 and the stake currenct is uatom, actual amount will be changed to the 100000uatom.
     * @param srcValidatorAddress
     * @param dstValidatorAddress
     * @param memo
     * @param onFulfill
     */
    sendBeginRedelegateMsg(amount, srcValidatorAddress, dstValidatorAddress, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currency = this.chainGetter.getChain(this.chainId).stakeCurrency;
            let dec = new unit_1.Dec(amount);
            dec = dec.mulTruncate(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
            const msg = {
                type: this.msgOpts.redelegate.type,
                value: {
                    delegator_address: this.base.bech32Address,
                    validator_src_address: srcValidatorAddress,
                    validator_dst_address: dstValidatorAddress,
                    amount: {
                        denom: currency.coinMinimalDenom,
                        amount: dec.truncate().toString(),
                    },
                },
            };
            yield this.sendMsgs("redelegate", {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
                        value: tx_4.MsgBeginRedelegate.encode({
                            delegatorAddress: msg.value.delegator_address,
                            validatorSrcAddress: msg.value.validator_src_address,
                            validatorDstAddress: msg.value.validator_dst_address,
                            amount: msg.value.amount,
                        }).finish(),
                    },
                ],
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.redelegate.gas.toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to redelegate, refresh the validators and delegations, rewards.
                    this.queries.cosmos.queryValidators
                        .getQueryStatus(types_1.BondStatus.Bonded)
                        .fetch();
                    this.queries.cosmos.queryDelegations
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                    this.queries.cosmos.queryRewards
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                }
            }));
        });
    }
    makeWithdrawDelegationRewardTx(validatorAddresses) {
        for (const validatorAddress of validatorAddresses) {
            cosmos_1.Bech32Address.validate(validatorAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixValAddr);
        }
        const msgs = validatorAddresses.map((validatorAddress) => {
            return {
                type: this.msgOpts.withdrawRewards.type,
                value: {
                    delegator_address: this.base.bech32Address,
                    validator_address: validatorAddress,
                },
            };
        });
        return this.makeTx("withdrawRewards", {
            aminoMsgs: msgs,
            protoMsgs: msgs.map((msg) => {
                return {
                    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                    value: tx_5.MsgWithdrawDelegatorReward.encode({
                        delegatorAddress: msg.value.delegator_address,
                        validatorAddress: msg.value.validator_address,
                    }).finish(),
                };
            }),
        }, (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to withdraw rewards, refresh rewards.
                this.queries.cosmos.queryRewards
                    .getQueryBech32Address(this.base.bech32Address)
                    .fetch();
            }
        });
    }
    /**
     * @deprecated
     */
    sendWithdrawDelegationRewardMsgs(validatorAddresses, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const msgs = validatorAddresses.map((validatorAddress) => {
                return {
                    type: this.msgOpts.withdrawRewards.type,
                    value: {
                        delegator_address: this.base.bech32Address,
                        validator_address: validatorAddress,
                    },
                };
            });
            yield this.sendMsgs("withdrawRewards", {
                aminoMsgs: msgs,
                protoMsgs: msgs.map((msg) => {
                    return {
                        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
                        value: tx_5.MsgWithdrawDelegatorReward.encode({
                            delegatorAddress: msg.value.delegator_address,
                            validatorAddress: msg.value.validator_address,
                        }).finish(),
                    };
                }),
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : (this.msgOpts.withdrawRewards.gas * validatorAddresses.length).toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to withdraw rewards, refresh rewards.
                    this.queries.cosmos.queryRewards
                        .getQueryBech32Address(this.base.bech32Address)
                        .fetch();
                }
            }));
        });
    }
    makeGovVoteTx(proposalId, option) {
        const voteOption = (() => {
            switch (option) {
                case "Yes":
                    return 1;
                case "Abstain":
                    return 2;
                case "No":
                    return 3;
                case "NoWithVeto":
                    return 4;
            }
        })();
        const msg = {
            type: this.msgOpts.govVote.type,
            value: {
                option: voteOption,
                proposal_id: proposalId,
                voter: this.base.bech32Address,
            },
        };
        return this.makeTx("govVote", {
            aminoMsgs: [msg],
            protoMsgs: [
                {
                    typeUrl: "/cosmos.gov.v1beta1.MsgVote",
                    value: tx_6.MsgVote.encode({
                        proposalId: msg.value.proposal_id,
                        voter: msg.value.voter,
                        option: (() => {
                            switch (msg.value.option) {
                                case 1:
                                    return gov_1.VoteOption.VOTE_OPTION_YES;
                                case 2:
                                    return gov_1.VoteOption.VOTE_OPTION_ABSTAIN;
                                case 3:
                                    return gov_1.VoteOption.VOTE_OPTION_NO;
                                case 4:
                                    return gov_1.VoteOption.VOTE_OPTION_NO_WITH_VETO;
                                default:
                                    return gov_1.VoteOption.VOTE_OPTION_UNSPECIFIED;
                            }
                        })(),
                    }).finish(),
                },
            ],
        }, (tx) => {
            if (tx.code == null || tx.code === 0) {
                // After succeeding to vote, refresh the proposal.
                const proposal = this.queries.cosmos.queryGovernance.proposals.find((proposal) => proposal.id === proposalId);
                if (proposal) {
                    proposal.fetch();
                }
                const vote = this.queries.cosmos.queryProposalVote.getVote(proposalId, this.base.bech32Address);
                vote.fetch();
            }
        });
    }
    /**
     * @deprecated
     */
    sendGovVoteMsg(proposalId, option, memo = "", stdFee = {}, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const voteOption = (() => {
                switch (option) {
                    case "Yes":
                        return 1;
                    case "Abstain":
                        return 2;
                    case "No":
                        return 3;
                    case "NoWithVeto":
                        return 4;
                }
            })();
            const msg = {
                type: this.msgOpts.govVote.type,
                value: {
                    option: voteOption,
                    proposal_id: proposalId,
                    voter: this.base.bech32Address,
                },
            };
            yield this.sendMsgs("govVote", {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmos.gov.v1beta1.MsgVote",
                        value: tx_6.MsgVote.encode({
                            proposalId: msg.value.proposal_id,
                            voter: msg.value.voter,
                            option: (() => {
                                switch (msg.value.option) {
                                    case 1:
                                        return gov_1.VoteOption.VOTE_OPTION_YES;
                                    case 2:
                                        return gov_1.VoteOption.VOTE_OPTION_ABSTAIN;
                                    case 3:
                                        return gov_1.VoteOption.VOTE_OPTION_NO;
                                    case 4:
                                        return gov_1.VoteOption.VOTE_OPTION_NO_WITH_VETO;
                                    default:
                                        return gov_1.VoteOption.VOTE_OPTION_UNSPECIFIED;
                                }
                            })(),
                        }).finish(),
                    },
                ],
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.govVote.gas.toString(),
            }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to vote, refresh the proposal.
                    const proposal = this.queries.cosmos.queryGovernance.proposals.find((proposal) => proposal.id === proposalId);
                    if (proposal) {
                        proposal.fetch();
                    }
                    const vote = this.queries.cosmos.queryProposalVote.getVote(proposalId, this.base.bech32Address);
                    vote.fetch();
                }
            }));
        });
    }
    get queries() {
        return this.queriesStore.get(this.chainId);
    }
    get hasEthereumAddress() {
        var _a, _b;
        return ((_b = (_a = this.chainGetter
            .getChain(this.chainId)
            .features) === null || _a === void 0 ? void 0 : _a.includes("eth-address-gen")) !== null && _b !== void 0 ? _b : false);
    }
}
exports.CosmosAccountImpl = CosmosAccountImpl;
//# sourceMappingURL=cosmos.js.map