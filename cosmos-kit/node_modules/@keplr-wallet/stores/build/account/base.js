"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountSetBaseSuper = exports.AccountSetBase = exports.WalletStatus = void 0;
const mobx_1 = require("mobx");
const common_1 = require("@keplr-wallet/common");
const cosmos_1 = require("@keplr-wallet/cosmos");
var WalletStatus;
(function (WalletStatus) {
    WalletStatus["NotInit"] = "NotInit";
    WalletStatus["Loading"] = "Loading";
    WalletStatus["Loaded"] = "Loaded";
    WalletStatus["NotExist"] = "NotExist";
    WalletStatus["Rejected"] = "Rejected";
})(WalletStatus = exports.WalletStatus || (exports.WalletStatus = {}));
class AccountSetBase {
    constructor(eventListener, chainGetter, chainId, opts) {
        this.eventListener = eventListener;
        this.chainGetter = chainGetter;
        this.chainId = chainId;
        this.opts = opts;
        this._walletVersion = undefined;
        this._walletStatus = WalletStatus.NotInit;
        this._name = "";
        this._bech32Address = "";
        this._txTypeInProgress = "";
        this.hasInited = false;
        this.sendTokenFns = [];
        this.makeSendTokenTxFns = [];
        this.handleInit = () => this.init();
        mobx_1.makeObservable(this);
        this.pubKey = new Uint8Array();
        if (opts.autoInit) {
            this.init();
        }
    }
    getKeplr() {
        return this.opts.getKeplr();
    }
    registerSendTokenFn(fn) {
        this.sendTokenFns.push(fn);
    }
    registerMakeSendTokenFn(fn) {
        this.makeSendTokenTxFns.push(fn);
    }
    enable(keplr, chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainInfo = this.chainGetter.getChain(chainId);
            if (this.opts.suggestChain) {
                if (this.opts.suggestChainFn) {
                    yield this.opts.suggestChainFn(keplr, chainInfo);
                }
                else {
                    yield this.suggestChain(keplr, chainInfo);
                }
            }
            yield keplr.enable(chainId);
        });
    }
    suggestChain(keplr, chainInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            yield keplr.experimentalSuggestChain(chainInfo.raw);
        });
    }
    *init() {
        // If wallet status is not exist, there is no need to try to init because it always fails.
        if (this.walletStatus === WalletStatus.NotExist) {
            return;
        }
        // If the store has never been initialized, add the event listener.
        if (!this.hasInited) {
            // If key store in the keplr extension is changed, this event will be dispatched.
            this.eventListener.addEventListener("keplr_keystorechange", this.handleInit);
        }
        this.hasInited = true;
        // Set wallet status as loading whenever try to init.
        this._walletStatus = WalletStatus.Loading;
        const keplr = yield* common_1.toGenerator(this.getKeplr());
        if (!keplr) {
            this._walletStatus = WalletStatus.NotExist;
            return;
        }
        this._walletVersion = keplr.version;
        try {
            yield this.enable(keplr, this.chainId);
        }
        catch (e) {
            console.log(e);
            this._walletStatus = WalletStatus.Rejected;
            this._rejectionReason = e;
            return;
        }
        try {
            const key = yield* common_1.toGenerator(keplr.getKey(this.chainId));
            this._bech32Address = key.bech32Address;
            this._name = key.name;
            this.pubKey = key.pubKey;
            // Set the wallet status as loaded after getting all necessary infos.
            this._walletStatus = WalletStatus.Loaded;
        }
        catch (e) {
            console.log(e);
            // Caught error loading key
            // Reset properties, and set status to Rejected
            this._bech32Address = "";
            this._name = "";
            this.pubKey = new Uint8Array(0);
            this._walletStatus = WalletStatus.Rejected;
            this._rejectionReason = e;
        }
        if (this._walletStatus !== WalletStatus.Rejected) {
            // Reset previous rejection error message
            this._rejectionReason = undefined;
        }
    }
    disconnect() {
        this._walletStatus = WalletStatus.NotInit;
        this.hasInited = false;
        this.eventListener.removeEventListener("keplr_keystorechange", this.handleInit);
        this._bech32Address = "";
        this._name = "";
        this.pubKey = new Uint8Array(0);
    }
    get walletVersion() {
        return this._walletVersion;
    }
    get isReadyToSendTx() {
        return (this.walletStatus === WalletStatus.Loaded && this.bech32Address !== "");
    }
    /**
     * @deprecated Use `isReadyToSendTx`
     */
    get isReadyToSendMsgs() {
        return (this.walletStatus === WalletStatus.Loaded && this.bech32Address !== "");
    }
    makeSendTokenTx(amount, currency, recipient) {
        for (let i = 0; i < this.makeSendTokenTxFns.length; i++) {
            const fn = this.makeSendTokenTxFns[i];
            const res = fn(amount, currency, recipient);
            if (res) {
                return res;
            }
        }
        const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
        throw new Error(`Unsupported type of currency (${denomHelper.type})`);
    }
    sendToken(amount, currency, recipient, memo = "", stdFee = {}, signOptions, onTxEvents) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < this.sendTokenFns.length; i++) {
                const fn = this.sendTokenFns[i];
                if (yield fn(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents)) {
                    return;
                }
            }
            const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
            throw new Error(`Unsupported type of currency (${denomHelper.type})`);
        });
    }
    get walletStatus() {
        return this._walletStatus;
    }
    get rejectionReason() {
        return this._rejectionReason;
    }
    get name() {
        return this._name;
    }
    get bech32Address() {
        return this._bech32Address;
    }
    /**
     * Returns the tx type in progress waiting to be committed.
     * If there is no tx type in progress, this returns an empty string ("").
     */
    get txTypeInProgress() {
        return this._txTypeInProgress;
    }
    /**
     * @deprecated Use `txTypeInProgress`
     */
    get isSendingMsg() {
        return this.txTypeInProgress;
    }
    get hasEthereumHexAddress() {
        var _a, _b;
        return ((_b = (_a = this.chainGetter
            .getChain(this.chainId)
            .features) === null || _a === void 0 ? void 0 : _a.includes("eth-address-gen")) !== null && _b !== void 0 ? _b : false);
    }
    get ethereumHexAddress() {
        if (this.bech32Address === "") {
            return "";
        }
        return cosmos_1.Bech32Address.fromBech32(this.bech32Address, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr).toHex(true);
    }
}
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_walletVersion", void 0);
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_walletStatus", void 0);
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_rejectionReason", void 0);
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_name", void 0);
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_bech32Address", void 0);
__decorate([
    mobx_1.observable
], AccountSetBase.prototype, "_txTypeInProgress", void 0);
__decorate([
    mobx_1.flow
], AccountSetBase.prototype, "init", null);
__decorate([
    mobx_1.action
], AccountSetBase.prototype, "disconnect", null);
__decorate([
    mobx_1.computed
], AccountSetBase.prototype, "isReadyToSendTx", null);
__decorate([
    mobx_1.computed
], AccountSetBase.prototype, "isReadyToSendMsgs", null);
__decorate([
    mobx_1.computed
], AccountSetBase.prototype, "ethereumHexAddress", null);
exports.AccountSetBase = AccountSetBase;
class AccountSetBaseSuper extends AccountSetBase {
    constructor(...params) {
        super(...params);
        mobx_1.makeObservable(this);
    }
    setTxTypeInProgress(type) {
        this._txTypeInProgress = type;
    }
}
__decorate([
    mobx_1.action
], AccountSetBaseSuper.prototype, "setTxTypeInProgress", null);
exports.AccountSetBaseSuper = AccountSetBaseSuper;
//# sourceMappingURL=base.js.map