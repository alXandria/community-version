"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmwasmAccountImpl = exports.defaultCosmwasmMsgOpts = exports.CosmwasmAccount = void 0;
const common_1 = require("@keplr-wallet/common");
const unit_1 = require("@keplr-wallet/unit");
const tx_1 = require("@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx");
const buffer_1 = require("buffer/");
const deepmerge_1 = __importDefault(require("deepmerge"));
const utils_1 = require("./utils");
const cosmos_1 = require("@keplr-wallet/cosmos");
exports.CosmwasmAccount = {
    use(options) {
        return (base, chainGetter, chainId) => {
            const msgOptsFromCreator = options.msgOptsCreator
                ? options.msgOptsCreator(chainId)
                : undefined;
            return {
                cosmwasm: new CosmwasmAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultCosmwasmMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {})),
            };
        };
    },
};
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
exports.defaultCosmwasmMsgOpts = {
    send: {
        cw20: {
            gas: 150000,
        },
    },
    executeWasm: {
        type: "wasm/MsgExecuteContract",
    },
};
class CosmwasmAccountImpl {
    constructor(base, chainGetter, chainId, queriesStore, _msgOpts) {
        this.base = base;
        this.chainGetter = chainGetter;
        this.chainId = chainId;
        this.queriesStore = queriesStore;
        this._msgOpts = _msgOpts;
        this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));
        this.base.registerSendTokenFn(this.processSendToken.bind(this));
    }
    /**
     * @deprecated Predict gas through simulation rather than using a fixed gas.
     */
    get msgOpts() {
        return this._msgOpts;
    }
    processMakeSendTokenTx(amount, currency, recipient) {
        const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
        if (denomHelper.type === "cw20") {
            const actualAmount = (() => {
                let dec = new unit_1.Dec(amount);
                dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                return dec.truncate().toString();
            })();
            if (!("type" in currency) || currency.type !== "cw20") {
                throw new Error("Currency is not cw20");
            }
            cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);
            return this.makeExecuteContractTx("send", currency.contractAddress, {
                transfer: {
                    recipient: recipient,
                    amount: actualAmount,
                },
            }, [], (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to send token, refresh the balance.
                    const queryBalance = this.queries.queryBalances
                        .getQueryBech32Address(this.base.bech32Address)
                        .balances.find((bal) => {
                        return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                    });
                    if (queryBalance) {
                        queryBalance.fetch();
                    }
                }
            });
        }
    }
    /**
     * @deprecated
     */
    processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
            switch (denomHelper.type) {
                case "cw20":
                    const actualAmount = (() => {
                        let dec = new unit_1.Dec(amount);
                        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                        return dec.truncate().toString();
                    })();
                    if (!("type" in currency) || currency.type !== "cw20") {
                        throw new Error("Currency is not cw20");
                    }
                    yield this.sendExecuteContractMsg("send", currency.contractAddress, {
                        transfer: {
                            recipient: recipient,
                            amount: actualAmount,
                        },
                    }, [], memo, {
                        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.cw20.gas.toString(),
                    }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                        if (tx.code == null || tx.code === 0) {
                            // After succeeding to send token, refresh the balance.
                            const queryBalance = this.queries.queryBalances
                                .getQueryBech32Address(this.base.bech32Address)
                                .balances.find((bal) => {
                                return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                            });
                            if (queryBalance) {
                                queryBalance.fetch();
                            }
                        }
                    }));
                    return true;
            }
            return false;
        });
    }
    makeExecuteContractTx(
    // This arg can be used to override the type of sending tx if needed.
    type = "executeWasm", contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj, funds, preOnTxEvents) {
        cosmos_1.Bech32Address.validate(contractAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);
        const msg = {
            type: this.msgOpts.executeWasm.type,
            value: {
                sender: this.base.bech32Address,
                contract: contractAddress,
                msg: obj,
                funds,
            },
        };
        return this.base.cosmos.makeTx(type, {
            aminoMsgs: [msg],
            protoMsgs: [
                {
                    typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
                    value: tx_1.MsgExecuteContract.encode({
                        sender: msg.value.sender,
                        contract: msg.value.contract,
                        msg: buffer_1.Buffer.from(JSON.stringify(msg.value.msg)),
                        funds: msg.value.funds,
                    }).finish(),
                },
            ],
        }, preOnTxEvents);
    }
    /**
     * @deprecated
     */
    sendExecuteContractMsg(
    // This arg can be used to override the type of sending tx if needed.
    type = "executeWasm", contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj, funds, memo = "", stdFee, signOptions, onTxEvents) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const msg = {
                type: this.msgOpts.executeWasm.type,
                value: {
                    sender: this.base.bech32Address,
                    contract: contractAddress,
                    msg: obj,
                    funds,
                },
            };
            yield this.base.cosmos.sendMsgs(type, {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
                        value: tx_1.MsgExecuteContract.encode({
                            sender: msg.value.sender,
                            contract: msg.value.contract,
                            msg: buffer_1.Buffer.from(JSON.stringify(msg.value.msg)),
                            funds: msg.value.funds,
                        }).finish(),
                    },
                ],
            }, memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: stdFee.gas,
            }, signOptions, onTxEvents);
        });
    }
    get queries() {
        return this.queriesStore.get(this.chainId);
    }
}
exports.CosmwasmAccountImpl = CosmwasmAccountImpl;
//# sourceMappingURL=cosmwasm.js.map