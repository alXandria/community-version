"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretAccountImpl = exports.defaultSecretMsgOpts = exports.SecretAccount = void 0;
const buffer_1 = require("buffer/");
const common_1 = require("@keplr-wallet/common");
const msg_1 = require("@keplr-wallet/proto-types/secret/compute/v1beta1/msg");
const cosmos_1 = require("@keplr-wallet/cosmos");
const unit_1 = require("@keplr-wallet/unit");
const deepmerge_1 = __importDefault(require("deepmerge"));
const utils_1 = require("./utils");
exports.SecretAccount = {
    use(options) {
        return (base, chainGetter, chainId) => {
            const msgOptsFromCreator = options.msgOptsCreator
                ? options.msgOptsCreator(chainId)
                : undefined;
            return {
                secret: new SecretAccountImpl(base, chainGetter, chainId, options.queriesStore, deepmerge_1.default(exports.defaultSecretMsgOpts, msgOptsFromCreator ? msgOptsFromCreator : {})),
            };
        };
    },
};
/**
 * @deprecated Predict gas through simulation rather than using a fixed gas.
 */
exports.defaultSecretMsgOpts = {
    send: {
        secret20: {
            gas: 250000,
        },
    },
    createSecret20ViewingKey: {
        gas: 150000,
    },
    executeSecretWasm: {
        type: "wasm/MsgExecuteContract",
    },
};
class SecretAccountImpl {
    constructor(base, chainGetter, chainId, queriesStore, _msgOpts) {
        this.base = base;
        this.chainGetter = chainGetter;
        this.chainId = chainId;
        this.queriesStore = queriesStore;
        this._msgOpts = _msgOpts;
        this.base.registerMakeSendTokenFn(this.processMakeSendTokenTx.bind(this));
        this.base.registerSendTokenFn(this.processSendToken.bind(this));
    }
    /**
     * @deprecated Predict gas through simulation rather than using a fixed gas.
     */
    get msgOpts() {
        return this._msgOpts;
    }
    processMakeSendTokenTx(amount, currency, recipient) {
        const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
        if (denomHelper.type === "secret20") {
            const actualAmount = (() => {
                let dec = new unit_1.Dec(amount);
                dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                return dec.truncate().toString();
            })();
            if (!("type" in currency) || currency.type !== "secret20") {
                throw new Error("Currency is not secret20");
            }
            cosmos_1.Bech32Address.validate(recipient, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);
            return this.makeExecuteSecretContractTx("send", currency.contractAddress, {
                transfer: {
                    recipient: recipient,
                    amount: actualAmount,
                },
            }, [], (tx) => {
                if (tx.code == null || tx.code === 0) {
                    // After succeeding to send token, refresh the balance.
                    const queryBalance = this.queries.queryBalances
                        .getQueryBech32Address(this.base.bech32Address)
                        .balances.find((bal) => {
                        return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                    });
                    if (queryBalance) {
                        queryBalance.fetch();
                    }
                }
            });
        }
    }
    /**
     * @deprecated
     */
    processSendToken(amount, currency, recipient, memo, stdFee, signOptions, onTxEvents) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const denomHelper = new common_1.DenomHelper(currency.coinMinimalDenom);
            switch (denomHelper.type) {
                case "secret20":
                    const actualAmount = (() => {
                        let dec = new unit_1.Dec(amount);
                        dec = dec.mul(unit_1.DecUtils.getPrecisionDec(currency.coinDecimals));
                        return dec.truncate().toString();
                    })();
                    if (!("type" in currency) || currency.type !== "secret20") {
                        throw new Error("Currency is not secret20");
                    }
                    yield this.sendExecuteSecretContractMsg("send", currency.contractAddress, {
                        transfer: {
                            recipient: recipient,
                            amount: actualAmount,
                        },
                    }, [], memo, {
                        amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                        gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.send.secret20.gas.toString(),
                    }, signOptions, utils_1.txEventsWithPreOnFulfill(onTxEvents, (tx) => {
                        if (tx.code == null || tx.code === 0) {
                            // After succeeding to send token, refresh the balance.
                            const queryBalance = this.queries.queryBalances
                                .getQueryBech32Address(this.base.bech32Address)
                                .balances.find((bal) => {
                                return (bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
                            });
                            if (queryBalance) {
                                queryBalance.fetch();
                            }
                        }
                    }));
                    return true;
            }
            return false;
        });
    }
    createSecret20ViewingKey(contractAddress, memo = "", stdFee = {}, signOptions, onFulfill) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const random = new Uint8Array(32);
            crypto.getRandomValues(random);
            const key = buffer_1.Buffer.from(random).toString("hex");
            yield this.makeExecuteSecretContractTx("createSecret20ViewingKey", contractAddress, {
                set_viewing_key: { key },
            }, []).send({
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: (_b = stdFee.gas) !== null && _b !== void 0 ? _b : this.msgOpts.createSecret20ViewingKey.gas.toString(),
            }, memo, signOptions, (tx) => {
                let viewingKey = "";
                if (tx.code == null || tx.code === 0) {
                    viewingKey = key;
                }
                if (onFulfill) {
                    onFulfill(tx, viewingKey);
                }
            });
            return;
        });
    }
    makeExecuteSecretContractTx(
    // This arg can be used to override the type of sending tx if needed.
    type = "executeSecretWasm", contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj, sentFunds, preOnTxEvents) {
        cosmos_1.Bech32Address.validate(contractAddress, this.chainGetter.getChain(this.chainId).bech32Config.bech32PrefixAccAddr);
        let encryptedMsg;
        return this.base.cosmos.makeTx(type, () => __awaiter(this, void 0, void 0, function* () {
            encryptedMsg = yield this.encryptSecretContractMsg(contractAddress, obj);
            const msg = {
                type: this.msgOpts.executeSecretWasm.type,
                value: {
                    sender: this.base.bech32Address,
                    contract: contractAddress,
                    // callback_code_hash: "",
                    msg: buffer_1.Buffer.from(encryptedMsg).toString("base64"),
                    sent_funds: sentFunds,
                },
            };
            return {
                aminoMsgs: [msg],
                protoMsgs: [
                    {
                        typeUrl: "/secret.compute.v1beta1.MsgExecuteContract",
                        value: msg_1.MsgExecuteContract.encode(msg_1.MsgExecuteContract.fromPartial({
                            sender: cosmos_1.Bech32Address.fromBech32(msg.value.sender).address,
                            contract: cosmos_1.Bech32Address.fromBech32(msg.value.contract)
                                .address,
                            msg: buffer_1.Buffer.from(msg.value.msg, "base64"),
                            sentFunds: msg.value.sent_funds,
                        })).finish(),
                    },
                ],
            };
        }), preOnTxEvents);
    }
    /**
     * @deprecated
     */
    sendExecuteSecretContractMsg(
    // This arg can be used to override the type of sending tx if needed.
    type = "executeSecretWasm", contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj, sentFunds, memo = "", stdFee, signOptions, onTxEvents) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let encryptedMsg;
            yield this.base.cosmos.sendMsgs(type, () => __awaiter(this, void 0, void 0, function* () {
                encryptedMsg = yield this.encryptSecretContractMsg(contractAddress, obj);
                const msg = {
                    type: this.msgOpts.executeSecretWasm.type,
                    value: {
                        sender: this.base.bech32Address,
                        contract: contractAddress,
                        // callback_code_hash: "",
                        msg: buffer_1.Buffer.from(encryptedMsg).toString("base64"),
                        sent_funds: sentFunds,
                    },
                };
                return {
                    aminoMsgs: [msg],
                    protoMsgs: [
                        {
                            typeUrl: "/secret.compute.v1beta1.MsgExecuteContract",
                            value: msg_1.MsgExecuteContract.encode(msg_1.MsgExecuteContract.fromPartial({
                                sender: cosmos_1.Bech32Address.fromBech32(msg.value.sender).address,
                                contract: cosmos_1.Bech32Address.fromBech32(msg.value.contract)
                                    .address,
                                msg: buffer_1.Buffer.from(msg.value.msg, "base64"),
                                sentFunds: msg.value.sent_funds,
                            })).finish(),
                        },
                    ],
                };
            }), memo, {
                amount: (_a = stdFee.amount) !== null && _a !== void 0 ? _a : [],
                gas: stdFee.gas,
            }, signOptions, onTxEvents);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return encryptedMsg;
        });
    }
    encryptSecretContractMsg(contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryContractCodeHashResponse = yield this.queries.secret.querySecretContractCodeHash
                .getQueryContract(contractAddress)
                .waitResponse();
            if (!queryContractCodeHashResponse) {
                throw new Error(`Can't get the code hash of the contract (${contractAddress})`);
            }
            const contractCodeHash = queryContractCodeHashResponse.data.result;
            const keplr = yield this.base.getKeplr();
            if (!keplr) {
                throw new Error("Can't get the Keplr API");
            }
            const enigmaUtils = keplr.getEnigmaUtils(this.chainId);
            return yield enigmaUtils.encrypt(contractCodeHash, obj);
        });
    }
    get queries() {
        return this.queriesStore.get(this.chainId);
    }
}
exports.SecretAccountImpl = SecretAccountImpl;
//# sourceMappingURL=secret.js.map