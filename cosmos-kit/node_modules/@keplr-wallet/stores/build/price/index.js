"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinGeckoPriceStore = void 0;
const common_1 = require("../common");
const axios_1 = __importDefault(require("axios"));
const common_2 = require("@keplr-wallet/common");
const unit_1 = require("@keplr-wallet/unit");
const deepmerge_1 = __importDefault(require("deepmerge"));
const mobx_1 = require("mobx");
class CoinGeckoPriceStore extends common_1.ObservableQuery {
    constructor(kvStore, supportedVsCurrencies, defaultVsCurrency) {
        const instance = axios_1.default.create({
            baseURL: "https://api.coingecko.com/api/v3",
        });
        super(kvStore, instance, "/simple/price");
        this.coinIds = [];
        this.vsCurrencies = [];
        this._defaultVsCurrency = defaultVsCurrency;
        this._supportedVsCurrencies = supportedVsCurrencies;
        mobx_1.makeObservable(this);
        this.restoreDefaultVsCurrency();
    }
    get defaultVsCurrency() {
        return this._defaultVsCurrency;
    }
    setDefaultVsCurrency(defaultVsCurrency) {
        this._defaultVsCurrency = defaultVsCurrency;
        this.saveDefaultVsCurrency();
    }
    *restoreDefaultVsCurrency() {
        const saved = yield* common_2.toGenerator(this.kvStore.get("__default_vs_currency"));
        if (saved) {
            this._defaultVsCurrency = saved;
        }
    }
    saveDefaultVsCurrency() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.kvStore.set("__default_vs_currency", this.defaultVsCurrency);
        });
    }
    get supportedVsCurrencies() {
        return this._supportedVsCurrencies;
    }
    getFiatCurrency(currency) {
        return this._supportedVsCurrencies[currency];
    }
    canFetch() {
        return this.coinIds.length > 0 && this.vsCurrencies.length > 0;
    }
    fetchResponse(cancelToken) {
        const _super = Object.create(null, {
            fetchResponse: { get: () => super.fetchResponse }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const { response, headers } = yield _super.fetchResponse.call(this, cancelToken);
            // Because this store only queries the price of the tokens that have been requested from start,
            // it will remove the prior prices that have not been requested to just return the fetching result.
            // So, to prevent this problem, merge the prior response and current response with retaining the prior response's price.
            return {
                headers,
                response: Object.assign(Object.assign({}, response), {
                    data: deepmerge_1.default(this.response ? this.response.data : {}, response.data),
                }),
            };
        });
    }
    refetch() {
        const url = `/simple/price?ids=${this.coinIds.join(",")}&vs_currencies=${this.vsCurrencies.join(",")}`;
        this.setUrl(url);
    }
    getCacheKey() {
        // Because the uri of the coingecko would be changed according to the coin ids and vsCurrencies.
        // Therefore, just using the uri as the cache key is not useful.
        return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({
            url: "/simple/price",
        })}`;
    }
    getPrice(coinId, vsCurrency) {
        if (!vsCurrency) {
            vsCurrency = this.defaultVsCurrency;
        }
        if (!this.supportedVsCurrencies[vsCurrency]) {
            return undefined;
        }
        if (!this.coinIds.includes(coinId) ||
            !this.vsCurrencies.includes(vsCurrency)) {
            if (!this.coinIds.includes(coinId)) {
                this.coinIds.push(coinId);
            }
            if (!this.vsCurrencies.includes(vsCurrency)) {
                this.vsCurrencies.push(vsCurrency);
            }
            this.refetch();
        }
        if (!this.response) {
            return undefined;
        }
        const coinPrices = this.response.data[coinId];
        if (!coinPrices) {
            return undefined;
        }
        return coinPrices[vsCurrency];
    }
    calculatePrice(coin, vsCurrrency) {
        if (!coin.currency.coinGeckoId) {
            return undefined;
        }
        if (!vsCurrrency) {
            vsCurrrency = this.defaultVsCurrency;
        }
        const fiatCurrency = this.supportedVsCurrencies[vsCurrrency];
        if (!fiatCurrency) {
            return undefined;
        }
        const price = this.getPrice(coin.currency.coinGeckoId, vsCurrrency);
        if (price === undefined) {
            return new unit_1.PricePretty(fiatCurrency, new unit_1.Int(0)).ready(false);
        }
        const dec = coin.toDec();
        const priceDec = new unit_1.Dec(price.toString());
        return new unit_1.PricePretty(fiatCurrency, dec.mul(priceDec));
    }
}
__decorate([
    mobx_1.observable
], CoinGeckoPriceStore.prototype, "_defaultVsCurrency", void 0);
__decorate([
    mobx_1.action
], CoinGeckoPriceStore.prototype, "setDefaultVsCurrency", null);
__decorate([
    mobx_1.flow
], CoinGeckoPriceStore.prototype, "restoreDefaultVsCurrency", null);
exports.CoinGeckoPriceStore = CoinGeckoPriceStore;
//# sourceMappingURL=index.js.map