"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelayMemoryKVStore = exports.MockObservableQuery = void 0;
const index_1 = require("./index");
const common_1 = require("@keplr-wallet/common");
const axios_1 = __importDefault(require("axios"));
const http_1 = __importDefault(require("http"));
const mobx_1 = require("mobx");
class MockObservableQuery extends index_1.ObservableQuery {
    constructor(kvStore) {
        const instance = axios_1.default.create({
            baseURL: "http://127.0.0.1:9234",
        });
        super(kvStore, instance, "/test");
    }
}
exports.MockObservableQuery = MockObservableQuery;
class DelayMemoryKVStore extends common_1.MemoryKVStore {
    constructor(prefix, delay) {
        super(prefix);
        this.delay = delay;
    }
    get(key) {
        const _super = Object.create(null, {
            get: { get: () => super.get }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                setTimeout(resolve, this.delay);
            });
            return _super.get.call(this, key);
        });
    }
    set(key, data) {
        const _super = Object.create(null, {
            set: { get: () => super.set }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve) => {
                setTimeout(resolve, this.delay);
            });
            return _super.set.call(this, key, data);
        });
    }
}
exports.DelayMemoryKVStore = DelayMemoryKVStore;
describe("Test observable query", () => {
    let server;
    let num = 0;
    beforeEach(() => {
        num = 0;
        server = http_1.default.createServer((_, resp) => {
            setTimeout(() => {
                resp.writeHead(200);
                resp.end(num.toString());
                num++;
            }, 200);
        });
        server.listen(9234);
    });
    afterEach(() => {
        if (server) {
            server.close();
            server = undefined;
        }
    });
    it("basic test", () => __awaiter(void 0, void 0, void 0, function* () {
        const basicTestFn = (store) => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            const query = new MockObservableQuery(store);
            // Nothing is being fetched because no value has been observed
            expect(query.isObserved).toBe(false);
            expect(query.isFetching).toBe(false);
            expect(query.error).toBeUndefined();
            expect(query.response).toBeUndefined();
            const disposer = mobx_1.autorun(() => {
                // This makes the response observed. Thus, fetching starts.
                if (query.response) {
                    expect(query.response.data).toBe(0);
                    disposer();
                }
            }, {
                onError: (e) => {
                    throw e;
                },
            });
            // Above code make query starts, but the response not yet fetched
            expect(query.isObserved).toBe(true);
            expect(query.isFetching).toBe(true);
            expect(query.error).toBeUndefined();
            expect(query.response).toBeUndefined();
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            expect(query.isObserved).toBe(false);
            expect(query.isFetching).toBe(false);
            expect(query.error).toBeUndefined();
            expect(query.response).not.toBeUndefined();
            expect((_a = query.response) === null || _a === void 0 ? void 0 : _a.data).toBe(0);
            yield query.waitResponse();
            expect((_b = query.response) === null || _b === void 0 ? void 0 : _b.data).toBe(0);
            yield query.waitFreshResponse();
            expect((_c = query.response) === null || _c === void 0 ? void 0 : _c.data).toBe(1);
        });
        const memStore = new DelayMemoryKVStore("test", 1);
        yield basicTestFn(memStore);
        num = 0;
        // The kvstore below has a delay of 50 seconds.
        // This is definitely slower than the query.
        // Even if the kvstore performs worse than the query, it should handle it well.
        const delayMemStore = new DelayMemoryKVStore("test", 50000);
        yield basicTestFn(delayMemStore);
    }));
});
//# sourceMappingURL=query.spec.js.map