"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryMap = exports.ObservableQuery = exports.ObservableQueryBase = exports.DeferInitialQueryController = exports.defaultOptions = void 0;
const mobx_1 = require("mobx");
const axios_1 = __importDefault(require("axios"));
const common_1 = require("@keplr-wallet/common");
const map_1 = require("../map");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
exports.defaultOptions = {
    cacheMaxAge: Number.MAX_VALUE,
    fetchingInterval: 0,
};
class DeferInitialQueryController {
    constructor() {
        this._isReady = false;
    }
    ready() {
        this._isReady = true;
    }
    wait() {
        if (this.isReady) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (this.isReady) {
                    resolve();
                    if (disposer) {
                        disposer();
                    }
                }
            });
        });
    }
    get isReady() {
        return this._isReady;
    }
}
__decorate([
    mobx_1.observable
], DeferInitialQueryController.prototype, "_isReady", void 0);
__decorate([
    mobx_1.action
], DeferInitialQueryController.prototype, "ready", null);
exports.DeferInitialQueryController = DeferInitialQueryController;
/**
 * Base of the observable query classes.
 * This recommends to use the Axios to query the response.
 */
class ObservableQueryBase {
    constructor(instance, options) {
        // Just use the oberable ref because the response is immutable and not directly adjusted.
        this._response = undefined;
        this._isFetching = false;
        this._error = undefined;
        this._isStarted = false;
        this.observedCount = 0;
        // intervalId can be number or NodeJS's Timout object according to the environment.
        // If environment is browser, intervalId should be number.
        // If environment is NodeJS, intervalId should be NodeJS.Timeout.
        this.intervalId = undefined;
        this.becomeObserved = () => {
            if (this.observedCount === 0) {
                this.start();
            }
            this.observedCount++;
        };
        this.becomeUnobserved = () => {
            this.observedCount--;
            if (this.observedCount === 0) {
                this.stop();
            }
        };
        this.intervalFetch = () => {
            if (!this.isFetching) {
                this.fetch();
            }
        };
        this.options = Object.assign(Object.assign({}, options), exports.defaultOptions);
        this._instance = instance;
        mobx_1.makeObservable(this);
        mobx_1.onBecomeObserved(this, "_response", this.becomeObserved);
        mobx_1.onBecomeObserved(this, "_isFetching", this.becomeObserved);
        mobx_1.onBecomeObserved(this, "_error", this.becomeObserved);
        mobx_1.onBecomeUnobserved(this, "_response", this.becomeUnobserved);
        mobx_1.onBecomeUnobserved(this, "_isFetching", this.becomeUnobserved);
        mobx_1.onBecomeUnobserved(this, "_error", this.becomeUnobserved);
    }
    static guessResponseTruncated(headers, data) {
        return (headers &&
            typeof headers["content-type"] === "string" &&
            headers["content-type"].startsWith("application/json") &&
            data.startsWith("{"));
    }
    get isObserved() {
        return this.observedCount > 0;
    }
    start() {
        if (!this._isStarted) {
            this._isStarted = true;
            this.onStart();
        }
    }
    stop() {
        if (this._isStarted) {
            this.onStop();
            this._isStarted = false;
        }
    }
    get isStarted() {
        return this._isStarted;
    }
    onStart() {
        this.fetch();
        if (this.options.fetchingInterval > 0) {
            this.intervalId = setInterval(this.intervalFetch, this.options.fetchingInterval);
        }
    }
    onStop() {
        this.cancel();
        if (this.intervalId != null) {
            clearInterval(this.intervalId);
        }
    }
    canFetch() {
        return true;
    }
    get isFetching() {
        return this._isFetching;
    }
    // Return the instance.
    // You can memorize this by using @computed if you need to override this.
    // NOTE: If this getter returns the different instance with previous instance.
    // It will be used in the latter fetching.
    get instance() {
        return this._instance;
    }
    *fetch() {
        // If not started, do nothing.
        if (!this.isStarted) {
            return;
        }
        if (ObservableQueryBase.experimentalDeferInitialQueryController &&
            !ObservableQueryBase.experimentalDeferInitialQueryController.isReady) {
            this._isFetching = true;
            yield ObservableQueryBase.experimentalDeferInitialQueryController.wait();
        }
        if (!this.canFetch()) {
            return;
        }
        // If response is fetching, cancel the previous query.
        if (this.isFetching) {
            this.cancel();
        }
        this._isFetching = true;
        // If there is no existing response, try to load saved reponse.
        if (!this._response) {
            // When first load, try to load the last response from disk.
            // To improve performance, don't wait the loading to proceed.
            // Use the last saved response if the last saved response exists and the current response hasn't been set yet.
            this.loadStaledResponse().then((staledResponse) => {
                if (staledResponse && !this._response) {
                    if (staledResponse.timestamp >
                        Date.now() - this.options.cacheMaxAge) {
                        this.setResponse(staledResponse);
                    }
                }
            });
        }
        else {
            // Make the existing response as staled.
            this.setResponse(Object.assign(Object.assign({}, this._response), { staled: true }));
        }
        this.cancelToken = axios_1.default.CancelToken.source();
        try {
            let { response, headers } = yield* common_1.toGenerator(this.fetchResponse(this.cancelToken.token));
            if (response.data &&
                typeof response.data === "string" &&
                (response.data.startsWith("stream was reset:") ||
                    ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data) ||
                    ObservableQuery.guessResponseTruncated(headers, response.data))) {
                // In some devices, it is a http ok code, but a strange response is sometimes returned.
                // It's not that they can't query at all, it seems that they get weird response from time to time.
                // These causes are not clear.
                // To solve this problem, if this problem occurs, try the query again, and if that fails, an error is raised.
                // https://github.com/chainapsis/keplr-wallet/issues/275
                // https://github.com/chainapsis/keplr-wallet/issues/278
                // https://github.com/chainapsis/keplr-wallet/issues/318
                if (this.cancelToken && this.cancelToken.token.reason) {
                    // In this case, it is assumed that it is caused by cancel() and do nothing.
                    return;
                }
                console.log("There is an unknown problem to the response. Request one more time.");
                // Try to query again.
                const refetched = yield* common_1.toGenerator(this.fetchResponse(this.cancelToken.token));
                response = refetched.response;
                headers = refetched.headers;
                if (response.data && typeof response.data === "string") {
                    if (response.data.startsWith("stream was reset:") ||
                        ObservableQuery.suspectedResponseDatasWithInvalidValue.includes(response.data)) {
                        throw new Error(response.data);
                    }
                    if (ObservableQuery.guessResponseTruncated(headers, response.data)) {
                        throw new Error("The response data seems to be truncated");
                    }
                }
            }
            this.setResponse(response);
            // Clear the error if fetching succeeds.
            this.setError(undefined);
            // Should not wait.
            this.saveResponse(response);
        }
        catch (e) {
            // If canceld, do nothing.
            if (axios_1.default.isCancel(e)) {
                return;
            }
            // If error is from Axios, and get response.
            if (e.response) {
                const error = {
                    status: e.response.status,
                    statusText: e.response.statusText,
                    message: e.response.statusText,
                    data: e.response.data,
                };
                this.setError(error);
            }
            else if (e.request) {
                // if can't get the response.
                const error = {
                    status: 0,
                    statusText: "Failed to get response",
                    message: "Failed to get response",
                };
                this.setError(error);
            }
            else {
                const error = {
                    status: 0,
                    statusText: e.message,
                    message: e.message,
                    data: e,
                };
                this.setError(error);
            }
        }
        finally {
            this._isFetching = false;
            this.cancelToken = undefined;
        }
    }
    get response() {
        return this._response;
    }
    get error() {
        return this._error;
    }
    setResponse(response) {
        this._response = response;
    }
    setError(error) {
        this._error = error;
    }
    cancel() {
        if (this.cancelToken) {
            this.cancelToken.cancel();
        }
    }
    /**
     * Wait the response and return the response without considering it is staled or fresh.
     */
    waitResponse() {
        if (!this.isFetching) {
            return Promise.resolve(this.response);
        }
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (!this.isFetching) {
                    resolve(this.response);
                    if (disposer) {
                        disposer();
                    }
                }
            });
        });
    }
    /**
     * Wait the response and return the response until it is fetched.
     */
    waitFreshResponse() {
        let onceCoerce = false;
        // Make sure that the fetching is tracked to force to be fetched.
        const reactionDisposer = mobx_1.reaction(() => this.isFetching, () => {
            if (!onceCoerce) {
                if (!this.isFetching) {
                    this.fetch();
                }
                onceCoerce = true;
            }
        }, {
            fireImmediately: true,
        });
        return new Promise((resolve) => {
            const disposer = mobx_1.autorun(() => {
                if (!this.isFetching) {
                    resolve(this.response);
                    if (reactionDisposer) {
                        reactionDisposer();
                    }
                    if (disposer) {
                        disposer();
                    }
                }
            });
        });
    }
}
/**
 * Allows to decide when to start the first query.
 *
 * This is a temporarily added feature to implement custom rpc/lcd feature in keplr extension or mobile.
 * Because custom rpc/lcd are handled in the background process and the front-end cannot synchronously get those values,
 * Rather than not showing the UI to the user during the delay, the UI is shown and the start of the query is delayed immediately after getting those values.
 *
 * XXX: Having a global field for this feature doesn't seem desirable in the long run.
 *      Unless it's a keplr extension or mobile, you don't need to care about this field.
 *      This field will soon be removed and can be replaced by other implementation.
 *
 */
ObservableQueryBase.experimentalDeferInitialQueryController = undefined;
ObservableQueryBase.suspectedResponseDatasWithInvalidValue = [
    "The network connection was lost.",
    "The request timed out.",
];
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_response", void 0);
__decorate([
    mobx_1.observable
], ObservableQueryBase.prototype, "_isFetching", void 0);
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_error", void 0);
__decorate([
    mobx_1.observable
], ObservableQueryBase.prototype, "_isStarted", void 0);
__decorate([
    mobx_1.observable.ref
], ObservableQueryBase.prototype, "_instance", void 0);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "start", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "stop", null);
__decorate([
    mobx_1.computed
], ObservableQueryBase.prototype, "instance", null);
__decorate([
    mobx_1.flow
], ObservableQueryBase.prototype, "fetch", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "setResponse", null);
__decorate([
    mobx_1.action
], ObservableQueryBase.prototype, "setError", null);
exports.ObservableQueryBase = ObservableQueryBase;
/**
 * ObservableQuery defines the event class to query the result from endpoint.
 * This supports the stale state if previous query exists.
 */
class ObservableQuery extends ObservableQueryBase {
    constructor(kvStore, instance, url, options = {}) {
        super(instance, options);
        this.kvStore = kvStore;
        this._url = "";
        this.refreshHandler = (data) => {
            const ifError = data === null || data === void 0 ? void 0 : data.ifError;
            if (ifError) {
                if (this.error) {
                    this.fetch();
                }
            }
            else {
                this.fetch();
            }
        };
        mobx_1.makeObservable(this);
        this.setUrl(url);
    }
    static refreshAllObserved() {
        ObservableQuery.eventListener.emit("refresh");
    }
    static refreshAllObservedIfError() {
        ObservableQuery.eventListener.emit("refresh", {
            ifError: true,
        });
    }
    onStart() {
        super.onStart();
        ObservableQuery.eventListener.addListener("refresh", this.refreshHandler);
    }
    onStop() {
        super.onStop();
        ObservableQuery.eventListener.addListener("refresh", this.refreshHandler);
    }
    get url() {
        return this._url;
    }
    setUrl(url) {
        if (this._url !== url) {
            this._url = url;
            this.fetch();
        }
    }
    fetchResponse(cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.instance.get(this.url, {
                cancelToken,
            });
            return {
                headers: result.headers,
                response: {
                    data: result.data,
                    status: result.status,
                    staled: false,
                    timestamp: Date.now(),
                },
            };
        });
    }
    getCacheKey() {
        return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({
            url: this.url,
        })}`;
    }
    saveResponse(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getCacheKey();
            yield this.kvStore.set(key, response);
        });
    }
    loadStaledResponse() {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getCacheKey();
            const response = yield this.kvStore.get(key);
            if (response) {
                return Object.assign(Object.assign({}, response), { staled: true });
            }
            return undefined;
        });
    }
}
ObservableQuery.eventListener = new eventemitter3_1.default();
__decorate([
    mobx_1.observable
], ObservableQuery.prototype, "_url", void 0);
__decorate([
    mobx_1.action
], ObservableQuery.prototype, "setUrl", null);
exports.ObservableQuery = ObservableQuery;
class ObservableQueryMap extends map_1.HasMapStore {
    constructor(creater) {
        super(creater);
    }
}
exports.ObservableQueryMap = ObservableQueryMap;
__exportStar(require("./json-rpc"), exports);
//# sourceMappingURL=index.js.map