import { AxiosInstance, CancelToken } from "axios";
import { KVStore } from "@keplr-wallet/common";
import { DeepReadonly } from "utility-types";
import { HasMapStore } from "../map";
import EventEmitter from "eventemitter3";
export declare type QueryOptions = {
    cacheMaxAge: number;
    fetchingInterval: number;
};
export declare const defaultOptions: QueryOptions;
export declare type QueryError<E> = {
    status: number;
    statusText: string;
    message: string;
    data?: E;
};
export declare type QueryResponse<T> = {
    status: number;
    data: T;
    staled: boolean;
    timestamp: number;
};
export declare class DeferInitialQueryController {
    protected _isReady: boolean;
    ready(): void;
    wait(): Promise<void>;
    get isReady(): boolean;
}
/**
 * Base of the observable query classes.
 * This recommends to use the Axios to query the response.
 */
export declare abstract class ObservableQueryBase<T = unknown, E = unknown> {
    /**
     * Allows to decide when to start the first query.
     *
     * This is a temporarily added feature to implement custom rpc/lcd feature in keplr extension or mobile.
     * Because custom rpc/lcd are handled in the background process and the front-end cannot synchronously get those values,
     * Rather than not showing the UI to the user during the delay, the UI is shown and the start of the query is delayed immediately after getting those values.
     *
     * XXX: Having a global field for this feature doesn't seem desirable in the long run.
     *      Unless it's a keplr extension or mobile, you don't need to care about this field.
     *      This field will soon be removed and can be replaced by other implementation.
     *
     */
    static experimentalDeferInitialQueryController: DeferInitialQueryController | undefined;
    protected static suspectedResponseDatasWithInvalidValue: string[];
    protected static guessResponseTruncated(headers: any, data: string): boolean;
    protected options: QueryOptions;
    private _response?;
    protected _isFetching: boolean;
    private _error?;
    private _isStarted;
    private cancelToken?;
    private observedCount;
    private intervalId;
    protected _instance: AxiosInstance;
    protected constructor(instance: AxiosInstance, options: Partial<QueryOptions>);
    private becomeObserved;
    private becomeUnobserved;
    get isObserved(): boolean;
    private start;
    private stop;
    get isStarted(): boolean;
    private readonly intervalFetch;
    protected onStart(): void;
    protected onStop(): void;
    protected canFetch(): boolean;
    get isFetching(): boolean;
    protected get instance(): DeepReadonly<AxiosInstance>;
    fetch(): Generator<unknown, any, any>;
    get response(): Readonly<QueryResponse<T>> | undefined;
    get error(): Readonly<QueryError<E>> | undefined;
    protected setResponse(response: Readonly<QueryResponse<T>>): void;
    protected setError(error: QueryError<E> | undefined): void;
    cancel(): void;
    /**
     * Wait the response and return the response without considering it is staled or fresh.
     */
    waitResponse(): Promise<Readonly<QueryResponse<T>> | undefined>;
    /**
     * Wait the response and return the response until it is fetched.
     */
    waitFreshResponse(): Promise<Readonly<QueryResponse<T>> | undefined>;
    protected abstract fetchResponse(cancelToken: CancelToken): Promise<{
        response: QueryResponse<T>;
        headers: any;
    }>;
    /**
     * Used for saving the last response to disk.
     * This should not make observable state changes.
     * @param response
     * @protected
     */
    protected abstract saveResponse(response: Readonly<QueryResponse<T>>): Promise<void>;
    /**
     * Used for loading the last response from disk.
     * @protected
     */
    protected abstract loadStaledResponse(): Promise<QueryResponse<T> | undefined>;
}
/**
 * ObservableQuery defines the event class to query the result from endpoint.
 * This supports the stale state if previous query exists.
 */
export declare class ObservableQuery<T = unknown, E = unknown> extends ObservableQueryBase<T, E> {
    protected readonly kvStore: KVStore;
    protected static eventListener: EventEmitter;
    static refreshAllObserved(): void;
    static refreshAllObservedIfError(): void;
    protected _url: string;
    constructor(kvStore: KVStore, instance: AxiosInstance, url: string, options?: Partial<QueryOptions>);
    protected onStart(): void;
    protected onStop(): void;
    protected readonly refreshHandler: (data: any) => void;
    get url(): string;
    protected setUrl(url: string): void;
    protected fetchResponse(cancelToken: CancelToken): Promise<{
        response: QueryResponse<T>;
        headers: any;
    }>;
    protected getCacheKey(): string;
    protected saveResponse(response: Readonly<QueryResponse<T>>): Promise<void>;
    protected loadStaledResponse(): Promise<QueryResponse<T> | undefined>;
}
export declare class ObservableQueryMap<T = unknown, E = unknown> extends HasMapStore<ObservableQuery<T, E>> {
    constructor(creater: (key: string) => ObservableQuery<T, E>);
}
export * from "./json-rpc";
