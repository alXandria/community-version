"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableSecretContractChainQuery = void 0;
const chain_query_1 = require("../chain-query");
const common_1 = require("@keplr-wallet/common");
const mobx_1 = require("mobx");
const axios_1 = __importDefault(require("axios"));
const buffer_1 = require("buffer/");
class ObservableSecretContractChainQuery extends chain_query_1.ObservableChainQuery {
    constructor(kvStore, chainId, chainGetter, apiGetter, contractAddress, 
    // eslint-disable-next-line @typescript-eslint/ban-types
    obj, querySecretContractCodeHash) {
        // Don't need to set the url initially because it can't request without encyption.
        super(kvStore, chainId, chainGetter, ``);
        this.apiGetter = apiGetter;
        this.contractAddress = contractAddress;
        this.obj = obj;
        this.querySecretContractCodeHash = querySecretContractCodeHash;
        this.keplr = undefined;
        this._isIniting = false;
        mobx_1.makeObservable(this);
        // Try to get the keplr API.
        this.initKeplr();
        const disposer = mobx_1.autorun(() => {
            // If the keplr API is ready and the contract code hash is fetched, try to init.
            if (this.keplr && this.contractCodeHash) {
                this.init();
                disposer();
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    setObj(obj) {
        this.obj = obj;
        this.init();
    }
    get isFetching() {
        return (this.querySecretContractCodeHash.getQueryContract(this.contractAddress)
            .isFetching ||
            this.keplr == null ||
            this._isIniting ||
            super.isFetching);
    }
    canFetch() {
        if (!this.querySecretContractCodeHash.getQueryContract(this.contractAddress)
            .response) {
            return false;
        }
        return this.contractAddress.length !== 0 && this.nonce != null;
    }
    *initKeplr() {
        this.keplr = yield* common_1.toGenerator(this.apiGetter());
    }
    *init() {
        this._isIniting = true;
        if (this.keplr && this.contractCodeHash) {
            const enigmaUtils = this.keplr.getEnigmaUtils(this.chainId);
            const encrypted = yield* common_1.toGenerator(enigmaUtils.encrypt(this.contractCodeHash, this.obj));
            this.nonce = encrypted.slice(0, 32);
            const encoded = buffer_1.Buffer.from(buffer_1.Buffer.from(encrypted).toString("base64")).toString("hex");
            this.setUrl(`/wasm/contract/${this.contractAddress}/query/${encoded}?encoding=hex`);
        }
        this._isIniting = false;
    }
    fetchResponse(cancelToken) {
        const _super = Object.create(null, {
            fetchResponse: { get: () => super.fetchResponse }
        });
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let headers;
            try {
                const fetched = yield _super.fetchResponse.call(this, cancelToken);
                response = fetched.response;
                headers = fetched.headers;
            }
            catch (e) {
                if (!axios_1.default.isCancel(e) && ((_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error)) {
                    const encryptedError = e.response.data.error;
                    const errorMessageRgx = /rpc error: code = (.+) = encrypted: (.+): (.+)/g;
                    const rgxMatches = errorMessageRgx.exec(encryptedError);
                    if (rgxMatches != null && rgxMatches.length === 4) {
                        const errorCipherB64 = rgxMatches[2];
                        const errorCipherBz = buffer_1.Buffer.from(errorCipherB64, "base64");
                        if (this.keplr && this.nonce) {
                            const decrypted = yield this.keplr
                                .getEnigmaUtils(this.chainId)
                                .decrypt(errorCipherBz, this.nonce);
                            const errorStr = buffer_1.Buffer.from(decrypted).toString();
                            // If error is from secret wasm chain itself, decrypt the error message and throw it.
                            throw new Error(errorStr);
                        }
                    }
                }
                throw e;
            }
            const encResult = response.data;
            if (!this.keplr) {
                throw new Error("Keplr API not initialized");
            }
            if (!this.nonce) {
                throw new Error("Nonce is unknown");
            }
            if (!encResult) {
                throw new Error("Failed to get the response from the contract");
            }
            const decrypted = yield this.keplr
                .getEnigmaUtils(this.chainId)
                .decrypt(buffer_1.Buffer.from(encResult.result.smart, "base64"), this.nonce);
            const message = buffer_1.Buffer.from(buffer_1.Buffer.from(decrypted).toString(), "base64").toString();
            const obj = JSON.parse(message);
            return {
                headers,
                response: {
                    data: obj,
                    status: response.status,
                    staled: false,
                    timestamp: Date.now(),
                },
            };
        });
    }
    // Actually, the url of fetching the secret20 balance will be changed every time.
    // So, we should save it with deterministic key.
    getCacheKey() {
        return `${this.instance.name}-${this.instance.defaults.baseURL}${this.instance.getUri({
            url: `/wasm/contract/${this.contractAddress}/query/${JSON.stringify(this.obj)}?encoding=json`,
        })}`;
    }
    get contractCodeHash() {
        const queryCodeHash = this.querySecretContractCodeHash.getQueryContract(this.contractAddress);
        if (!queryCodeHash.response) {
            return undefined;
        }
        // Code hash is persistent, so it is safe not to consider that the response is from cache or network.
        // TODO: Handle the error case.
        return queryCodeHash.response.data.result;
    }
}
__decorate([
    mobx_1.observable.ref
], ObservableSecretContractChainQuery.prototype, "keplr", void 0);
__decorate([
    mobx_1.observable
], ObservableSecretContractChainQuery.prototype, "_isIniting", void 0);
__decorate([
    mobx_1.flow
], ObservableSecretContractChainQuery.prototype, "initKeplr", null);
__decorate([
    mobx_1.flow
], ObservableSecretContractChainQuery.prototype, "init", null);
__decorate([
    mobx_1.computed
], ObservableSecretContractChainQuery.prototype, "contractCodeHash", null);
exports.ObservableSecretContractChainQuery = ObservableSecretContractChainQuery;
//# sourceMappingURL=contract-query.js.map