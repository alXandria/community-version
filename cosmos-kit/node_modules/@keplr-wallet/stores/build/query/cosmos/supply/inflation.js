"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryInflation = void 0;
const mobx_1 = require("mobx");
const unit_1 = require("@keplr-wallet/unit");
class ObservableQueryInflation {
    constructor(chainId, chainGetter, _queryMint, _queryPool, _querySupplyTotal, _queryIrisMint, _querySifchainAPY, _queryOsmosisEpochs, _queryOsmosisEpochProvisions, _queryOsmosisMintParams, _queryJunoAnnualProvisions, _queryDistributionParams) {
        this.chainId = chainId;
        this.chainGetter = chainGetter;
        this._queryMint = _queryMint;
        this._queryPool = _queryPool;
        this._querySupplyTotal = _querySupplyTotal;
        this._queryIrisMint = _queryIrisMint;
        this._querySifchainAPY = _querySifchainAPY;
        this._queryOsmosisEpochs = _queryOsmosisEpochs;
        this._queryOsmosisEpochProvisions = _queryOsmosisEpochProvisions;
        this._queryOsmosisMintParams = _queryOsmosisMintParams;
        this._queryJunoAnnualProvisions = _queryJunoAnnualProvisions;
        this._queryDistributionParams = _queryDistributionParams;
        mobx_1.makeObservable(this);
    }
    get error() {
        var _a, _b;
        return ((_b = (_a = this._queryMint.error) !== null && _a !== void 0 ? _a : this._queryPool.error) !== null && _b !== void 0 ? _b : this._querySupplyTotal.getQueryStakeDenom().error);
    }
    get isFetching() {
        return (this._queryMint.isFetching ||
            this._queryPool.isFetching ||
            this._querySupplyTotal.getQueryStakeDenom().isFetching);
    }
    // Return an inflation as `IntPrety`.
    // If the staking pool info is fetched, this will consider this info for calculating the more accurate value.
    get inflation() {
        // TODO: Use `RatePretty`
        var _a, _b, _c, _d;
        try {
            let dec;
            // XXX: Hard coded part for the iris hub and sifchain.
            // TODO: Remove this part.
            const chainInfo = this.chainGetter.getChain(this.chainId);
            if (chainInfo.chainId.startsWith("irishub")) {
                dec = new unit_1.Dec((_b = (_a = this._queryIrisMint.response) === null || _a === void 0 ? void 0 : _a.data.result.inflation) !== null && _b !== void 0 ? _b : "0").mul(unit_1.DecUtils.getPrecisionDec(2));
            }
            else if (chainInfo.chainId.startsWith("sifchain")) {
                return new unit_1.IntPretty(new unit_1.Dec(this._querySifchainAPY.liquidityAPY.toString()));
            }
            else if (chainInfo.chainId.startsWith("osmosis")) {
                /*
                  XXX: Temporary and unfinished implementation for the osmosis staking APY.
                       Osmosis has different minting method.
                       It mints the fixed token per epoch with deduction feature on the range of epoch.
                       And, it actually doesn't mint the token, it has the locked token that will be inflated.
                       So, currently, using the result of `supply total` to calculate the APY is actually not valid
                       because it included the locked token that is not yet inflated.
                       So, for now, just assume that the curreny supply is 100,000,000.
                 */
                const mintParams = this._queryOsmosisMintParams;
                if (mintParams.epochIdentifier) {
                    const epochDuration = this._queryOsmosisEpochs.getEpoch(mintParams.epochIdentifier).duration;
                    if (epochDuration) {
                        const epochProvision = this._queryOsmosisEpochProvisions
                            .epochProvisions;
                        if (epochProvision &&
                            this._querySupplyTotal.getQueryStakeDenom().response) {
                            const mintingEpochProvision = new unit_1.Dec(epochProvision
                                .toDec()
                                .mul(mintParams.distributionProportions.staking)
                                .truncate()
                                .toString());
                            const yearMintingProvision = mintingEpochProvision.mul(new unit_1.Dec(((365 * 24 * 3600) / epochDuration).toString()));
                            const total = unit_1.DecUtils.getPrecisionDec(8);
                            dec = yearMintingProvision
                                .quo(total)
                                .mul(unit_1.DecUtils.getPrecisionDec(2));
                        }
                    }
                }
            }
            else if (chainInfo.chainId.startsWith("juno")) {
                // In juno, the actual supply on chain and the supply recognized by the community are different.
                // I don't know why, but it's annoying to deal with this problem.
                if (this._queryJunoAnnualProvisions.annualProvisionsRaw &&
                    this._queryPool.response) {
                    const bondedToken = new unit_1.Dec(this._queryPool.response.data.pool.bonded_tokens);
                    const dec = this._queryJunoAnnualProvisions.annualProvisionsRaw
                        .quo(bondedToken)
                        .mul(new unit_1.Dec(1).sub(this._queryDistributionParams.communityTax.toDec()))
                        .mul(unit_1.DecUtils.getTenExponentN(2));
                    return new unit_1.IntPretty(dec);
                }
            }
            else {
                dec = new unit_1.Dec((_d = (_c = this._queryMint.response) === null || _c === void 0 ? void 0 : _c.data.inflation) !== null && _d !== void 0 ? _d : "0").mul(unit_1.DecUtils.getPrecisionDec(2));
            }
            if (!dec || dec.equals(new unit_1.Dec(0))) {
                return new unit_1.IntPretty(new unit_1.Int(0)).ready(false);
            }
            if (this._queryPool.response &&
                this._querySupplyTotal.getQueryStakeDenom().response) {
                const bondedToken = new unit_1.Dec(this._queryPool.response.data.pool.bonded_tokens);
                const totalStr = (() => {
                    if (chainInfo.chainId.startsWith("osmosis")) {
                        // For osmosis, for now, just assume that the current supply is 100,000,000 with 6 decimals.
                        return unit_1.DecUtils.getPrecisionDec(8 + 6).toString();
                    }
                    return this._querySupplyTotal.getQueryStakeDenom().response.data
                        .amount.amount;
                })();
                const total = new unit_1.Dec(totalStr);
                if (total.gt(new unit_1.Dec(0))) {
                    // staking APR is calculated as:
                    //   new_coins_per_year = inflation_pct * total_supply * (1 - community_pool_tax)
                    //   apr = new_coins_per_year / total_bonded_tokens
                    const ratio = bondedToken.quo(total);
                    dec = dec
                        .mul(new unit_1.Dec(1).sub(this._queryDistributionParams.communityTax.toDec()))
                        .quo(ratio);
                    // TODO: Rounding?
                }
            }
            return new unit_1.IntPretty(dec);
        }
        catch (e) {
            console.log(e);
            // XXX: There have been reported errors regarding Sifchain.
            // However, I wasn’t able to reproduce the error so exact cause haven’t been identified.
            // For now, use try-catch on suspect parts to resolve the issue. Will be on a lookout for a more permanent solution in the future.
            return new unit_1.IntPretty(new unit_1.Int(0)).ready(false);
        }
    }
}
__decorate([
    mobx_1.computed
], ObservableQueryInflation.prototype, "inflation", null);
exports.ObservableQueryInflation = ObservableQueryInflation;
//# sourceMappingURL=inflation.js.map