"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryCosmosBalanceRegistry = exports.ObservableQueryCosmosBalances = exports.ObservableQueryBalanceNative = void 0;
const common_1 = require("@keplr-wallet/common");
const mobx_1 = require("mobx");
const unit_1 = require("@keplr-wallet/unit");
const common_2 = require("../../../common");
const balances_1 = require("../../balances");
const chain_query_1 = require("../../chain-query");
class ObservableQueryBalanceNative extends balances_1.ObservableQueryBalanceInner {
    constructor(kvStore, chainId, chainGetter, denomHelper, nativeBalances) {
        super(kvStore, chainId, chainGetter, 
        // No need to set the url
        "", denomHelper);
        this.nativeBalances = nativeBalances;
        mobx_1.makeObservable(this);
    }
    canFetch() {
        return false;
    }
    get isFetching() {
        return this.nativeBalances.isFetching;
    }
    get error() {
        return this.nativeBalances.error;
    }
    get response() {
        return this.nativeBalances.response;
    }
    *fetch() {
        yield this.nativeBalances.fetch();
    }
    get balance() {
        const currency = this.currency;
        if (!this.nativeBalances.response) {
            return new unit_1.CoinPretty(currency, new unit_1.Int(0)).ready(false);
        }
        return common_2.StoreUtils.getBalanceFromCurrency(currency, this.nativeBalances.response.data.balances);
    }
}
__decorate([
    mobx_1.override
], ObservableQueryBalanceNative.prototype, "fetch", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalanceNative.prototype, "balance", null);
exports.ObservableQueryBalanceNative = ObservableQueryBalanceNative;
class ObservableQueryCosmosBalances extends chain_query_1.ObservableChainQuery {
    constructor(kvStore, chainId, chainGetter, bech32Address) {
        super(kvStore, chainId, chainGetter, `/cosmos/bank/v1beta1/balances/${bech32Address}?pagination.limit=1000`);
        this.duplicatedFetchCheck = false;
        this.bech32Address = bech32Address;
        mobx_1.makeObservable(this);
    }
    canFetch() {
        // If bech32 address is empty, it will always fail, so don't need to fetch it.
        return this.bech32Address.length > 0;
    }
    *fetch() {
        if (!this.duplicatedFetchCheck) {
            // Because the native "bank" module's balance shares the querying result,
            // it is inefficient to fetching duplicately in the same loop.
            // So, if the fetching requests are in the same tick, this prevent to refetch the result and use the prior fetching.
            this.duplicatedFetchCheck = true;
            setTimeout(() => {
                this.duplicatedFetchCheck = false;
            }, 1);
            yield super.fetch();
        }
    }
    setResponse(response) {
        super.setResponse(response);
        const chainInfo = this.chainGetter.getChain(this.chainId);
        // 반환된 response 안의 denom을 등록하도록 시도한다.
        // 어차피 이미 등록되어 있으면 밑의 메소드가 아무 행동도 안하기 때문에 괜찮다.
        // computed를 줄이기 위해서 배열로 한번에 설정하는게 낫다.
        const denoms = response.data.balances.map((coin) => coin.denom);
        chainInfo.addUnknownCurrencies(...denoms);
    }
}
__decorate([
    mobx_1.override
], ObservableQueryCosmosBalances.prototype, "fetch", null);
exports.ObservableQueryCosmosBalances = ObservableQueryCosmosBalances;
class ObservableQueryCosmosBalanceRegistry {
    constructor(kvStore) {
        this.kvStore = kvStore;
        this.nativeBalances = new Map();
    }
    getBalanceInner(chainId, chainGetter, bech32Address, minimalDenom) {
        const denomHelper = new common_1.DenomHelper(minimalDenom);
        if (denomHelper.type !== "native") {
            return;
        }
        const key = `${chainId}/${bech32Address}`;
        if (!this.nativeBalances.has(key)) {
            this.nativeBalances.set(key, new ObservableQueryCosmosBalances(this.kvStore, chainId, chainGetter, bech32Address));
        }
        return new ObservableQueryBalanceNative(this.kvStore, chainId, chainGetter, denomHelper, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.nativeBalances.get(key));
    }
}
exports.ObservableQueryCosmosBalanceRegistry = ObservableQueryCosmosBalanceRegistry;
//# sourceMappingURL=balances.js.map