"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryProposal = void 0;
const chain_query_1 = require("../../chain-query");
const types_1 = require("./types");
const mobx_1 = require("mobx");
const unit_1 = require("@keplr-wallet/unit");
class ObservableQueryProposal extends chain_query_1.ObservableChainQuery {
    constructor(kvStore, chainId, chainGetter, _raw, governance) {
        super(kvStore, chainId, chainGetter, `/cosmos/gov/v1beta1/proposals/${_raw.proposal_id}/tally`);
        this._raw = _raw;
        this.governance = governance;
        mobx_1.makeObservable(this);
    }
    canFetch() {
        return this.proposalStatus === types_1.ProposalStatus.VOTING_PERIOD;
    }
    get raw() {
        return this._raw;
    }
    get proposalStatus() {
        switch (this.raw.status) {
            case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
                return types_1.ProposalStatus.DEPOSIT_PERIOD;
            case "PROPOSAL_STATUS_VOTING_PERIOD":
                return types_1.ProposalStatus.VOTING_PERIOD;
            case "PROPOSAL_STATUS_PASSED":
                return types_1.ProposalStatus.PASSED;
            case "PROPOSAL_STATUS_REJECTED":
                return types_1.ProposalStatus.REJECTED;
            case "PROPOSAL_STATUS_FAILED":
                return types_1.ProposalStatus.FAILED;
            default:
                return types_1.ProposalStatus.UNSPECIFIED;
        }
    }
    get id() {
        return this.raw.proposal_id;
    }
    get title() {
        return this.raw.content.title;
    }
    get description() {
        return this.raw.content.description;
    }
    get turnout() {
        const pool = this.governance.getQueryPool();
        const bondedTokenDec = pool.bondedTokens.toDec();
        if (!pool.response || bondedTokenDec.equals(new unit_1.Dec(0))) {
            return new unit_1.IntPretty(new unit_1.Dec(0)).ready(false);
        }
        const tally = this.tally;
        const tallySum = tally.yes
            .add(tally.no)
            .add(tally.abstain)
            .add(tally.noWithVeto);
        // TODO: Use `RatePretty`
        return new unit_1.IntPretty(tallySum
            .toDec()
            .quoTruncate(bondedTokenDec)
            .mulTruncate(unit_1.DecUtils.getPrecisionDec(2))).ready(tally.yes.isReady);
    }
    /**
     * Return the voting tally.
     * If the proposal status is passed or rejected, it returns the final tally of the proposal.
     * If the proposal status is in voting period, it queries the tally to the rest endpoint.
     * If the querying of tally is not completed, it return the tally with all 0 with not ready option.
     */
    get tally() {
        const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;
        if (this.proposalStatus !== types_1.ProposalStatus.VOTING_PERIOD) {
            return {
                yes: new unit_1.IntPretty(new unit_1.Int(this.raw.final_tally_result.yes))
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                no: new unit_1.IntPretty(new unit_1.Int(this.raw.final_tally_result.no))
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                abstain: new unit_1.IntPretty(new unit_1.Int(this.raw.final_tally_result.abstain))
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                noWithVeto: new unit_1.IntPretty(new unit_1.Int(this.raw.final_tally_result.no_with_veto))
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
            };
        }
        if (!this.response) {
            return {
                yes: new unit_1.IntPretty(new unit_1.Int(0))
                    .ready(false)
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                no: new unit_1.IntPretty(new unit_1.Int(0))
                    .ready(false)
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                abstain: new unit_1.IntPretty(new unit_1.Int(0))
                    .ready(false)
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
                noWithVeto: new unit_1.IntPretty(new unit_1.Int(0))
                    .ready(false)
                    .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                    .maxDecimals(stakeCurrency.coinDecimals),
            };
        }
        return {
            yes: new unit_1.IntPretty(new unit_1.Int(this.response.data.tally.yes))
                .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                .maxDecimals(stakeCurrency.coinDecimals),
            no: new unit_1.IntPretty(new unit_1.Int(this.response.data.tally.no))
                .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                .maxDecimals(stakeCurrency.coinDecimals),
            abstain: new unit_1.IntPretty(new unit_1.Int(this.response.data.tally.abstain))
                .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                .maxDecimals(stakeCurrency.coinDecimals),
            noWithVeto: new unit_1.IntPretty(new unit_1.Int(this.response.data.tally.no_with_veto))
                .moveDecimalPointLeft(stakeCurrency.coinDecimals)
                .maxDecimals(stakeCurrency.coinDecimals),
        };
    }
    get total() {
        const tally = this.tally;
        const tallySum = tally.yes
            .add(tally.no)
            .add(tally.abstain)
            .add(tally.noWithVeto);
        const stakeCurrency = this.chainGetter.getChain(this.chainId).stakeCurrency;
        return new unit_1.CoinPretty(stakeCurrency, tallySum);
    }
    get tallyRatio() {
        const tally = this.tally;
        const tallySum = tally.yes
            .add(tally.no)
            .add(tally.abstain)
            .add(tally.noWithVeto);
        if (tallySum.toDec().equals(new unit_1.Dec(0))) {
            return {
                yes: new unit_1.IntPretty(new unit_1.Int(0)).ready(false),
                no: new unit_1.IntPretty(new unit_1.Int(0)).ready(false),
                abstain: new unit_1.IntPretty(new unit_1.Int(0)).ready(false),
                noWithVeto: new unit_1.IntPretty(new unit_1.Int(0)).ready(false),
            };
        }
        // TODO: Use `RatePretty`
        return {
            yes: new unit_1.IntPretty(tally.yes
                .toDec()
                .quoTruncate(tallySum.toDec())
                .mulTruncate(unit_1.DecUtils.getPrecisionDec(2))).ready(tally.yes.isReady),
            no: new unit_1.IntPretty(tally.no
                .toDec()
                .quoTruncate(tallySum.toDec())
                .mulTruncate(unit_1.DecUtils.getPrecisionDec(2))).ready(tally.no.isReady),
            abstain: new unit_1.IntPretty(tally.abstain
                .toDec()
                .quoTruncate(tallySum.toDec())
                .mulTruncate(unit_1.DecUtils.getPrecisionDec(2))).ready(tally.abstain.isReady),
            noWithVeto: new unit_1.IntPretty(tally.noWithVeto
                .toDec()
                .quoTruncate(tallySum.toDec())
                .mulTruncate(unit_1.DecUtils.getPrecisionDec(2))).ready(tally.noWithVeto.isReady),
        };
    }
}
__decorate([
    mobx_1.computed
], ObservableQueryProposal.prototype, "turnout", null);
__decorate([
    mobx_1.computed
], ObservableQueryProposal.prototype, "tally", null);
__decorate([
    mobx_1.computed
], ObservableQueryProposal.prototype, "total", null);
__decorate([
    mobx_1.computed
], ObservableQueryProposal.prototype, "tallyRatio", null);
exports.ObservableQueryProposal = ObservableQueryProposal;
//# sourceMappingURL=proposal.js.map