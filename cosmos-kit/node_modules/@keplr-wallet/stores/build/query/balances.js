"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableQueryBalances = exports.ObservableQueryBalancesInner = exports.ObservableQueryBalanceInner = void 0;
const chain_query_1 = require("./chain-query");
const common_1 = require("@keplr-wallet/common");
const mobx_1 = require("mobx");
const unit_1 = require("@keplr-wallet/unit");
const common_2 = require("../common");
const mobx_utils_1 = require("mobx-utils");
class ObservableQueryBalanceInner extends chain_query_1.ObservableChainQuery {
    constructor(kvStore, chainId, chainGetter, url, denomHelper) {
        super(kvStore, chainId, chainGetter, url);
        this.denomHelper = denomHelper;
        mobx_1.makeObservable(this);
    }
    get currency() {
        const denom = this.denomHelper.denom;
        const chainInfo = this.chainGetter.getChain(this.chainId);
        const currency = chainInfo.findCurrency(denom);
        // TODO: Infer the currency according to its denom (such if denom is `uatom` -> `Atom` with decimal 6)?
        if (!currency) {
            throw new Error(`Unknown currency: ${denom}`);
        }
        return currency;
    }
}
__decorate([
    mobx_1.computed
], ObservableQueryBalanceInner.prototype, "currency", null);
exports.ObservableQueryBalanceInner = ObservableQueryBalanceInner;
class ObservableQueryBalancesInner {
    constructor(kvStore, chainId, chainGetter, balanceRegistries, bech32Address) {
        this.kvStore = kvStore;
        this.chainId = chainId;
        this.chainGetter = chainGetter;
        this.balanceRegistries = balanceRegistries;
        this.balanceMap = new Map();
        this.getBalanceFromCurrency = mobx_utils_1.computedFn((currency) => {
            const bal = this.balances.find((bal) => bal.currency.coinMinimalDenom === currency.coinMinimalDenom);
            if (bal) {
                return bal.balance;
            }
            return new unit_1.CoinPretty(currency, new unit_1.Int(0));
        });
        mobx_1.makeObservable(this);
        this.bech32Address = bech32Address;
    }
    fetch() {
        this.balanceMap.forEach((bal) => bal.fetch());
    }
    getBalanceInner(currency) {
        let key = currency.coinMinimalDenom;
        // If the currency is secret20, it will be different according to not only the minimal denom but also the viewing key of the currency.
        if ("type" in currency && currency.type === "secret20") {
            key = currency.coinMinimalDenom + "/" + currency.viewingKey;
        }
        if (!this.balanceMap.has(key)) {
            mobx_1.runInAction(() => {
                let balanceInner;
                for (const registry of this.balanceRegistries) {
                    balanceInner = registry.getBalanceInner(this.chainId, this.chainGetter, this.bech32Address, currency.coinMinimalDenom);
                    if (balanceInner) {
                        break;
                    }
                }
                if (balanceInner) {
                    this.balanceMap.set(key, balanceInner);
                }
                else {
                    throw new Error(`Failed to get and parse the balance for ${key}`);
                }
            });
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.balanceMap.get(key);
    }
    get stakable() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        return this.getBalanceInner(chainInfo.stakeCurrency);
    }
    /**
     * 알려진 모든 Currency들의 balance를 반환환다.
     */
    get balances() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        const result = [];
        for (let i = 0; i < chainInfo.currencies.length; i++) {
            const currency = chainInfo.currencies[i];
            result.push(this.getBalanceInner(currency));
        }
        return result;
    }
    /**
     * 알려진 모든 Currency들 중 0 이상의 잔고를 가진 balance를 반환환다.
     */
    get positiveBalances() {
        const balances = this.balances;
        return balances.filter((bal) => bal.balance.toDec().gt(new unit_1.Dec(0)));
    }
    /**
     * Returns that the balances that are not native tokens.
     * Native token means that the token that exists on the `bank` module.
     */
    get nonNativeBalances() {
        const balances = this.balances;
        return balances.filter((bal) => new common_1.DenomHelper(bal.currency.coinMinimalDenom).type !== "native");
    }
    /**
     * Returns that the balances that are native tokens with greater than 0 balance.
     * Native token means that the token that exists on the `bank` module.
     */
    get positiveNativeUnstakables() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        const balances = this.balances;
        return balances.filter((bal) => new common_1.DenomHelper(bal.currency.coinMinimalDenom).type === "native" &&
            bal.balance.toDec().gt(new unit_1.Dec(0)) &&
            bal.currency.coinMinimalDenom !==
                chainInfo.stakeCurrency.coinMinimalDenom);
    }
    get unstakables() {
        const chainInfo = this.chainGetter.getChain(this.chainId);
        const currencies = chainInfo.currencies.filter((cur) => cur.coinMinimalDenom !== chainInfo.stakeCurrency.coinMinimalDenom);
        const result = [];
        for (let i = 0; i < currencies.length; i++) {
            const currency = currencies[i];
            result.push(this.getBalanceInner(currency));
        }
        return result;
    }
}
__decorate([
    mobx_1.observable.shallow
], ObservableQueryBalancesInner.prototype, "balanceMap", void 0);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "stakable", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "balances", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "positiveBalances", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "nonNativeBalances", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "positiveNativeUnstakables", null);
__decorate([
    mobx_1.computed
], ObservableQueryBalancesInner.prototype, "unstakables", null);
exports.ObservableQueryBalancesInner = ObservableQueryBalancesInner;
class ObservableQueryBalances extends common_2.HasMapStore {
    constructor(kvStore, chainId, chainGetter) {
        super((bech32Address) => {
            return new ObservableQueryBalancesInner(this.kvStore, this.chainId, this.chainGetter, this.balanceRegistries, bech32Address);
        });
        this.kvStore = kvStore;
        this.chainId = chainId;
        this.chainGetter = chainGetter;
        this.balanceRegistries = [];
    }
    addBalanceRegistry(registry) {
        this.balanceRegistries.push(registry);
    }
    getQueryBech32Address(bech32Address) {
        return this.get(bech32Address);
    }
}
exports.ObservableQueryBalances = ObservableQueryBalances;
//# sourceMappingURL=balances.js.map