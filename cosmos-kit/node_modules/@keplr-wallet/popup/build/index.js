"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableScroll = exports.disableScroll = exports.fitPopupWindow = exports.closePopupWindow = exports.openPopupWindow = exports.PopupSize = void 0;
exports.PopupSize = {
    width: 360,
    height: 580,
};
const lastWindowIds = {};
/**
 * Try open window if no previous window exists.
 * If, previous window exists, try to change the location of this window.
 * Finally, try to recover focusing for opened window.
 * @param url
 */
function openPopupWindow(url, channel = "default", options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const option = Object.assign({ width: exports.PopupSize.width, height: exports.PopupSize.height, url: url, type: "popup" }, options);
        if (lastWindowIds[channel] !== undefined) {
            try {
                const window = yield browser.windows.get(lastWindowIds[channel], {
                    populate: true,
                });
                if ((_a = window === null || window === void 0 ? void 0 : window.tabs) === null || _a === void 0 ? void 0 : _a.length) {
                    const tab = window.tabs[0];
                    if (tab === null || tab === void 0 ? void 0 : tab.id) {
                        yield browser.tabs.update(tab.id, { active: true, url });
                    }
                    else {
                        throw new Error("Null window or tabs");
                    }
                }
                else {
                    throw new Error("Null window or tabs");
                }
            }
            catch (_b) {
                lastWindowIds[channel] = (yield browser.windows.create(option)).id;
            }
        }
        else {
            lastWindowIds[channel] = (yield browser.windows.create(option)).id;
        }
        if (lastWindowIds[channel]) {
            try {
                yield browser.windows.update(lastWindowIds[channel], {
                    focused: true,
                });
            }
            catch (e) {
                console.log(`Failed to update window focus: ${e.message}`);
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return lastWindowIds[channel];
    });
}
exports.openPopupWindow = openPopupWindow;
function closePopupWindow(channel) {
    (() => __awaiter(this, void 0, void 0, function* () {
        const windowId = lastWindowIds[channel];
        if (windowId) {
            yield browser.windows.remove(windowId);
        }
    }))();
}
exports.closePopupWindow = closePopupWindow;
/**
 * window.open() has many options for sizing, but they require different ways to do this per web browser.
 * So, to avoid this problem, just manually set sizing if new window popup is opened.
 */
function fitPopupWindow() {
    // Get the gap size like title bar or menu bar, etc...
    const gap = {
        width: window.outerWidth - window.innerWidth,
        height: window.outerHeight - window.innerHeight,
    };
    if (browser.windows) {
        browser.windows.getCurrent().then((window) => {
            if ((window === null || window === void 0 ? void 0 : window.id) != null) {
                browser.windows.update(window.id, {
                    width: exports.PopupSize.width + gap.width,
                    height: exports.PopupSize.height + gap.height,
                });
            }
        });
        return;
    }
    window.resizeTo(exports.PopupSize.width + gap.width, exports.PopupSize.height + gap.height);
}
exports.fitPopupWindow = fitPopupWindow;
/**
 * In some case, opened window has scrollbar even if scroll is unnecessary.
 * This can spoil the layout of content slightly.
 * So, if you are sure you don't need scrolling, use this function to remove scrolling.
 */
function disableScroll() {
    const html = document.getElementsByTagName("html");
    html[0].style.overflow = "hidden";
}
exports.disableScroll = disableScroll;
function enableScroll() {
    const html = document.getElementsByTagName("html");
    html[0].style.overflow = "";
}
exports.enableScroll = enableScroll;
//# sourceMappingURL=index.js.map